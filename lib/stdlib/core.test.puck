import 'puck:test' as *
import 'core.puck' as {
  IntoIterator
  Iterator
  List
  None
  Num
  Radix
  Option
  Range
  Result
  String
}

fn any(a) {a}

describe('core', || {
  describe('Num', || {
    describe('parseInt', || {
      it('should default to parse decimal numbers', || {
        expect(Num.parseInt('1')).toEqual(Ok(1))
        expect(Num.parseInt('0')).toEqual(Ok(0))
        expect(Num.parseInt('10')).toEqual(Ok(10))
        expect(Num.parseInt('-123456789')).toEqual(Ok(-123456789))
      })

      it('should be able to parse binary numbers', || {
        expect(Num.parseInt('1', Radix::Binary)).toEqual(Ok(1))
        expect(Num.parseInt('0', Radix::Binary)).toEqual(Ok(0))
        expect(Num.parseInt('10', Radix::Binary)).toEqual(Ok(2))
        expect(Num.parseInt('-101', Radix::Binary)).toEqual(Ok(-5))
      })

      it('should be able to parse octal numbers', || {
        expect(Num.parseInt('1', Radix::Octal)).toEqual(Ok(1))
        expect(Num.parseInt('0', Radix::Octal)).toEqual(Ok(0))
        expect(Num.parseInt('10', Radix::Octal)).toEqual(Ok(8))
        expect(Num.parseInt('-107', Radix::Octal)).toEqual(Ok(-71))
      })

      it('should be able to parse hex numbers', || {
        expect(Num.parseInt('1', Radix::Hex)).toEqual(Ok(1))
        expect(Num.parseInt('0', Radix::Hex)).toEqual(Ok(0))
        expect(Num.parseInt('f', Radix::Hex)).toEqual(Ok(15))
        expect(Num.parseInt('F', Radix::Hex)).toEqual(Ok(15))
        expect(Num.parseInt('10', Radix::Hex)).toEqual(Ok(16))
        expect(Num.parseInt('-10e9f', Radix::Hex)).toEqual(Ok(-69279))
        expect(Num.parseInt('-10E9F', Radix::Hex)).toEqual(Ok(-69279))
      })

      it('should error for invalid characters', || {
        expect(Num.parseInt('A')).toEqual(Err(()))
        expect(Num.parseInt('2', Radix::Binary)).toEqual(Err(()))
        expect(Num.parseInt('8', Radix::Octal)).toEqual(Err(()))
        expect(Num.parseInt('G', Radix::Hex)).toEqual(Err(()))
        expect(Num.parseInt('2341A')).toEqual(Err(()))
        expect(Num.parseInt('1010112', Radix::Binary)).toEqual(Err(()))
        expect(Num.parseInt('1232648', Radix::Octal)).toEqual(Err(()))
        expect(Num.parseInt('1289AC6G', Radix::Hex)).toEqual(Err(()))
      })
    })

    describe('parse', || {
      it('should be able to parse integers', || {
        expect(Num.parse('1')).toEqual(Ok(1))
        expect(Num.parse('0')).toEqual(Ok(0))
        expect(Num.parse('10')).toEqual(Ok(10))
        expect(Num.parse('-123456789')).toEqual(Ok(-123456789))
      })

      it('should be able to parse doubles', || {
        expect(Num.parse('1.03')).toEqual(Ok(1.03))
        expect(Num.parse('0.5')).toEqual(Ok(0.5))
        expect(Num.parse('10.12')).toEqual(Ok(10.12))
        expect(Num.parse('-123456789.123')).toEqual(Ok(-123456789.123))
      })
    })

    describe('isNan', || {
      it('should return false for normal numbers', || {
        expect(1.isNan()).toBe(false)
        expect(1.04.isNan()).toBe(false)
        expect(100.isNan()).toBe(false)
        expect((-50).isNan()).toBe(false)
      })

      it('should return true for nan', || {
        let nan: Num = 0/0
        expect(nan.isNan()).toBe(true)
      })
    })

    describe('isInfinite', || {
      it('should return false for normal numbers', || {
        expect(1.isInfinite()).toBe(false)
        expect(1.04.isInfinite()).toBe(false)
        expect(100.isInfinite()).toBe(false)
        expect((-50).isInfinite()).toBe(false)
      })

      it('should return true for infinity', || {
        let positiveInfinity: Num = 1/0
        let negativeInfinity: Num = -1/0
        expect(positiveInfinity.isInfinite()).toBe(true)
        expect(negativeInfinity.isInfinite()).toBe(true)
      })
    })

    describe('ceil', || {
      it('should should always away from zero', || {
        expect(1.ceil()).toBe(1)
        expect(1.5.ceil()).toBe(2)
        expect(-0.4.ceil()).toBe(-1)
        expect(10.4.ceil()).toBe(11)
        expect(-10.4.ceil()).toBe(-11)
      })
    })

    describe('floor', || {
      it('should should always round towards zero', || {
        expect(1.floor()).toBe(1)
        expect(1.5.floor()).toBe(1)
        expect(-0.4.floor()).toBe(-0)
        expect(10.4.floor()).toBe(10)
        expect(-10.4.floor()).toBe(-10)
      })
    })

    describe('round', || {
      it('should should round using normal rules', || {
        expect(1.round()).toBe(1)
        expect(1.5.round()).toBe(2)
        expect(-0.4.round()).toBe(-0)
        expect(-0.5.round()).toBe(-1)
        expect(10.4.round()).toBe(10)
        expect(10.5.round()).toBe(11)
        expect(-10.4.round()).toBe(-10)
        expect(-10.5.round()).toBe(-11)
      })
    })

    describe('limit', || {
      it('should return the start of range if the number is less than the start', || {
        expect(5.limit({start: 10, end: 50})).toBe(10)
        expect(0.limit({start: 5, end: 50})).toBe(5)
        expect((-100).limit({start: -50, end: -10})).toBe(-50)
      })

      it('should return the end of range if the number is greater than the end', || {
        expect(100.limit({start: 10, end: 50})).toBe(49)
        expect((-5).limit({start: -50, end: -10})).toBe(-11)
      })

      it('should return the number if it is with the range', || {
        expect(11.limit({start: 10, end: 50})).toBe(11)
        expect(49.limit({start: 10, end: 50})).toBe(49)
        expect(20.limit({start: 10, end: 50})).toBe(20)
        expect(0.limit({start: -10, end: 10})).toBe(0)
        expect((-10).limit({start: -50, end: -5})).toBe(-10)
      })
    })
  })

  describe('String', || {
    describe('contains', || {
      it('should return true if the string contains the substring', || {
        expect('abcdefg'.contains('abc')).toBe(true)
        expect('abcdefg'.contains('efg')).toBe(true)
        expect('abcdefg'.contains('cde')).toBe(true)
        expect('abcdefg'.contains('c')).toBe(true)
        expect('abcdefg'.contains('abcdefg')).toBe(true)
      })

      it('should return false if the string does not contain the substring', || {
        expect('abcdefg'.contains('cba')).toBe(false)
        expect('abcdefg'.contains('efgh')).toBe(false)
        expect('abcdefg'.contains('ced')).toBe(false)
        expect('abcdefg'.contains('h')).toBe(false)
        expect('abcdefg'.contains('abcdefgh')).toBe(false)
      })
    })

    describe('split', || {
      it('should default to split at each character', || {
        expect('abcdefg'.split()).toEqual(['a', 'b', 'c', 'd', 'e', 'f', 'g'])
      })

      it('should split at the provided pattern', || {
        expect('hello world'.split(' ')).toEqual(['hello', 'world'])
        expect('hello, world'.split(' ')).toEqual(['hello,', 'world'])
        expect('hello, world'.split(', ')).toEqual(['hello', 'world'])
      })
    })

    describe('padLeft', || {
      it('should not pad the string if the width is >= width', || {
        expect('Hello'.padLeft(5)).toEqual('Hello')
        expect('Hello'.padLeft(2)).toEqual('Hello')
        expect('Hello'.padLeft(-2)).toEqual('Hello')
      })

      it('should pad the string with spaces if the width is < width', || {
        expect('Hello'.padLeft(10)).toEqual('     Hello')
      })

      it('should pad the string with spaces if the passed padding is an empty string and width is < width', || {
        expect('Hello'.padLeft(10, '')).toEqual('     Hello')
      })

      it('should pad the string with passed padding if the width is < width', || {
        expect('Hello'.padLeft(10, '*')).toEqual('*****Hello')
        expect('Hello'.padLeft(10, '**')).toEqual('******Hello')
      })
    })

    describe('padRight', || {
      it('should not pad the string if the width is >= width', || {
        expect('Hello'.padRight(5)).toEqual('Hello')
        expect('Hello'.padRight(2)).toEqual('Hello')
        expect('Hello'.padRight(-2)).toEqual('Hello')
      })

      it('should pad the string with spaces if the width is < width', || {
        expect('Hello'.padRight(10)).toEqual('Hello     ')
      })

      it('should pad the string with spaces if the passed padding is an empty string and width is < width', || {
        expect('Hello'.padRight(10, '')).toEqual('Hello     ')
      })

      it('should pad the string with passed padding if the width is < width', || {
        expect('Hello'.padRight(10, '*')).toEqual('Hello*****')
        expect('Hello'.padRight(10, '**')).toEqual('Hello******')
      })
    })

    describe('toLowerCase', || {
      it('should convert characters to lower case', || {
        expect('abcABCåäöÅÄÖ'.toLowerCase()).toEqual('abcabcåäöåäö')
      })
    })

    describe('toUpperCase', || {
      it('should convert characters to upper case', || {
        expect('abcABCåäöÅÄÖ'.toUpperCase()).toEqual('ABCABCÅÄÖÅÄÖ')
      })
    })

    describe('trim', || {
      it('should remove whitespace', || {
        expect(''.trim()).toEqual('')
        expect('   Hello'.trim()).toEqual('Hello')
        expect('Hello   '.trim()).toEqual('Hello')
        expect('   Hello   '.trim()).toEqual('Hello')
      })
    })

    describe('trimLeft', || {
      it('should remove leading whitespace', || {
        expect(''.trimLeft()).toEqual('')
        expect('   Hello'.trimLeft()).toEqual('Hello')
        expect('Hello   '.trimLeft()).toEqual('Hello   ')
        expect('   Hello   '.trimLeft()).toEqual('Hello   ')
      })
    })

    describe('trimRight', || {
      it('should remove trailing whitespace', || {
        expect(''.trimRight()).toEqual('')
        expect('   Hello'.trimRight()).toEqual('   Hello')
        expect('Hello   '.trimRight()).toEqual('Hello')
        expect('   Hello   '.trimRight()).toEqual('   Hello')
      })
    })

    describe('IntoIterator', || {
      it('should return an iterator that iterates over the characters', || {
        let mut iterator = 'ABCåäö'.iter()
        expect(iterator.next()).toEqual(Some('A'))
        expect(iterator.next()).toEqual(Some('B'))
        expect(iterator.next()).toEqual(Some('C'))
        expect(iterator.next()).toEqual(Some('å'))
        expect(iterator.next()).toEqual(Some('ä'))
        expect(iterator.next()).toEqual(Some('ö'))
        expect(iterator.next()).toEqual(None)
      })
    })
  })

  describe('Option', || {
    describe('isSome', || {
      it('should return true if Some(value)', || {
        expect(Some(1).isSome()).toBe(true)
      })

      it('should return false if None', || {
        expect(None.isSome()).toBe(false)
      })
    })

    describe('isNone', || {
      it('should return false if Some(value)', || {
        expect(Some(1).isNone()).toBe(false)
      })

      it('should return true if None', || {
        expect(None.isNone()).toBe(true)
      })
    })

    describe('andThen', || {
      it('should map the value if Some(value) and returns Some(newValue)', || {
        expect(Some(1).andThen(|value| Some(value + value))).toEqual(Some(2))
      })

      it('should not call the map function if None', || {
        expect(None.andThen(|value| expect('andThen').toBe('not called'))).toEqual(None)
      })

      it('should return None if Some(value) and returns None', || {
        expect(Some(1).andThen(|value| None)).toEqual(None)
      })
    })

    describe('map', || {
      it('should map the value if Some(value)', || {
        expect(Some(1).map(|value| value + value)).toEqual(Some(2))
        expect(Some(2).map(|value| value + value).unwrap()).toBe(4)
      })

      it('should not call the map function if None', || {
        expect(None.map(|value| expect('map').toBe('not called'))).toEqual(None)
      })
    })

    describe('mapOr', || {
      it('should map the value if Some(value)', || {
        expect(Some(1).mapOr(5, |value| value + value)).toBe(2)
      })

      it('should return the default value if None', || {
        expect(None.mapOr(5, |value| expect('map').toBe('not called'))).toBe(5)
      })
    })

    describe('mapOrElse', || {
      it('should map the value if Some(value)', || {
        expect(
          Some(1)
          .mapOrElse(|| {
            expect('orElse').toBe('not called')
            0
          }
          |value| value + value)
        ).toBe(2)
      })

      it('should return the result of the default function if None', || {
        expect(None.mapOrElse(|| 5, |value| expect('map').toBe('not called'))).toBe(5)
      })
    })

    describe('unwrap', || {
      it('should return the value if Some(value)', || {
        expect(Some('value').unwrap()).toBe('value')
      })

      it('should panic if None', || {
        expect(|| None.unwrap()).toThrow()
      })
    })

    describe('unwrapOr', || {
      it('should return the value if Some(value)', || {
        expect(Some('value').unwrapOr('default')).toBe('value')
      })

      it('should return the default value if None', || {
        expect(None.unwrapOr('default')).toBe('default')
      })
    })

    describe('unwrapOrElse', || {
      it('should return the value if Some(value)', || {
        expect(Some('value').unwrapOrElse(|| expect('orElse').toBe('not called'))).toBe('value')
      })

      it('should return the result of the default function if None', || {
        expect(None.unwrapOrElse(|| 'default')).toBe('default')
      })
    })
  })

  describe('Result', || {
    describe('isOk', || {
      it('should return true if Ok(value)', || {
        expect(Ok(1).isOk()).toBe(true)
      })

      it('should return false if Err(err)', || {
        expect(Err(2).isOk()).toBe(false)
      })
    })

    describe('isErr', || {
      it('should return false if Ok(value)', || {
        expect(Ok(1).isErr()).toBe(false)
      })

      it('should return true if Err(err)', || {
        expect(Err(2).isErr()).toBe(true)
      })
    })

    describe('andThen', || {
      it('should map the value if Ok(value) and returns Ok(newValue)', || {
        expect(Ok(1).andThen(|value| Ok(value + value))).toEqual(Ok(2))
      })

      it('should not call the map function if Err(err)', || {
        expect(
          Err(2).andThen(|_| {
            expect('andThen').toBe('not called')
            any(Err(0))
          })
        ).toEqual(any(Err(2)))
      })

      it('should return the error if Ok(value) and returns Err(error)', || {
        expect(Ok(1).andThen(|_| Err('error'))).toEqual(any(Err('error')))
      })
    })

    describe('map', || {
      it('should map the value if Ok(value)', || {
        expect(Ok(1).map(|value| value + value)).toEqual(Ok(2))
        expect(Ok(2).map(|value| value + value).unwrap()).toBe(4)
      })

      it('should not call the map function if Err(err)', || {
        expect(Err(2).map(|_| expect('map').toBe('not called'))).toEqual(any(Err(2)))
      })
    })

    describe('mapErr', || {
      it('should map the value if Ok(value)', || {
        expect(Err(1).mapErr(|value| value + value)).toEqual(any(Err(2)))
        expect(Err(2).mapErr(|value| value + value).unwrapErr()).toBe(4)
      })

      it('should not call the mapErr function if Err(err)', || {
        expect(Ok(2).mapErr(|value| expect('mapErr').toBe('not called'))).toEqual(Ok(2))
      })
    })

    describe('unwrap', || {
      it('should return the value if Ok(value)', || {
        expect(Ok('value').unwrap()).toBe('value')
      })

      it('should panic if Err(err)', || {
        expect(|| Err('err').unwrap()).toThrow()
      })
    })

    describe('unwrapErr', || {
      it('should panic if Ok(value)', || {
        expect(|| Ok('value').unwrapErr()).toThrow()
      })

      it('should return the error if Err(err)', || {
        expect(Err('err').unwrapErr()).toBe('err')
      })
    })
  })

  describe('Iterator', || {
    describe('count', || {
      it('should count the elements in the iterator', || {
        expect([].iter().count()).toBe(0)
        expect([1, 2, 3].iter().count()).toBe(3)
        expect(['a', 'b'].iter().count()).toBe(2)
      })
    })

    describe('EnumerateIterator', || {
      it('should map index and values on the iterator', || {
        let mut iterator = [1, 2, 3].iter().enumerate()
        expect(iterator.next()).toEqual(Some((0, 1)))
        expect(iterator.next()).toEqual(Some((1, 2)))
        expect(iterator.next()).toEqual(Some((2, 3)))
        expect(iterator.next()).toEqual(None)
      })
    })

    describe('MapIterator', || {
      it('should map values on the iterator', || {
        let mut iterator = [1, 2, 3].iter().map(|i| i * 2)
        expect(iterator.next()).toEqual(Some(2))
        expect(iterator.next()).toEqual(Some(4))
        expect(iterator.next()).toEqual(Some(6))
        expect(iterator.next()).toEqual(None)
      })

      it('should map lazily', || {
        let mut iterator = [1, 2, 3].iter().map(|i| {
          if i > 1
            then throw 'Should only be called once'
          i
        })

        expect(iterator.next()).toEqual(Some(1))
      })
    })

    describe('filter', || {
      it('should remove elements from the iterator that does not match the predicate', || {
        let predicate = |i| i < 3
        let mut iterator = [1, 2, 3].iter().filter(predicate)
        expect(iterator.next()).toEqual(Some(1))
        expect(iterator.next()).toEqual(Some(2))
        expect(iterator.next()).toEqual(None)

        let predicate = |i| i != 2
        let mut iterator = [1, 2, 3].iter().filter(predicate)
        expect(iterator.next()).toEqual(Some(1))
        expect(iterator.next()).toEqual(Some(3))
        expect(iterator.next()).toEqual(None)
      })

      it('should correctly count a filtered iterator', || {
        let predicate = |i| i % 2 == 1
        let mut iterator = [1, 2, 3, 4].iter().filter(predicate)
        expect(iterator.count()).toBe(2)
      })
    })

    describe('filterMap', || {
      it('should remove elements from the iterator that does not match the predicate', || {
        let predicate = |i| if i < 3 then Some(i * 2) else None
        let mut iterator = [1, 2, 3].iter().filterMap(predicate)
        expect(iterator.next()).toEqual(Some(2))
        expect(iterator.next()).toEqual(Some(4))
        expect(iterator.next()).toEqual(None)

        let predicate = |i| if i != 2 then Some(i * 2) else None
        let mut iterator = [1, 2, 3].iter().filterMap(predicate)
        expect(iterator.next()).toEqual(Some(2))
        expect(iterator.next()).toEqual(Some(6))
        expect(iterator.next()).toEqual(None)
      })

      it('should correctly count a filtered iterator', || {
        let predicate = |i| if i % 2 == 1 then Some(i * 2) else None
        let mut iterator = [1, 2, 3, 4].iter().filterMap(predicate)
        expect(iterator.count()).toBe(2)
      })
    })

    describe('all', || {
      it('should return true for empty iterators', || {
        expect([].iter().all(|_| false)).toBe(true)
      })

      it('should return true if all elements matches the predicate', || {
        let mut iterator = [1, 2, 3].iter()
        let predicate = |i| i > 0
        expect(iterator.all(predicate)).toBe(true)
      })

      it('should return false if any of the elements does not match the predicate', || {
        let predicate = |i| i > 4
        expect([1, 2, 3].iter().all(predicate)).toBe(false)
        expect([4, 5, 6].iter().all(predicate)).toBe(false)
        expect([6, 5, 4].iter().all(predicate)).toBe(false)
      })
    })

    describe('any', || {
      it('should return false for empty iterators', || {
        expect([].iter().any(|_| true)).toBe(false)
      })

      it('should return true if any of the elements match the predicate', || {
        let predicate = |i| i > 4
        expect([1, 2, 5].iter().any(predicate)).toBe(true)
        expect([4, 5, 6].iter().any(predicate)).toBe(true)
        expect([6, 1, 2].iter().any(predicate)).toBe(true)
      })

      it('should return false if none of the elements match the predicate', || {
        let mut iterator = [1, 2, 3].iter()
        let predicate = |i| i > 4
        expect(iterator.any(predicate)).toBe(false)
      })
    })

    describe('find', || {
      it('should return None for empty iterators', || {
        expect([].iter().find(|_| true)).toEqual(None)
      })

      it('should return the first matching element', || {
        let predicate = |i| i > 4
        expect([1, 2, 5].iter().find(predicate)).toEqual(Some(5))
        expect([4, 5, 6].iter().find(predicate)).toEqual(Some(5))
        expect([6, 1, 2].iter().find(predicate)).toEqual(Some(6))
      })

      it('should return None if none of the elements match the predicate', || {
        let mut iterator = [1, 2, 3].iter()
        let predicate = |i| i > 4
        expect(iterator.find(predicate)).toEqual(None)
      })
    })
  })

  describe('List', || {
    describe('IntoIterator', || {
      it('should return an iterator that iterates over the elements', || {
        let mut iterator = [1, 2, 3].iter()
        expect(iterator.next()).toEqual(Some(1))
        expect(iterator.next()).toEqual(Some(2))
        expect(iterator.next()).toEqual(Some(3))
        expect(iterator.next()).toEqual(None)
      })
    })
  })

  describe('Range', || {
    describe('IntoIterator', || {
      it('should return an iterator that iterates over the elements', || {
        let range: Range = {start: -3, end: 3}
        let mut iterator = range.iter()
        expect(iterator.next()).toEqual(Some(-3))
        expect(iterator.next()).toEqual(Some(-2))
        expect(iterator.next()).toEqual(Some(-1))
        expect(iterator.next()).toEqual(Some(0))
        expect(iterator.next()).toEqual(Some(1))
        expect(iterator.next()).toEqual(Some(2))
        expect(iterator.next()).toEqual(None)
      })
    })
  })
})
