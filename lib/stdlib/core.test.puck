import 'puck:test' as *
import 'core.puck' as {Num, NumBase, Option, Result, String}

fn any(a) {a}

describe('core', || {
  describe('Num', || {
    describe('parseInt', || {
      it('should default to parse decimal numbers', || {
        expect(Num.parseInt('1')).toEqual(Ok(1))
        expect(Num.parseInt('0')).toEqual(Ok(0))
        expect(Num.parseInt('10')).toEqual(Ok(10))
        expect(Num.parseInt('-123456789')).toEqual(Ok(-123456789))
      })

      it('should be able to parse binary numbers', || {
        expect(Num.parseInt('1', NumBase::Binary)).toEqual(Ok(1))
        expect(Num.parseInt('0', NumBase::Binary)).toEqual(Ok(0))
        expect(Num.parseInt('10', NumBase::Binary)).toEqual(Ok(2))
        expect(Num.parseInt('-101', NumBase::Binary)).toEqual(Ok(-5))
      })

      it('should be able to parse octal numbers', || {
        expect(Num.parseInt('1', NumBase::Octal)).toEqual(Ok(1))
        expect(Num.parseInt('0', NumBase::Octal)).toEqual(Ok(0))
        expect(Num.parseInt('10', NumBase::Octal)).toEqual(Ok(8))
        expect(Num.parseInt('-107', NumBase::Octal)).toEqual(Ok(-71))
      })

      it('should be able to parse hex numbers', || {
        expect(Num.parseInt('1', NumBase::Hex)).toEqual(Ok(1))
        expect(Num.parseInt('0', NumBase::Hex)).toEqual(Ok(0))
        expect(Num.parseInt('f', NumBase::Hex)).toEqual(Ok(15))
        expect(Num.parseInt('F', NumBase::Hex)).toEqual(Ok(15))
        expect(Num.parseInt('10', NumBase::Hex)).toEqual(Ok(16))
        expect(Num.parseInt('-10e9f', NumBase::Hex)).toEqual(Ok(-69279))
        expect(Num.parseInt('-10E9F', NumBase::Hex)).toEqual(Ok(-69279))
      })

      it('should error for invalid characters', || {
        expect(Num.parseInt('A')).toEqual(Err(()))
        expect(Num.parseInt('2', NumBase::Binary)).toEqual(Err(()))
        expect(Num.parseInt('8', NumBase::Octal)).toEqual(Err(()))
        expect(Num.parseInt('G', NumBase::Hex)).toEqual(Err(()))
        expect(Num.parseInt('2341A')).toEqual(Err(()))
        expect(Num.parseInt('1010112', NumBase::Binary)).toEqual(Err(()))
        expect(Num.parseInt('1232648', NumBase::Octal)).toEqual(Err(()))
        expect(Num.parseInt('1289AC6G', NumBase::Hex)).toEqual(Err(()))
      })
    })

    describe('parse', || {
      it('should be able to parse integers', || {
        expect(Num.parse('1')).toEqual(Ok(1))
        expect(Num.parse('0')).toEqual(Ok(0))
        expect(Num.parse('10')).toEqual(Ok(10))
        expect(Num.parse('-123456789')).toEqual(Ok(-123456789))
      })

      it('should be able to parse doubles', || {
        expect(Num.parse('1.03')).toEqual(Ok(1.03))
        expect(Num.parse('0.5')).toEqual(Ok(0.5))
        expect(Num.parse('10.12')).toEqual(Ok(10.12))
        expect(Num.parse('-123456789.123')).toEqual(Ok(-123456789.123))
      })
    })

    describe('isNan', || {
      it('should return false for normal numbers', || {
        expect(1.isNan()).toBe(false)
        expect(1.04.isNan()).toBe(false)
        expect(100.isNan()).toBe(false)
        expect((-50).isNan()).toBe(false)
      })

      it('should return true for nan', || {
        let nan: Num = 0/0
        expect(nan.isNan()).toBe(true)
      })
    })

    describe('isInfinite', || {
      it('should return false for normal numbers', || {
        expect(1.isInfinite()).toBe(false)
        expect(1.04.isInfinite()).toBe(false)
        expect(100.isInfinite()).toBe(false)
        expect((-50).isInfinite()).toBe(false)
      })

      it('should return true for infinity', || {
        let positiveInfinity: Num = 1/0
        let negativeInfinity: Num = -1/0
        expect(positiveInfinity.isInfinite()).toBe(true)
        expect(negativeInfinity.isInfinite()).toBe(true)
      })
    })

    describe('ceil', || {
      it('should should always away from zero', || {
        expect(1.ceil()).toBe(1)
        expect(1.5.ceil()).toBe(2)
        expect(-0.4.ceil()).toBe(-1)
        expect(10.4.ceil()).toBe(11)
        expect(-10.4.ceil()).toBe(-11)
      })
    })

    describe('floor', || {
      it('should should always round towards zero', || {
        expect(1.floor()).toBe(1)
        expect(1.5.floor()).toBe(1)
        expect(-0.4.floor()).toBe(-0)
        expect(10.4.floor()).toBe(10)
        expect(-10.4.floor()).toBe(-10)
      })
    })

    describe('round', || {
      it('should should round using normal rules', || {
        expect(1.round()).toBe(1)
        expect(1.5.round()).toBe(2)
        expect(-0.4.round()).toBe(-0)
        expect(-0.5.round()).toBe(-1)
        expect(10.4.round()).toBe(10)
        expect(10.5.round()).toBe(11)
        expect(-10.4.round()).toBe(-10)
        expect(-10.5.round()).toBe(-11)
      })
    })
  })

  describe('String', || {
    describe('contains', || {
      it('should return true if the string contains the substring', || {
        expect('abcdefg'.contains('abc')).toBe(true)
        expect('abcdefg'.contains('efg')).toBe(true)
        expect('abcdefg'.contains('cde')).toBe(true)
        expect('abcdefg'.contains('c')).toBe(true)
        expect('abcdefg'.contains('abcdefg')).toBe(true)
      })

      it('should return false if the string does not contain the substring', || {
        expect('abcdefg'.contains('cba')).toBe(false)
        expect('abcdefg'.contains('efgh')).toBe(false)
        expect('abcdefg'.contains('ced')).toBe(false)
        expect('abcdefg'.contains('h')).toBe(false)
        expect('abcdefg'.contains('abcdefgh')).toBe(false)
      })
    })

    describe('split', || {
      it('should default to split at each character', || {
        expect('abcdefg'.split()).toEqual(['a', 'b', 'c', 'd', 'e', 'f', 'g'])
      })

      it('should split at the provided pattern', || {
        expect('hello world'.split(' ')).toEqual(['hello', 'world'])
        expect('hello, world'.split(' ')).toEqual(['hello,', 'world'])
        expect('hello, world'.split(', ')).toEqual(['hello', 'world'])
      })
    })

    describe('padLeft', || {
      it('should not pad the string if the width is >= width', || {
        expect('Hello'.padLeft(5)).toEqual('Hello')
        expect('Hello'.padLeft(2)).toEqual('Hello')
        expect('Hello'.padLeft(-2)).toEqual('Hello')
      })

      it('should pad the string with spaces if the width is < width', || {
        expect('Hello'.padLeft(10)).toEqual('     Hello')
      })

      it('should pad the string with spaces if the passed padding is an empty string and width is < width', || {
        expect('Hello'.padLeft(10, '')).toEqual('     Hello')
      })

      it('should pad the string with passed padding if the width is < width', || {
        expect('Hello'.padLeft(10, '*')).toEqual('*****Hello')
        expect('Hello'.padLeft(10, '**')).toEqual('******Hello')
      })
    })

    describe('padRight', || {
      it('should not pad the string if the width is >= width', || {
        expect('Hello'.padRight(5)).toEqual('Hello')
        expect('Hello'.padRight(2)).toEqual('Hello')
        expect('Hello'.padRight(-2)).toEqual('Hello')
      })

      it('should pad the string with spaces if the width is < width', || {
        expect('Hello'.padRight(10)).toEqual('Hello     ')
      })

      it('should pad the string with spaces if the passed padding is an empty string and width is < width', || {
        expect('Hello'.padRight(10, '')).toEqual('Hello     ')
      })

      it('should pad the string with passed padding if the width is < width', || {
        expect('Hello'.padRight(10, '*')).toEqual('Hello*****')
        expect('Hello'.padRight(10, '**')).toEqual('Hello******')
      })
    })

    describe('toLowerCase', || {
      it('should convert characters to lower case', || {
        expect('abcABCåäöÅÄÖ'.toLowerCase()).toEqual('abcabcåäöåäö')
      })
    })

    describe('toUpperCase', || {
      it('should convert characters to upper case', || {
        expect('abcABCåäöÅÄÖ'.toUpperCase()).toEqual('ABCABCÅÄÖÅÄÖ')
      })
    })

    describe('trim', || {
      it('should remove whitespace', || {
        expect(''.trim()).toEqual('')
        expect('   Hello'.trim()).toEqual('Hello')
        expect('Hello   '.trim()).toEqual('Hello')
        expect('   Hello   '.trim()).toEqual('Hello')
      })
    })

    describe('trimLeft', || {
      it('should remove leading whitespace', || {
        expect(''.trimLeft()).toEqual('')
        expect('   Hello'.trimLeft()).toEqual('Hello')
        expect('Hello   '.trimLeft()).toEqual('Hello   ')
        expect('   Hello   '.trimLeft()).toEqual('Hello   ')
      })
    })

    describe('trimRight', || {
      it('should remove trailing whitespace', || {
        expect(''.trimRight()).toEqual('')
        expect('   Hello'.trimRight()).toEqual('   Hello')
        expect('Hello   '.trimRight()).toEqual('Hello')
        expect('   Hello   '.trimRight()).toEqual('   Hello')
      })
    })
  })

  describe('Option', || {
    describe('isSome', || {
      it('should return true if Some(value)', || {
        expect(Some(1).isSome()).toBe(true)
      })

      it('should return false if None', || {
        expect(None.isSome()).toBe(false)
      })
    })

    describe('isNone', || {
      it('should return false if Some(value)', || {
        expect(Some(1).isNone()).toBe(false)
      })

      it('should return true if None', || {
        expect(None.isNone()).toBe(true)
      })
    })

    describe('andThen', || {
      it('should map the value if Some(value) and returns Some(newValue)', || {
        expect(Some(1).andThen(|value| Some(value + value))).toEqual(Some(2))
      })

      it('should not call the map function if None', || {
        expect(None.andThen(|value| expect('andThen').toBe('not called'))).toEqual(None)
      })

      it('should return None if Some(value) and returns None', || {
        expect(Some(1).andThen(|value| None)).toEqual(None)
      })
    })

    describe('map', || {
      it('should map the value if Some(value)', || {
        expect(Some(1).map(|value| value + value)).toEqual(Some(2))
        expect(Some(2).map(|value| value + value).unwrap()).toBe(4)
      })

      it('should not call the map function if None', || {
        expect(None.map(|value| expect('map').toBe('not called'))).toEqual(None)
      })
    })

    describe('mapOr', || {
      it('should map the value if Some(value)', || {
        expect(Some(1).mapOr(5, |value| value + value)).toBe(2)
      })

      it('should return the default value if None', || {
        expect(None.mapOr(5, |value| expect('map').toBe('not called'))).toBe(5)
      })
    })

    describe('mapOrElse', || {
      it('should map the value if Some(value)', || {
        expect(
          Some(1)
          .mapOrElse(|| {
            expect('orElse').toBe('not called')
            0
          }
          |value| value + value)
        ).toBe(2)
      })

      it('should return the result of the default function if None', || {
        expect(None.mapOrElse(|| 5, |value| expect('map').toBe('not called'))).toBe(5)
      })
    })

    describe('unwrap', || {
      it('should return the value if Some(value)', || {
        expect(Some('value').unwrap()).toBe('value')
      })

      it('should panic if None', || {
        expect(|| None.unwrap()).toThrow()
      })
    })

    describe('unwrapOr', || {
      it('should return the value if Some(value)', || {
        expect(Some('value').unwrapOr('default')).toBe('value')
      })

      it('should return the default value if None', || {
        expect(None.unwrapOr('default')).toBe('default')
      })
    })

    describe('unwrapOrElse', || {
      it('should return the value if Some(value)', || {
        expect(Some('value').unwrapOrElse(|| expect('orElse').toBe('not called'))).toBe('value')
      })

      it('should return the result of the default function if None', || {
        expect(None.unwrapOrElse(|| 'default')).toBe('default')
      })
    })
  })

  describe('Result', || {
    describe('isOk', || {
      it('should return true if Ok(value)', || {
        expect(Ok(1).isOk()).toBe(true)
      })

      it('should return false if Err(err)', || {
        expect(Err(2).isOk()).toBe(false)
      })
    })

    describe('isErr', || {
      it('should return false if Ok(value)', || {
        expect(Ok(1).isErr()).toBe(false)
      })

      it('should return true if Err(err)', || {
        expect(Err(2).isErr()).toBe(true)
      })
    })

    describe('andThen', || {
      it('should map the value if Ok(value) and returns Ok(newValue)', || {
        expect(Ok(1).andThen(|value| Ok(value + value))).toEqual(Ok(2))
      })

      it('should not call the map function if Err(err)', || {
        expect(
          Err(2).andThen(|_| {
            expect('andThen').toBe('not called')
            any(Err(0))
          })
        ).toEqual(any(Err(2)))
      })

      it('should return the error if Ok(value) and returns Err(error)', || {
        expect(Ok(1).andThen(|_| Err('error'))).toEqual(any(Err('error')))
      })
    })

    describe('map', || {
      it('should map the value if Ok(value)', || {
        expect(Ok(1).map(|value| value + value)).toEqual(Ok(2))
        expect(Ok(2).map(|value| value + value).unwrap()).toBe(4)
      })

      it('should not call the map function if Err(err)', || {
        expect(Err(2).map(|_| expect('map').toBe('not called'))).toEqual(any(Err(2)))
      })
    })

    describe('mapErr', || {
      it('should map the value if Ok(value)', || {
        expect(Err(1).mapErr(|value| value + value)).toEqual(any(Err(2)))
        expect(Err(2).mapErr(|value| value + value).unwrapErr()).toBe(4)
      })

      it('should not call the mapErr function if Err(err)', || {
        expect(Ok(2).mapErr(|value| expect('mapErr').toBe('not called'))).toEqual(Ok(2))
      })
    })

    describe('unwrap', || {
      it('should return the value if Ok(value)', || {
        expect(Ok('value').unwrap()).toBe('value')
      })

      it('should panic if Err(err)', || {
        expect(|| Err('err').unwrap()).toThrow()
      })
    })

    describe('unwrapErr', || {
      it('should panic if Ok(value)', || {
        expect(|| Ok('value').unwrapErr()).toThrow()
      })

      it('should return the error if Err(err)', || {
        expect(Err('err').unwrapErr()).toBe('err')
      })
    })
  })
})
