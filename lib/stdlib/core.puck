//#![no_core]
import 'puck:js' as {Object, console, null, undefined}

export type Bool = {}
export type Num = {}
export type String = {}
export trait StringTrait {
  fn contains(self, subStr: String) {
    self.indexOf(subStr) >= 0
  }
}
impl StringTrait for String {}

export type List<E> = {}
export trait Iterable<E> {
  /// Returns an [Iterable] that provides all but the first [count] elements.
  // fn skip(self, count: Num): Iterable<E>
  fn skip(self, count: Num): List<E>

  /// Returns an [Iterable] that skips leading elements until [test] is satisfied.
  // fn skipUntil(self, test: (E) => Bool): Iterable<E>
  fn skipUntil(self, test: (E) => Bool): List<E>
}

impl<E> Iterable<E> for List<E> {
  fn skip(self, count) {
    self.slice(count)
  }

  fn skipUntil(self, test) {
    let index = self.findIndex(test)
    if index == -1
      then []
      else self.slice(index)
  }
}

/// A (half-open) range which is bounded at both ends: { x | start <= x < end }.
/// Use start..end (two dots) for its shorthand.
export type Range<Idx=Num> = {
  /// The lower bound of the range (inclusive).
  start: Idx
  /// The upper bound of the range (exclusive).
  end: Idx
}
export trait RangeTrait<Idx> {
  fn contains(self, item: Idx): Bool
  fn isSubsetOf(self, other: Range<Idx>): Bool
}
impl RangeTrait<Num> for Range<Num> {
  fn contains(self, item) {
    self.start <= item and item < self.end
  }
  fn isSubsetOf(self, other) {
    self.start >= other.start and other.end >= self.end
  }
}

export fn print(message, a, b, c) {
  let mut args = [message]
  if a != undefined {
    args.push(a)
  }
  if b != undefined {
    args[2] = b
  }
  if c != undefined {
    args[3] = c
  }

  console.log.apply(console, args)
}

export fn objectFromList<T>(list: List<List<T>>) {
  let mut object = Object.create(null)
  list.forEach(|item| object[item[0]] = item[1])
  object
}
