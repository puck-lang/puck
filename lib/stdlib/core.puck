//#![no_core]
import 'puck:js' as {Error, Object, console, null, undefined}

export type Bool {}
export type Num {}
export type String {}
impl String {
  fn contains(self, subStr: String) -> Bool {
    self.indexOf(subStr) >= 0
  }
}

export enum Result<T, E> {
  Ok(T)
  Err(E)
}
export let Ok = Result::Ok
export let Err = Result::Err
impl<T, E> Result<T, E> {
  fn isOk(self) -> Bool {self.kind == 'Ok'}
  fn isErr(self: Result<T, E>) -> Bool {not self.isOk()}

  /// Calls op if the result is Ok, otherwise returns the Err value of self.
  ///
  /// This function can be used for control flow based on Result values.
  fn andThen<U>(self: Result<T, E>, op: (T) -> Result<U, E>) -> Result<U, E> {
    if let Result::Ok(value) = self
      then op(value)
      else self
  }

  /// Maps a Result<T, E> to Result<U, E> by applying a function to a contained Ok value, leaving an Err value untouched.
  ///
  /// This function can be used to compose the results of two functions.
  fn map<U>(self: Result<T, E>, op: (T) -> U) -> Result<U, E> {
    if let Result::Ok(value) = self
      then Ok(op(value))
      else self
  }

  /// Maps a Result<T, E> to Result<T, F> by applying a function to a contained Err value, leaving an Ok value untouched.
  fn mapErr<F>(self: Result<T, E>, op: (E) -> F) -> Result<T, F> {
    if let Result::Err(value) = self
      then Err(op(value))
      else self
  }

  fn unwrap(self) -> T {
    if self.isErr()
      then throw Error(self.value[0])

    self.value[0]
  }

  fn unwrapErr(self) -> E {
    if self.isOk()
      then throw Error(self.value[0])

    self.value[0]
  }
}

export enum Option<T> {
  Some(T)
  None
}
export let Some = Option::Some
export let None = Option::None
impl<T> Option<T> {
  fn isSome(self) -> Bool {self.kind == 'Some'}
  fn isNone(self) -> Bool {not self.isSome()}

  fn andThen<U>(self, op: (T) -> Option<U>) -> Option<U> {
    if let Option::Some(value) = self
      then op(value)
      else self
  }

  fn map<U>(self, f: (T) -> U) -> Option<U> {
    if let Option::Some(value) = self
      then Some(f(value))
      else self
  }

  fn mapOr<U>(self, default: U, f: (T) -> U) -> U {
    if let Option::Some(value) = self
      then f(value)
      else default
  }

  fn mapOrElse<U>(self, default: () -> U, f: (T) -> U) -> U {
    if let Option::Some(value) = self
      then f(value)
      else default()
  }

  fn unwrap(self) -> T {
    if self.isNone()
      then throw Error('Can not unwrap empty Option')

    self.value[0]
  }

  fn unwrapOr(self, default: T) -> T {
    if let Option::Some(value) = self
      then value
      else default
  }

  fn unwrapOrElse(self, default: () -> T) -> T {
    if let Option::Some(value) = self
      then value
      else default()
  }
}

fn anyCast(a) {a}

export type List<E> {}
impl<E> List<E> {
  fn zip<A, B>(a: List<A>, b: List<B>) -> List<(A, B)> {
    if a.length != b.length
      then throw Error('List a and b are not of the same length')

    a.enumerate().map(|(a, i)| (a, b[i]))
  }

  fn add(mut self, element: E) -> () {
    self.push(element)
  }
}
export trait Iterable<E> {
  fn enumerate(self) -> List<(E, Num)>

  fn size(self) -> Num
  fn isEmpty(self) -> Bool
  fn isNotEmpty(self) -> Bool
  fn first(self) -> Option<E>
  fn last(self) -> Option<E>

  fn all(self, predicate: (E) -> Bool) -> Bool
  fn any(self, predicate: (E) -> Bool) -> Bool
  fn find(self, predicate: (E) -> Bool) -> Option<E>

  fn forEach(self, func: (E) -> ()) -> ()
  fn map<U>(self, func: (E) -> U) -> List<U>

  /// Returns an [Iterable] that provides all but the first [count] elements.
  // fn skip(self, count: Num) -> Iterable<E>
  fn skip(self, count: Num) -> List<E>

  /// Returns an [Iterable] that skips leading elements until [test] is satisfied.
  // fn skipUntil(self, test: (E) -> Bool) -> Iterable<E>
  fn skipUntil(self, test: (E) -> Bool) -> List<E>
}

impl<E> Iterable<E> for List<E> {

  fn enumerate(self) -> List<(E, Num)> {
    anyCast(self).map(|element, index| (element, index))
  }

  fn size(self) -> Num {
    self.length
  }

  fn isEmpty(self) -> Bool {
    self.length == 0
  }

  fn isNotEmpty(self) -> Bool {
    self.length > 0
  }

  fn first(self) -> Option<E> {
    if self.length > 0
      then Some(self[0])
      else None
  }

  fn last(self) -> Option<E> {
    if self.length > 0
      then Some(self[self.length - 1])
      else None
  }

  fn all(self, predicate: (E) -> Bool) -> Bool {
    let mut i = 0
    while i < self.length {
      if not predicate(self[i]) then return false
      i += 1
    }
    true
  }

  fn any(self, predicate: (E) -> Bool) -> Bool {
    let mut i = 0
    while i < self.length {
      if predicate(self[i]) then return true
      i += 1
    }
    false
  }

  fn find(self, predicate: (E) -> Bool) -> Option<E> {
    let index = self.findIndex(predicate)

    if index >= 0
      then Some(self[index])
      else None
  }

  fn forEach(self, func: (E) -> ()) -> () {
    anyCast(self).forEach(func)
  }

  fn map<U>(self, func: (E) -> U) -> List<U> {
    anyCast(self).map(func)
  }

  fn skip(self, count: Num) -> List<E> {
    self.slice(count)
  }

  fn skipUntil(self, predicate: (E) -> Bool) -> List<E> {
    let index = self.findIndex(predicate)
    if index == -1
      then []
      else self.slice(index)
  }
}

/// A (half-open) range which is bounded at both ends: { x | start <= x < end }.
/// Use start..end (two dots) for its shorthand.
export type Range<Idx=Num> {
  /// The lower bound of the range (inclusive).
  start: Idx
  /// The upper bound of the range (exclusive).
  end: Idx
}
impl<Idx> Range<Idx> {
  fn contains(self, item: Idx) -> Bool {
    self.start <= item and item < self.end
  }
  fn isSubsetOf(self, other: Range<Idx>) -> Bool {
    self.start >= other.start and other.end >= self.end
  }
}

export fn print(message, extra = []) {
  console.log.apply(console, [message].concat(extra))
}

export type ObjectMap<T> {}
impl<T> ObjectMap<T> {
  fn new<T>() -> ObjectMap<T> {
    Object.create(null)
  }

  fn fromList<T>(list: List<(String, T)>) -> ObjectMap<T> {
    let mut object = Object.create(null)
    list.forEach(|item| object[item[0]] = item[1])
    object
  }

  fn keys(self) -> List<String> {
    Object.keys(self)
  }

  fn values(self) -> List<T> {
    Object.keys(self).map(|key| self[key])
  }

  fn toList(self) -> List<(String, T)> {
    Object.keys(self).map(|key| (key, self[key]))
  }

  fn all(self, predicate: (T) -> Bool) -> Bool {
    let mut i = 0
    let keys = Object.keys(self)
    while i < keys.length {
      if not predicate(self[keys[i]]) then return false
      i += 1
    }
    true
  }

  fn any(self, predicate: (T) -> Bool) -> Bool {
    let mut i = 0
    let keys = Object.keys(self)
    while i < keys.length {
      if predicate(self[keys[i]]) then return true
      i += 1
    }
    false
  }

  fn map<U>(self, mapper: (T) -> U) -> ObjectMap<U> {
    let mut new = ObjectMap.new()
    Object.keys(self).forEach(|key| {
      new[key] = mapper(self[key])
    })
    new
  }

  fn find(self, predicate: ((String, T)) -> Bool) -> Option<(String, T)> {
    let key = Object.keys(self).find(|key| predicate((key, self[key])))

    if key
      then Some((key, self[key]))
      else None
  }

  fn forEach(self, func: ((String, T)) -> ()) -> () {
    Object.keys(self).forEach(|key| {
      func((key, self[key]))
    });
    (())
  }

  fn has(self, key: String) -> Bool {
    Object.prototype.hasOwnProperty.call(self, key)
  }

  fn get(self, key: String) -> Option<T> {
    if self.has(key)
      then Some(self[key])
      else None
  }

  fn size(self) -> Num {
    Object.keys(self).length
  }
}
