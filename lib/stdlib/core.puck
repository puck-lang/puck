//#![no_core]
import 'puck:js' as {Array, Error, Object, console, null, typeof, undefined}
import 'core/js.js' as js
import 'core/unknown.puck' as {Unknown}

export Unknown

export fn identical<T>(a: T, b: T) -> Bool {
  js->identical(a, b).transmute()
}

fn anyCast(a) {a}

/// The add operator +.
#[type_id = 'Add']
export trait Add<RHS, Output> {
    /// The resulting type after applying the + operator
    // type Output;

    fn add(self, rhs: RHS) -> Output;
}

/// The subtraction operator -.
#[type_id = 'Sub']
export trait Sub<RHS, Output> {
    /// The resulting type after applying the - operator
    // type Output;

    fn sub(self, rhs: RHS) -> Output;
}

/// The multiplication operator *.
#[type_id = 'Mul']
export trait Mul<RHS, Output> {
    /// The resulting type after applying the * operator
    // type Output;

    fn mul(self, rhs: RHS) -> Output;
}

/// The divition operator /.
#[type_id = 'Div']
export trait Div<RHS, Output> {
    /// The resulting type after applying the / operator
    // type Output;

    fn div(self, rhs: RHS) -> Output;
}

/// The remainder operator %.
#[type_id = 'Rem']
export trait Rem<RHS, Output> {
    /// The resulting type after applying the % operator
    // type Output;

    fn rem(self, rhs: RHS) -> Output;
}

/// The power operator **.
#[type_id = 'Pow']
export trait Pow<RHS, Output> {
    /// The resulting type after applying the ** operator
    // type Output;

    fn pow(self, rhs: RHS) -> Output;
}

/// The concat operator ++.
#[type_id = 'Concat']
export trait Concat<RHS, Output> {
    /// The resulting type after applying the ++ operator
    // type Output;

    fn concat(self, rhs: RHS) -> Output;
}

export type RegExp {}

impl RegExp {
  fn new(pattern, flags = '') -> RegExp {
    js->RegExp(pattern, flags).transmute()
  }

  fn test(self, string: String) -> Bool {
    self->test(string).transmute()
  }
}

#[type_id = 'Bool']
export type Bool {}
impl Bool {
  fn toString(self) -> String {
    if self
      then 'true'
      else 'false'
  }
}

export enum Radix {
  Binary
  Octal
  Decimal
  Hex
}

impl Radix {
  fn pattern(self) -> RegExp {
    match self {
      Radix::Binary => RegExp.new('^[-+]?[01]+$')
      Radix::Octal => RegExp.new('^[-+]?[0-7]+$')
      Radix::Decimal => RegExp.new('^[-+]?[0-9]+$')
      Radix::Hex => RegExp.new('^[-+]?[0-9A-Fa-f]+$')
    }
  }

  fn radix(self) -> Num {
    match self {
      Radix::Binary => 2
      Radix::Octal => 8
      Radix::Decimal => 10
      Radix::Hex => 16
    }
  }
}

#[type_id = 'Num']
export type Num {}
impl Num {
  fn parseInt(string: String, radix: Radix = Radix::Decimal) -> Result<Num, ()> {
    if radix.pattern().test(string)
      then Result::Ok(js->parseInt(string, radix.radix()).transmute())
      else Result::Err(())
  }

  fn parse(string: String) -> Result<Num, ()> {
    if RegExp.new('^[-+]?[0-9]+(\\.[0-9]+)?$').test(string)
      then Result::Ok(js->parseFloat(string, 10).transmute())
      else Result::Err(())
  }

  fn isNan(self) -> Bool {
    js->isNaN(self).transmute()
  }

  fn isInfinite(self) -> Bool {
    self == js->infinity.transmute() or self == -js->infinity.transmute()
  }

  fn ceil(self) -> Num {
    js->Math->ceil(self).transmute()
  }

  fn floor(self) -> Num {
    js->Math->floor(self).transmute()
  }

  fn round(self) -> Num {
    js->Math->round(self).transmute()
  }

  fn limit(self, range: Range) -> Num {
    if self < range.start
      then range.start
    else if self >= range.end
      then range.end - 1
    else self
  }

  fn cmp(self, other: Num) -> Ordering {
    if self < other
      then Ordering::Less
    else if self > other
      then Ordering::Greater
    else Ordering::Equal
  }

  fn toString(self) -> String {
    self->toString().transmute()
  }
}

impl Add<Num, Num> for Num {
  fn add(self, rhs: Num) -> Num {self + rhs}
}

impl Sub<Num, Num> for Num {
  fn sub(self, rhs: Num) -> Num {self - rhs}
}

impl Mul<Num, Num> for Num {
  fn mul(self, rhs: Num) -> Num {self * rhs}
}

impl Div<Num, Num> for Num {
  fn div(self, rhs: Num) -> Num {self / rhs}
}

impl Rem<Num, Num> for Num {
  fn rem(self, rhs: Num) -> Num {self % rhs}
}

impl Pow<Num, Num> for Num {
  fn pow(self, rhs: Num) -> Num {self ** rhs}
}

#[type_id = 'String']
export type String {}
impl String {
  fn size(self) -> Num {
    self->length.transmute()
  }

  fn contains(self, subStr: String) -> Bool {
    self.find(subStr).andValue(Option::Some(true)).unwrapOr(false)
  }

  fn startsWith(self, subStr: String) -> Bool {
    self.sub(0..subStr.size()) == subStr
  }

  fn endsWith(self, subStr: String) -> Bool {
    self.sub(Range.new(self.size() - subStr.size(), self.size())) == subStr
  }

  fn split(self, pattern: String = '') -> List<String> {
    self->split(pattern).transmute()
  }

  fn find(self, pattern: String = '') -> Option<Num> {
    let index: Num = self->indexOf(pattern).transmute()
    if index >= 0
      then Option::Some(index)
      else Option::None
  }

  fn sub(self, range: Range<Num>) -> String {
    if range.end < range.start then panic('The range is reversed')

    self->substring(range.start, range.end).transmute()
  }

  /// Pads the string on the left if it is shorter than width.
  ///
  /// If width is already smaller than or equal to String::size(),
  /// no padding is added. A negative width is treated as zero.
  ///
  /// If padding has length different from 1, the result will not have length width.
  fn padLeft(self, width: Num, padding: String = ' ') -> String {
    let width: Num =
      if width < 0
        then 0
        else width

    let padding =
      if padding == ''
        then ' '
        else padding

    if self.size() >= width
      then return self

    let padCount = (width - self.size()) / padding.size()
    let mut i = 0
    let mut new = self
    while i < padCount {
      new = padding ++ new
      i += 1
    }

    new
  }

  /// Pads the string on the right if it is shorter than width.
  ///
  /// If width is already smaller than or equal to String::size(),
  /// no padding is added. A negative width is treated as zero.
  ///
  /// If padding has length different from 1, the result will not have length width.
  fn padRight(self, width: Num, padding: String = ' ') -> String {
    let width: Num =
      if width < 0
        then 0
        else width

    let padding =
      if padding == ''
        then ' '
        else padding

    if self.size() >= width
      then return self

    let padCount = (width - self.size()) / padding.size()
    let mut i = 0
    let mut new = self
    while i < padCount {
      new = new ++ padding
      i += 1
    }

    new
  }

  fn toLowerCase(self) -> String {
    anyCast(self).toLowerCase()
  }

  fn toUpperCase(self) -> String {
    anyCast(self).toUpperCase()
  }

  /// Removes leading and trailing whitespace
  fn trim(self) -> String {
    self.trimLeft().trimRight()
  }

  /// Removes leading whitespace
  fn trimLeft(self) -> String {
    anyCast(self).replace(RegExp.new('^\\s+'), '')
  }

  /// Removes trailing whitespace
  fn trimRight(self) -> String {
    anyCast(self).replace(RegExp.new('\\s+$'), '')
  }
}

impl Concat<String, String> for String {
  fn concat(self, rhs: String) -> String {self ++ rhs}
}

// FIX: These should work
// impl Concat<Num, String> for String {
//   fn concat(self, rhs: Num) -> String {self ++ rhs}
// }

// impl Concat<String, String> for Num {
//   fn concat(self, rhs: String) -> String {self ++ rhs}
// }

type StringIterator {
  index: Num
  string: String
}

impl Iterator<String> for StringIterator {
  fn next(mut self) -> Option<String> {
    if self.index < self.string.size() {
      let char: String = self.string->charAt(self.index).transmute()
      self.index += 1
      Option::Some(char)
    }
    else Option::None
  }
}

impl IntoIterator<String> for String {
  fn iter(self) -> StringIterator {
    let iterator: StringIterator = {
      index: 0
      string: self
    }
    iterator
  }
}

impl Index<Num, String> for String {
  fn index(self, index: Num) -> String {
    if index < 0 then panic('index out of bounds: index must be positive but is $index')
    if index >= self.size() {
      panic('index out of bounds: the length is ' ++ self.size().toString() ++ ' but the index is $index')
    }

    self->charAt(index).transmute()
  }
}

export enum Result<T, E> {
  Ok(T)
  Err(E)
}
export let Ok = Result::Ok
export let Err = Result::Err
impl<T, E> Result<T, E> {
  fn isOk(self) -> Bool {
    match self {
      Ok(_) => true
      Err(_) => false
    }
  }
  fn isErr(self: Result<T, E>) -> Bool {
    match self {
      Ok(_) => false
      Err(_) => true
    }
  }

  /// Returns res if the result is Ok, otherwise returns the Err value of self.
  fn andValue<U>(self, res: Result<U, E>) -> Result<U, E> {
    if self.isOk()
      then res
      else self
  }

  /// Calls op if the result is Ok, otherwise returns the Err value of self.
  ///
  /// This function can be used for control flow based on Result values.
  fn andThen<U>(self: Result<T, E>, op: (T) -> Result<U, E>) -> Result<U, E> {
    if let Ok(value) = self
      then op(value)
      else self
  }

  /// Returns res if the result is Err, otherwise returns the Ok value of self.
  fn orValue<F>(self, res: Result<T, F>) -> Result<T, F> {
    if self.isErr()
      then res
      else self
  }

  /// Calls op if the result is Err, otherwise returns the Ok value of self.
  ///
  /// This function can be used for control flow based on result values.
  fn orElse<F>(self, op: (E) -> Result<T, F>) -> Result<T, F> {
    if let Err(err) = self
      then op(err)
      else self
  }

  /// Maps a Result<T, E> to Result<U, E> by applying a function to a contained Ok value, leaving an Err value untouched.
  ///
  /// This function can be used to compose the results of two functions.
  fn map<U>(self: Result<T, E>, op: (T) -> U) -> Result<U, E> {
    if let Ok(value) = self
      then Ok(op(value))
      else self
  }

  /// Maps a Result<T, E> to Result<T, F> by applying a function to a contained Err value, leaving an Ok value untouched.
  fn mapErr<F>(self: Result<T, E>, op: (E) -> F) -> Result<T, F> {
    if let Result::Err(value) = self
      then Err(op(value))
      else self
  }

  fn unwrap(self) -> T {
    match self {
      Ok(value) => value
      Err(err) => panic(Error(err))
    }
  }

  fn unwrapOr(self, default: T) -> T {
    if let Ok(value) = self
      then value
      else default
  }

  fn unwrapOrElse(self, default: () -> T) -> T {
    if let Ok(value) = self
      then value
      else default()
  }

  fn unwrapErr(self) -> E {
    match self {
      Ok(value) => panic(Error(value))
      Err(err) => err
    }
  }
}

#[type_id = 'Option']
export enum Option<T> {
  Some(T)
  None
}
export let Some = Option::Some
export let None = Option::None
impl<T> Option<T> {
  fn isSome(self) -> Bool {
    match self {
      Some(_) => true
      Option::None => false
    }
  }
  fn isNone(self) -> Bool {
    match self {
      Some(_) => false
      Option::None => true
    }
  }

  fn okOr<E>(self, err: E) -> Result<T, E> {
    if let Some(value) = self
      then Ok(value)
      else Err(err)
  }

  fn okOrElse<E>(self, err: () -> E) -> Result<T, E> {
    if let Some(value) = self
      then Ok(value)
      else Err(err())
  }

  /// Returns None if the option is None, otherwise returns optb.
  fn andValue<U>(self, optb: Option<U>) -> Option<U> {
    if self.isNone()
      then self
      else optb
  }

  fn andThen<U>(self, op: (T) -> Option<U>) -> Option<U> {
    if let Some(value) = self
      then op(value)
      else self
  }

  /// Returns the option if it contains a value, otherwise returns optb.
  fn orValue(self, optb: Option<T>) -> Option<T> {
    if self.isSome()
      then self
      else optb
  }

  fn orElse(self, op: () -> Option<T>) -> Option<T> {
    if self.isNone()
      then op()
      else self
  }

  fn map<U>(self, f: (T) -> U) -> Option<U> {
    if let Some(value) = self
      then Some(f(value))
      else self
  }

  fn mapOr<U>(self, default: U, f: (T) -> U) -> U {
    if let Some(value) = self
      then f(value)
      else default
  }

  fn mapOrElse<U>(self, default: () -> U, f: (T) -> U) -> U {
    if let Some(value) = self
      then f(value)
      else default()
  }

  fn unwrap(self) -> T {
    match self {
      Some(value) => value
      Option::None => panic('Can not unwrap empty Option')
    }
  }

  fn unwrapOr(self, default: T) -> T {
    if let Some(value) = self
      then value
      else default
  }

  fn unwrapOrElse(self, default: () -> T) -> T {
    if let Some(value) = self
      then value
      else default()
  }
}

/// An Ordering is the result of a comparison between two values.
export enum Ordering {
  Less
  Equal
  Greater
}

impl Ordering {
  /// Reverse the Ordering.
  ///
  /// - Less becomes Greater.
  /// - Greater becomes Less.
  /// - Equal becomes Equal.
  ///
  /// Example:
  /// ```
  /// // sort the array from largest to smallest.
  /// data.sortBy(|a, b| a.cmp(b).reverse())
  /// ```
  fn reverse(self) -> Ordering {
    match self {
      Ordering::Less => Ordering::Greater
      Ordering::Equal => Ordering::Equal
      Ordering::Greater => Ordering::Less
    }
  }
}

#[type_id = 'List']
export type List<E> {}
impl<E> List<E> {
  fn zip<A, B>(a: Iterable<A>, b: List<B>) -> List<(A, B)> {
    if a.size() != b.size()
      then panic(Error('Iterable a and b are not of the same length'))

    a.enumerate().map(|(i, a)| (a, b[i])).toList()
  }

  fn push(mut self, element: E) -> () {
    self->push(element)
  }

  fn lpush(mut self, element: E) -> () {
    self->unshift(element)
  }

  /// Removes the element at position index from this list.
  ///
  /// This method reduces the length of this by one and moves all later objects down by one position.
  ///
  /// Returns the removed object.
  ///
  /// The index must be in the range 0 ≤ index < length.
  fn removeAt(mut self, index: Num) -> E {
    let element = self[index]
    self->splice(index, 1)
    element
  }

  /// Removes all objects from this list that satisfy test.
  ///
  /// An object o satisfies test if test(o) is true.
  fn removeWhere(mut self, test: (E) -> Bool) -> () {
    let mut index = -1
    let mut i = 0
    for e of self {
      if test(e) {
        index = i
      }
      i += 1
    }

    if index > -1 {
      self.removeAt(index)
      true
    }
    else false
  }

  fn get(self, index: Num) -> Option<E> {
    if index >= 0 and index < self.size()
      then Some(self[index])
      else None
  }

  fn contains(self, item: E) -> Bool {
    let index: Num = self->indexOf(item).transmute()
    index != -1
  }

  /// Binary search a sorted slice with a comparator function.
  ///
  /// The comparator function should implement an order consistent with
  /// the sort order of the underlying slice, returning an order code that
  /// indicates whether its argument is Less, Equal or Greater the desired target.
  ///
  /// If a matching value is found then returns Ok, containing the index for
  /// the matched element; if no match is found then Err is returned, containing
  /// the index where a matching element could be inserted while maintaining
  /// sorted order.
  fn binarySearchBy(self, f: (E) -> Ordering) -> Result<Num, Num> {
    let mut min = 0
    let mut max: Num = self.size() - 1
    while true {
      if max < min then return Err(min)
      let range = min + max
      let mut guess: Num = (range / 2)
      guess = guess.floor()

      match f(self[guess]) {
        Ordering::Equal => return Ok(guess)
        Ordering::Less => {
          min = guess + 1
        }
        Ordering::Greater => {
          max = guess - 1
        }
      }
    }

    Err(0)
  }
}

impl<E> Concat<List<E>, List<E>> for List<E> {
  fn concat(self, rhs: List<E>) -> List<E> {self->concat(rhs).transmute()}
}

/// Conversion into an Iterator.
///
/// By implementing IntoIterator for a type, you define how it will be
/// converted to an iterator. This is common for types which describe
/// a collection of some kind.
///
/// One benefit of implementing IntoIterator is that your type will work
/// with the for loop syntax.
#[type_id = 'IntoIterator']
export trait IntoIterator<E> {
  fn iter(self) -> Iterator<E>
}

/// An iterator that maps the values of iter with f.
///
/// This struct is created by the map() method on Iterator.
type MapIterator<I, F> {
  iter: I
  f: F
}

impl<E, F> Iterator<E> for MapIterator<Iterator<E>, F> {
  fn next(mut self) -> Option<E> {
    self.iter.next().map(self.f)
  }
}

/// An iterator that filters the elements of iter with predicate.
///
/// This struct is created by the filter() method on Iterator.
type FilterIterator<I, P> {
  iter: I
  predicate: P
}

impl<E, P> Iterator<E> for FilterIterator<Iterator<E>, (E) -> Bool> {
  fn next(mut self) -> Option<E> {
    while true {
      if let Some(value) = self.iter.next() {
        if self.predicate(value)
          then return Some(value)
      }
      else return None
    }
    None
  }
}

/// An iterator that uses f to both filter and map elements from iter.
///
/// This struct is created by the filterMap() method on Iterator.
type FilterMapIterator<I, F> {
  iter: I
  f: F
}

impl<E, U, P> Iterator<E> for FilterMapIterator<Iterator<E>, (E) -> Option<U>> {
  fn next(mut self) -> Option<E> {
    while true {
      if let Some(value) = self.iter.next() {
        if let Some(value) = self.f(value)
          then return Some(value)
      }
      else return None
    }
    None
  }
}

type FlatMapIterator<I, E, U> {
  iter: I
  flatteningIter: Option<Iterator<U>>
  f: (E) -> IntoIterator<U>
}

impl<E, U, P> Iterator<E> for FlatMapIterator<Iterator<E>, E, U> {
  fn next(mut self) -> Option<E> {
    if let Some(mut i) = self.flatteningIter {
      if let Some(value) = i.next()
        then return Some(value)
        else {
          self.flatteningIter = None
        }
    }


    while true {
      if let Some(value) = self.iter.next() {
        let mut iter = self.f(value).iter()
        if let Some(value) = iter.next() {
          self.flatteningIter = Some(iter)
          return Some(value)
        }
      }
      else return None
    }
    None
  }
}

#[type_id = 'Iterator']
export trait Iterator<E> {
  /// Advances the iterator and returns the next value.
  ///
  /// Returns None when iteration is finished. Individual iterator implementations
  /// may choose to resume iteration, and so calling next() again may or may not
  /// eventually start returning Some(Item) again at some point.
  fn next(mut self) -> Option<E>

  /// Consumes the iterator, counting the number of iterations and returning it.
  ///
  /// This method will evaluate the iterator until its next() returns None.
  /// Once None is encountered, count() returns the number of times it called next().
  fn count(mut self) -> Num {
    let mut count_ = 0
    while true {
      if let Some(value) = self.next() {
        count_ += 1
      }
      else return count_
    }
    count_
  }

  fn map<U>(self, f: (E) -> U) -> Iterator<U> {
    let iter: MapIterator<Self, f> = {
      iter: self
      f
    }
    iter
  }

  /// Creates an iterator which uses a closure to determine if an element
  /// should be yielded.
  ///
  /// The closure must return true or false. filter() creates an iterator
  /// which calls this closure on each element. If the closure returns true,
  /// then the element is returned. If the closure returns false, it will
  /// try again, and call the closure on the next element, seeing if it
  /// passes the test.
  fn filter(self, predicate: (E) -> Bool) -> Iterator<E> {
    let iter: FilterIterator<Self, predicate> = {
      iter: self
      predicate
    }
    iter
  }

  /// Creates an iterator that both filters and maps.
  ///
  /// The closure must return an Option<T>. filterMap() creates an iterator
  /// which calls this closure on each element. If the closure returns
  /// Some(element), then that element is returned. If the closure returns
  /// None, it will try again, and call the closure on the next element,
  /// seeing if it will return Some.
  ///
  /// Why filterMap() and not just filter().map()? The key is in this part:
  ///
  ///     If the closure returns Some(element), then that element is returned.
  ///
  /// In other words, it removes the Option<T> layer automatically.
  /// If your mapping is already returning an Option<T> and you want to skip
  /// over Nones, then filterMap() is much, much nicer to use.
  fn filterMap<U>(self, f: (E) -> Option<U>) -> Iterator<U> {
    let iter: FilterMapIterator<Self, f> = {
      iter: self
      f
    }
    iter
  }

  fn flatMap<U> (self, f: (E) -> IntoIterator<U>) -> Iterator<U> {
    let iter: FlatMapIterator<Self, E, U> = {
      iter: self
      flatteningIter: None
      f
    }
    iter
  }

  /// Creates an iterator which gives the current iteration count
  /// as well as the next value.
  ///
  /// The iterator returned yields pairs (i, val), where i is the
  /// current index of iteration and val is the value returned by the iterator.
  fn enumerate(self) -> Iterator<(Num, E)> {
    let mut index = -1
    self.map(|e| {
      index += 1
      (index, e)
    })
  }

  /// An iterator adaptor that applies a function, producing a single, final value.
  ///
  /// fold() takes two arguments: an initial value, and a closure with two arguments:
  /// an 'accumulator', and an element. The closure returns the value that the
  /// accumulator should have for the next iteration.
  ///
  /// The initial value is the value the accumulator will have on the first call.
  ///
  /// After applying this closure to every element of the iterator, fold() returns the accumulator.
  ///
  /// This operation is sometimes called 'reduce' or 'inject'.
  ///
  /// Folding is useful whenever you have a collection of something, and want to
  /// produce a single value from it.
  fn fold<B>(mut self, init: B, reducer: (B, E) -> B) -> B {
    let mut accumulator = init
    while true {
      if let Some(value) = self.next() {
        accumulator = reducer(accumulator, value)
      }
      else return accumulator
    }
  }

  /// Tests if all elements of the iterator matches a predicate.
  ///
  /// all() takes a closure that returns true or false. It applies this
  /// closure to each element of the iterator, and if all of them return
  /// true, then so does all(). If any of them return false, it returns false.
  ///
  /// all() is short-circuting; in other words, it will stop processing
  /// as soon as it finds a false, given that no matter what else happens,
  /// the result will also be false.
  ///
  /// An empty iterator returns true.
  fn all(mut self, predicate: (E) -> Bool) -> Bool {
    while true {
      if let Some(value) = self.next() {
        if not predicate(value)
          then return false
      }
      else return true
    }
    true
  }

  /// Tests if any element of the iterator matches a predicate.
  ///
  /// any() takes a closure that returns true or false. It applies this
  /// closure to each element of the iterator, and if any of them return
  /// true, then so does any(). If they all return false, it returns false.
  ///
  /// any() is short-circuting; in other words, it will stop processing
  /// as soon as it finds a true, given that no matter what else happens,
  /// the result will also be true.
  ///
  /// An empty iterator returns false.
  fn any(mut self, predicate: (E) -> Bool) -> Bool {
    while true {
      if let Some(value) = self.next() {
        if predicate(value)
          then return true
      }
      else return false
    }
    false
  }

  /// Searches for an element of an iterator that satisfies a predicate.
  ///
  /// find() takes a closure that returns true or false. It applies this
  /// closure to each element of the iterator, and if any of them return
  /// true, then find() returns Some(element). If they all return false,
  /// it returns None.
  ///
  /// find() is short-circuting; in other words, it will stop processing
  /// as soon as the closure returns true.
  fn find(mut self, predicate: (E) -> Bool) -> Option<E> {
    while true {
      if let Some(value) = self.next() {
        if predicate(value)
          then return Some(value)
      }
      else return None
    }
    None
  }

  /// Searches for an element in an iterator, returning its index.
  ///
  /// position() takes a closure that returns true or false. It applies this
  /// closure to each element of the iterator, and if one of them returns true,
  /// then position() returns Some(index).
  /// If all of them return false, it returns None.
  ///
  /// position() is short-circuiting; in other words, it will stop
  /// processing as soon as it finds a true.
  fn position(mut self, predicate: (E) -> Bool) -> Option<Num> {
    let mut index = 0
    while true {
      if let Some(value) = self.next() {
        if predicate(value)
          then return Some(index)
      }
      else return None
      index += 1
    }
    None
  }

  fn forEach(mut self, f: (E) -> ()) -> () {
    while true {
      if let Some(value) = self.next() {
        f(value)
      }
      else break
    }
  }

  // TODO: Implement correctly when possible
  fn collect(mut self) -> List<E> {
    let mut list = []
    while true {
      if let Some(value) = self.next() {
        list.push(value)
      }
      else return list
    }
    list
  }
}
export trait Iterable<E> {
  fn enumerate(self) -> Iterable<(Num, E)>

  fn size(self) -> Num
  fn isEmpty(self) -> Bool
  fn isNotEmpty(self) -> Bool
  fn first(self) -> Option<E>
  fn last(self) -> Option<E>

  fn all(self, predicate: (E) -> Bool) -> Bool
  fn any(self, predicate: (E) -> Bool) -> Bool
  fn find(self, predicate: (E) -> Bool) -> Option<E>

  fn filter(self, func: (E) -> Bool) -> Iterable<E>
  fn forEach(self, func: (E) -> ()) -> ()
  fn map<U>(self, func: (E) -> U) -> Iterable<U>
  fn filterMap<U>(self, func: (E) -> Option<U>) -> Iterable<U>

  /// Returns an Iterable that yields all but the first [count] elements.
  fn skip(self, count: Num) -> Iterable<E>

  /// Returns an Iterable that skips leading elements until [test] is satisfied.
  fn skipUntil(self, test: (E) -> Bool) -> Iterable<E>

  /// Returns an Iterable that yields its first count elements.
  /// If count is greater than the Iterable size the returned Iterable
  /// will end at its size, before count is reached.
  fn take(self, count: Num) -> Iterable<E>

  fn toList(self) -> List<E>
}

type ListIterator<E> {
  index: Num
  list: List<E>
}

impl<E> Iterator<E> for ListIterator<E> {
  fn next(mut self) -> Option<E> {
    let element = self.list.get(self.index)
    if element.isSome() {
      self.index += 1
    }
    element
  }
}

impl<E> IntoIterator<E> for List<E> {
  fn iter(self) -> ListIterator<E> {
    let iterator: ListIterator<E> = {
      index: 0
      list: self
    }
    iterator
  }
}

fn asList<E>(a) -> List<E> {a}

impl<E> Iterable<E> for List<E> {

  fn enumerate(self) -> Iterable<(Num, E)> {
    asList(self->map(|element, index| (index, element)))
  }

  fn size(self) -> Num {
    self->length.transmute()
  }

  fn isEmpty(self) -> Bool {
    self.size() == 0
  }

  fn isNotEmpty(self) -> Bool {
    self.size() > 0
  }

  fn first(self) -> Option<E> {
    if self.size() > 0
      then Some(self[0])
      else None
  }

  fn last(self) -> Option<E> {
    if self.size() > 0
      then Some(self[self.size() - 1])
      else None
  }

  fn all(self, predicate: (E) -> Bool) -> Bool {
    let mut i = 0
    while i < self.size() {
      if not predicate(self[i]) then return false
      i += 1
    }
    true
  }

  fn any(self, predicate: (E) -> Bool) -> Bool {
    let mut i = 0
    while i < self.size() {
      if predicate(self[i]) then return true
      i += 1
    }
    false
  }

  fn find(self, predicate: (E) -> Bool) -> Option<E> {
    let index: Num = self->findIndex(predicate).transmute()

    if index >= 0
      then Some(self[index])
      else None
  }

  fn forEach(self, func: (E) -> ()) -> () {
    self->forEach(func)
  }

  fn filter(self, func: (E) -> Bool) -> Iterable<E> {
    asList(anyCast(self).filter(func))
  }

  fn map<U>(self, func: (E) -> U) -> Iterable<U> {
    asList(anyCast(self).map(func))
  }

  fn filterMap<U>(self, func: (E) -> Option<U>) -> Iterable<U> {
    let mut newList: List<U> = []
    self.forEach(|element| {
      if let Some(mappedElement) = func(element) {
        newList.push(mappedElement)
      }
    })
    newList
  }

  fn skip(self, count: Num) -> Iterable<E> {
    asList(self->slice(count))
  }

  fn skipUntil(self, predicate: (E) -> Bool) -> Iterable<E> {
    let index: Num = self->findIndex(predicate).transmute()
    asList(
      if index == -1
        then []
        else self->slice(index).transmute()
    )
  }

  fn take(self, count: Num) -> Iterable<E> {
    asList(self->slice(0, count))
  }

  fn toList(self) -> List<E> {
    self
  }
}

/// A (half-open) range which is bounded at both ends: { x | start <= x < end }.
/// Use start..end (two dots) for its shorthand.
#[type_id = 'Range']
export type Range<Idx=Num> {
  /// The lower bound of the range (inclusive).
  start: Idx
  /// The upper bound of the range (exclusive).
  end: Idx
}
// TODO: Implement range.new on T instead of Num
// impl<T> Range<T> {
//   fn new(start: T, end: T) -> Range<T> {{start, end}}
// }

impl Range<Num> {
  fn new(start: Num, end: Num) -> Range<Num> {{start, end}}

  fn contains(self, item: Num) -> Bool {
    self.start <= item and item < self.end
  }
  fn isSubsetOf(self, other: Range<Num>) -> Bool {
    self.start >= other.start and other.end >= self.end
  }
}

type NumRangeIterator {
  index: Num
  end: Num
}

impl Iterator<Num> for NumRangeIterator {
  fn next(mut self) -> Option<Num> {
    let element = self.index
    if element < self.end {
      self.index += 1
      Some(element)
    }
    else None
  }
}

impl IntoIterator<Num> for Range<Num> {
  fn iter(self) -> NumRangeIterator {
    let iterator: NumRangeIterator = {
      index: self.start
      end: self.end
    }
    iterator
  }
}

export fn print<T>(message, extra: T = ()) -> () {
  if identical(extra, ())
    then console->log(message)
    else console->log->apply(console, [message]->concat(extra))
}

export fn panic(reason: String) -> Never {
  js->panic(reason).transmute()
}

export type ObjectMap<T> {}
impl<T> ObjectMap<T> {
  fn new<T>() -> ObjectMap<T> {
    Object->create(null).transmute()
  }

  fn fromIter<T>(list: Iterable<(String, T)>) -> ObjectMap<T> {
    let mut object = ObjectMap.new()
    list.forEach(|(key, item)| object.set(key, item))
    object
  }

  fn size(self) -> Num {
    self.keys()->length.transmute()
  }

  fn isEmpty(self) -> Bool {
    self.size() == 0
  }

  fn isNotEmpty(self) -> Bool {
    self.size() > 0
  }

  fn keys(self) -> List<String> {
    Object->keys(self).transmute()
  }

  fn values(self) -> List<T> {
    self.keys().map(|key| self[key]).toList()
  }

  fn toList(self) -> List<(String, T)> {
    self.keys().map(|key| (key, self[key])).toList()
  }

  fn all(self, predicate: (T) -> Bool) -> Bool {
    let mut i = 0
    let keys = self.keys()
    while i < keys.size() {
      if not predicate(self[keys[i]]) then return false
      i += 1
    }
    true
  }

  fn any(self, predicate: (T) -> Bool) -> Bool {
    let mut i = 0
    let keys = self.keys()
    while i < keys.size() {
      if predicate(self[keys[i]]) then return true
      i += 1
    }
    false
  }

  fn map<U>(self, mapper: (T) -> U) -> ObjectMap<U> {
    let mut new = ObjectMap.new()
    self.keys().forEach(|key| {
      new[key] = mapper(self[key])
    })
    new
  }

  fn find(self, predicate: ((String, T)) -> Bool) -> Option<(String, T)> {
    let key = self.keys().find(|key| predicate((key, self[key])))

    if let Some(key) = key
      then Some((key, self[key]))
      else None
  }

  fn forEach(self, func: ((String, T)) -> ()) -> () {
    let keys: List<String> = Object->keys(self).transmute()
    keys.forEach(|key| {
      func((key, self[key]))
    })
  }

  fn delete(mut self, key: String) -> () {
    js->['delete'](self, key)
  }

  fn has(self, key: String) -> Bool {
    Object->prototype->hasOwnProperty->call(self, key).transmute()
  }

  fn get(self, key: String) -> Option<T> {
    if self.has(key)
      then Some(self[key])
      else None
  }

  fn set(mut self, key: String, value: T) -> () {
    self[key] = value
  }

  fn merge(mut self, other: ObjectMap<T>) -> () {
    Object->assign(self, other)
  }
}

export enum Never {}

/// The Index trait is used to specify the functionality
/// of indexing operations like list[idx].
#[type_id = 'Index']
export trait Index<Idx, Out> {
  fn index(self, index: Idx) -> Out
}

impl<E> Index<Num, E> for List<E> {
  fn index(self, index: Num) -> E {
    if index < 0 then panic('index out of bounds: index must be positive but is $index')
    if index >= self.size() {
      panic('index out of bounds: the length is ' ++ self.size().toString() ++ ' but the index is $index')
    }

    self->[index].transmute()
  }
}

impl<T> Index<String, T> for ObjectMap<T> {
  fn index(self, key: String) -> T {
    if not self.has(key) then panic('The key $key is missing')

    self->[key].transmute()
  }
}

impl<K, V> Index<K, V> for Map<K, V> {
  fn index(self, key: K) -> V {
    if not self.has(key) then panic('The key $key is missing')

    self.get(key).unwrap()
  }
}

/// Trait for equality comparisons which are partial equivalence relations.
///
/// This trait allows for partial equality, for types that do not have a
/// full equivalence relation. For example, in floating point numbers
/// NaN != NaN, so floating point types implement PartialEq but not Eq.
///
/// Formally, the equality must be (for all a, b and c):
///
/// - symmetric: a == b implies b == a; and
/// - transitive: a == b and b == c implies a == c.
///
/// Note that these requirements mean that the trait itself must be implemented
/// symmetrically and transitively: if T: PartialEq<U> and U: PartialEq<V>
/// then U: PartialEq<T> and T: PartialEq<V>.
#[type_id = 'PartialEq']
export trait PartialEq<Rhs> {
  fn eq(self, other: Rhs) -> Bool
  fn ne(self, other: Rhs) -> Bool {not self.eq(other)}
}

impl PartialEq<Bool> for Bool {
  fn eq(self, other: Bool) -> Bool {identical(self, other)}
}

impl PartialEq<Num> for Num {
  fn eq(self, other: Num) -> Bool {identical(self, other)}
}

impl PartialEq<String> for String {
  fn eq(self, other: String) -> Bool {identical(self, other)}
}

/// Trait for values that can be compared for a sort-order.
///
/// The comparison must satisfy, for all a, b and c:
///
/// - antisymmetry: if `a < b` then `!(a > b)`, as well as `a > b` implying `!(a < b)`; and
/// - transitivity: `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.
///
/// Note that these requirements mean that the trait itself must be
/// implemented symmetrically and transitively: if T: PartialOrd<U> and U: PartialOrd<V>
/// then U: PartialOrd<T> and T: PartialOrd<V>.
///
/// # How can I implement Ord?
///
/// PartialOrd only requires implementation of the partialCmp method,
/// with the others generated from default implementations.
///
/// However it remains possible to implement the others separately for types
/// which do not have a total order. For example, for floating point  numbers,
/// `NaN < 0 == false` and `NaN >= 0 == false` (cf. IEEE 754-2008 section 5.11).
///
/// PartialOrd requires your type to be PartialEq.
///
/// If your type is Ord, you can implement partialCmp() by using cmp()
#[type_id = 'PartialOrd']
export trait PartialOrd<Rhs> {
  fn partialCmp(self, other: Rhs) -> Option<Ordering>

  fn lt(self, other: Rhs) -> Bool {
    match self.partialCmp(other) {
      Some(Ordering::Less) => true
      _ => false
    }
  }

  fn le(self, other: Rhs) -> Bool {
    match self.partialCmp(other) {
      Some(Ordering::Less) => true
      Some(Ordering::Equal) => true
      _ => false
    }
  }

  fn gt(self, other: Rhs) -> Bool {
    match self.partialCmp(other) {
      Some(Ordering::Greater) => true
      _ => false
    }
  }

  fn ge(self, other: Rhs) -> Bool {
    match self.partialCmp(other) {
      Some(Ordering::Greater) => true
      Some(Ordering::Equal) => true
      _ => false
    }
  }
}

/// Trait for types that form a [total order](https://en.wikipedia.org/wiki/Total_order).
///
/// An order is a total order if it is (for all `a`, `b` and `c`):
///
/// - total and antisymmetric: exactly one of `a < b`, `a == b` or `a > b` is true; and
/// - transitive, `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.
export trait Ord {
  fn cmp(self, other: Self) -> Ordering
}

impl PartialOrd<Num> for Num {
  fn partialCmp(self, other: Num) -> Option<Ordering> {
    let a = self <= other
    let b = self >= other

    if a and b then Some(Ordering::Equal)
    else if not a and b then Some(Ordering::Greater)
    else if a and not b then Some(Ordering::Less)
    else None
  }

  fn lt(self, other: Num) -> Bool { self < other }
  fn le(self, other: Num) -> Bool { self <= other }
  fn ge(self, other: Num) -> Bool { self >= other }
  fn gt(self, other: Num) -> Bool { self > other }
}

impl Ord for String {
  fn cmp(self, other: String) -> Ordering {
    let cmp: Num = self->localeCompare(other).transmute()

    if cmp > 0 then Ordering::Greater
    else if cmp < 0 then Ordering::Less
    else Ordering::Equal
  }
}

impl PartialOrd<String> for String {
  fn partialCmp(self, other: String) -> Option<Ordering> {
    let o: String = other
    Some(self.cmp(o))
  }
}

export type JsIterator<E> {
  next: () -> {value: E, done: Bool}
}

impl<E> Iterator<E> for JsIterator<E> {
  fn next(mut self) -> Option<E> {
    let {value, done} = self->next().transmute()
    if done
      then None
      else Some(value)
  }
}

impl<E> IntoIterator<E> for JsIterator<E> {
  fn iter(self) -> Iterator<E> {
    let iterator: JsIterator<E> = self
    iterator
  }
}

export type Map<K, V> {}
impl<K, V> Map<K, V> {
  fn new() -> Map<K, V> {
    js->createMap().transmute()
  }

  fn fromIter<K, V>(list: Iterable<(K, V)>) -> Map<K, V> {
    let mut map = Map.new()
    list.forEach(|(key, item)| map.set(key, item))
    map
  }

  fn size(self) -> Num {
    self->size.transmute()
  }

  // Removes all elements the Map
  fn clear(mut self) -> () {
    self->clear()
  }

  fn set(mut self, key: K, value: V) -> () {
    self->set(key, value)
  }

  fn get(self, key: K) -> Option<V> {
    let value: V = self->get(key).transmute()
    if value
      then Some(value)
      else None
  }

  fn delete(mut self, key: K) -> () {
    self->['delete'](key)
  }

  fn has(self, key: K) -> Bool {
    self->has(key).transmute()
  }

  fn entries(self) -> JsIterator<(K, V)> {self->entries().transmute()}
  fn keys(self) -> JsIterator<K> {self->keys().transmute()}
  fn values(self) -> JsIterator<V> {self->values().transmute()}

  fn forEach(self, f: (K, V) -> ()) -> () {
    self->forEach(f)
  }

  fn entry(mut self, key: K) -> Entry<K, V> {{
    map: self
    key
  }}
}

/// A view into a single location in a map, which may be vacant or occupied.
/// This type is constructed from the [entry](Map.entry) method on [Map].
export type Entry<K, V> {
  map: Map<K, V>
  key: K
}

impl<K, V> Entry<K, V> {
  /// Ensures a value is in the entry by inserting the default if empty,
  /// and returns a reference to the value in the entry.
  fn orInsert(mut self, default: V) -> V {
    if let Some(value) = self.map.get(self.key)
      then value
      else {
        self.map.set(self.key, default)
        default
      }
  }

  /// Ensures a value is in the entry by inserting the result of the default
  /// function if empty, and returns a reference to the value in the entry.
  fn orInsertWith(mut self, default: () -> V) -> V {
    if let Some(value) = self.map.get(self.key)
      then value
      else {
        let value = default()
        self.map.set(self.key, value)
        value
      }
  }

  /// Returns a reference to this entry's key.
  fn key(self) -> K {self.key}
}

export type Set<T> {}
impl<T> Set<T> {
  fn new() -> Set<T> {
    js->createSet().transmute()
  }

  fn size(self) -> Num {
    self->size.transmute()
  }

  // Removes all elements the Set
  fn clear(mut self) -> () {
    self->clear()
  }

  fn add(mut self, value: T) -> () {
    self->add(value)
  }

  fn delete(mut self, value: T) -> () {
    self->['delete'](value)
  }

  fn has(self, value: T) -> Bool {
    self->has(value).transmute()
  }

  fn values(self) -> JsIterator<T> {self->values().transmute()}

  fn forEach(self, f: (T) -> ()) -> () {
    self->forEach(f)
  }
}

impl<T> IntoIterator<T> for Set<T> {
  fn iter(self) -> Iterator<T> {
    let jsiter: JsIterator<T> = self.values()
    let iter: Iterator<T> = jsiter
    iter
  }
}
