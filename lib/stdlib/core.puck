//#![no_core]
import 'puck:js' as {Array, Error, Object, console, null, typeof, undefined}
import 'core/js.js' as js

fn anyCast(a) {a}

export type RegExp {}

impl RegExp {
  fn new(pattern, flags = '') -> RegExp {
    js->RegExp(pattern, flags).transmute()
  }

  fn test(self, string: String) -> Bool {
    self->test(string).transmute()
  }
}

#[type_id = 'Bool']
export type Bool {}

export enum Radix {
  Binary
  Octal
  Decimal
  Hex
}

impl Radix {
  fn pattern(self) -> RegExp {
    match self {
      Radix::Binary => RegExp.new('^[-+]?[01]+$')
      Radix::Octal => RegExp.new('^[-+]?[0-7]+$')
      Radix::Decimal => RegExp.new('^[-+]?[0-9]+$')
      Radix::Hex => RegExp.new('^[-+]?[0-9A-Fa-f]+$')
    }
  }

  fn radix(self) -> Num {
    match self {
      Radix::Binary => 2
      Radix::Octal => 8
      Radix::Decimal => 10
      Radix::Hex => 16
    }
  }
}

#[type_id = 'Num']
export type Num {}
impl Num {
  fn parseInt(string: String, radix: Radix = Radix::Decimal) -> Result<Num, ()> {
    if radix.pattern().test(string)
      then Result::Ok(js->parseInt(string, radix.radix()).transmute())
      else Result::Err(())
  }

  fn parse(string: String) -> Result<Num, ()> {
    if RegExp.new('^[-+]?[0-9]+(\\.[0-9]+)?$').test(string)
      then Result::Ok(js->parseFloat(string, 10).transmute())
      else Result::Err(())
  }

  fn isNan(self) -> Bool {
    js->isNaN(self).transmute()
  }

  fn isInfinite(self) -> Bool {
    self == js->infinity or self == -js->infinity
  }

  fn ceil(self) -> Num {
    js->Math->ceil(self).transmute()
  }

  fn floor(self) -> Num {
    js->Math->floor(self).transmute()
  }

  fn round(self) -> Num {
    js->Math->round(self).transmute()
  }

  fn limit(self, range: Range) -> Num {
    if self < range.start
      then range.start
    else if self >= range.end
      then range.end - 1
    else self
  }

  fn cmp(self, other: Num) -> Ordering {
    if self < other
      then Ordering::Less
    else if self > other
      then Ordering::Greater
    else Ordering::Equal
  }
}

#[type_id = 'String']
export type String {}
impl String {
  fn size(self) -> Num {
    self->length.transmute()
  }

  fn contains(self, subStr: String) -> Bool {
    self->indexOf(subStr).transmute() >= 0
  }

  fn split(self, pattern: String = '') -> List<String> {
    anyCast(self).split(pattern)
  }

  /// Pads the string on the left if it is shorter than width.
  ///
  /// If width is already smaller than or equal to String::size(),
  /// no padding is added. A negative width is treated as zero.
  ///
  /// If padding has length different from 1, the result will not have length width.
  fn padLeft(self, width: Num, padding: String = ' ') -> String {
    let width =
      if width < 0
        then 0
        else width

    let padding =
      if padding == ''
        then ' '
        else padding

    if self.size() >= width
      then return self

    let padCount = (width - self.size()) / padding.size()
    let mut i = 0
    let mut new = self
    while i < padCount {
      new = padding + new
      i += 1
    }

    new
  }

  /// Pads the string on the right if it is shorter than width.
  ///
  /// If width is already smaller than or equal to String::size(),
  /// no padding is added. A negative width is treated as zero.
  ///
  /// If padding has length different from 1, the result will not have length width.
  fn padRight(self, width: Num, padding: String = ' ') -> String {
    let width =
      if width < 0
        then 0
        else width

    let padding =
      if padding == ''
        then ' '
        else padding

    if self.size() >= width
      then return self

    let padCount = (width - self.size()) / padding.size()
    let mut i = 0
    let mut new = self
    while i < padCount {
      new = new + padding
      i += 1
    }

    new
  }

  fn toLowerCase(self) -> String {
    anyCast(self).toLowerCase()
  }

  fn toUpperCase(self) -> String {
    anyCast(self).toUpperCase()
  }

  /// Removes leading and trailing whitespace
  fn trim(self) -> String {
    self.trimLeft().trimRight()
  }

  /// Removes leading whitespace
  fn trimLeft(self) -> String {
    anyCast(self).replace(RegExp.new('^\\s+'), '')
  }

  /// Removes trailing whitespace
  fn trimRight(self) -> String {
    anyCast(self).replace(RegExp.new('\\s+$'), '')
  }
}

type StringIterator {
  index: Num
  string: String
}

impl Iterator<String> for StringIterator {
  fn next(mut self) -> Option<String> {
    if self.index < self.string.size() {
      let char: String = self.string->charAt(self.index).transmute()
      self.index += 1
      Option::Some(char)
    }
    else Option::None
  }
}

impl IntoIterator<String> for String {
  fn iter(self) -> StringIterator {
    let iterator: StringIterator = {
      index: 0
      string: self
    }
    iterator
  }
}

export enum Result<T, E> {
  Ok(T)
  Err(E)
}
export let Ok = Result::Ok
export let Err = Result::Err
impl<T, E> Result<T, E> {
  fn isOk(self) -> Bool {self->kind.transmute() == 'Ok'}
  fn isErr(self: Result<T, E>) -> Bool {not self.isOk()}

  /// Calls op if the result is Ok, otherwise returns the Err value of self.
  ///
  /// This function can be used for control flow based on Result values.
  fn andThen<U>(self: Result<T, E>, op: (T) -> Result<U, E>) -> Result<U, E> {
    if let Result::Ok(value) = self
      then op(value)
      else self
  }

  /// Maps a Result<T, E> to Result<U, E> by applying a function to a contained Ok value, leaving an Err value untouched.
  ///
  /// This function can be used to compose the results of two functions.
  fn map<U>(self: Result<T, E>, op: (T) -> U) -> Result<U, E> {
    if let Result::Ok(value) = self
      then Ok(op(value))
      else self
  }

  /// Maps a Result<T, E> to Result<T, F> by applying a function to a contained Err value, leaving an Ok value untouched.
  fn mapErr<F>(self: Result<T, E>, op: (E) -> F) -> Result<T, F> {
    if let Result::Err(value) = self
      then Err(op(value))
      else self
  }

  fn unwrap(self) -> T {
    match self {
      Ok(value) => value
      Err(err) => throw Error(err)
    }
  }

  fn unwrapErr(self) -> E {
    match self {
      Ok(value) => throw Error(value)
      Err(err) => err
    }
  }
}

export enum Option<T> {
  Some(T)
  None
}
export let Some = Option::Some
export let None = Option::None
impl<T> Option<T> {
  fn isSome(self) -> Bool {self->kind.transmute() == 'Some'}
  fn isNone(self) -> Bool {not self.isSome()}

  fn okOr<E>(self, err: E) -> Result<T, E> {
    if let Option::Some(value) = self
      then Ok(value)
      else Err(err)
  }

  fn okOrElse<E>(self, err: () -> E) -> Result<T, E> {
    if let Option::Some(value) = self
      then Ok(value)
      else Err(err())
  }

  /// Returns None if the option is None, otherwise returns optb.
  fn andValue<U>(self, optb: Option<U>) -> Option<U> {
    if self.isNone()
      then self
      else optb
  }

  fn andThen<U>(self, op: (T) -> Option<U>) -> Option<U> {
    if let Option::Some(value) = self
      then op(value)
      else self
  }

  /// Returns the option if it contains a value, otherwise returns optb.
  fn orValue(self, optb: Option<T>) -> Option<T> {
    if self.isSome()
      then self
      else optb
  }

  fn orElse(self, op: () -> Option<T>) -> Option<T> {
    if self.isNone()
      then op()
      else self
  }

  fn map<U>(self, f: (T) -> U) -> Option<U> {
    if let Option::Some(value) = self
      then Some(f(value))
      else self
  }

  fn mapOr<U>(self, default: U, f: (T) -> U) -> U {
    if let Option::Some(value) = self
      then f(value)
      else default
  }

  fn mapOrElse<U>(self, default: () -> U, f: (T) -> U) -> U {
    if let Option::Some(value) = self
      then f(value)
      else default()
  }

  fn unwrap(self) -> T {
    match self {
      Some(value) => value
      Option::None => throw Error('Can not unwrap empty Option')
    }
  }

  fn unwrapOr(self, default: T) -> T {
    if let Option::Some(value) = self
      then value
      else default
  }

  fn unwrapOrElse(self, default: () -> T) -> T {
    if let Option::Some(value) = self
      then value
      else default()
  }
}

export enum Ordering {
  Less
  Equal
  Greater
}

impl Ordering {
  /// Reverse the Ordering.
  ///
  /// - Less becomes Greater.
  /// - Greater becomes Less.
  /// - Equal becomes Equal.
  ///
  /// Example:
  /// ```
  /// // sort the array from largest to smallest.
  /// data.sortBy(|a, b| a.cmp(b).reverse())
  /// ```
  fn reverse(self) -> Ordering {
    match self {
      Ordering::Less => Ordering::Greater
      Ordering::Equal => Ordering::Equal
      Ordering::Greater => Ordering::Less
    }
  }
}

#[type_id = 'List']
export type List<E> {}
impl<E> List<E> {
  fn zip<A, B>(a: Iterable<A>, b: List<B>) -> List<(A, B)> {
    if a.size() != b.size()
      then throw Error('Iterable a and b are not of the same length')

    a.enumerate().map(|(i, a)| (a, b[i])).toList()
  }

  fn push(mut self, element: E) -> () {
    self->push(element)
  }

  fn lpush(mut self, element: E) -> () {
    self->unshift(element)
  }

  fn get(self, index: Num) -> Option<E> {
    if index >= 0 and index < self.size()
      then Some(self[index])
      else None
  }

  fn contains(self, item: E) -> Bool {
    self->indexOf(item) != -1
  }

  /// Binary search a sorted slice with a comparator function.
  ///
  /// The comparator function should implement an order consistent with
  /// the sort order of the underlying slice, returning an order code that
  /// indicates whether its argument is Less, Equal or Greater the desired target.
  ///
  /// If a matching value is found then returns Ok, containing the index for
  /// the matched element; if no match is found then Err is returned, containing
  /// the index where a matching element could be inserted while maintaining
  /// sorted order.
  fn binarySearchBy(self, f: (E) -> Ordering) -> Result<Num, Num> {
    let mut min = 0
    let mut max = self.size() - 1
    while true {
      if max < min then return Err(min)
      let mut guess: Num = ((min + max) / 2)
      guess = guess.floor()

      match f(self[guess]) {
        Ordering::Equal => return Ok(guess)
        Ordering::Less => {
          min = guess + 1
        }
        Ordering::Greater => {
          max = guess - 1
        }
      }
    }

    Err(0)
  }
}
/// Conversion into an Iterator.
///
/// By implementing IntoIterator for a type, you define how it will be
/// converted to an iterator. This is common for types which describe
/// a collection of some kind.
///
/// One benefit of implementing IntoIterator is that your type will work
/// with the for loop syntax.
export trait IntoIterator<E> {
  fn iter(self) -> Iterator<E>
}

/// An iterator that maps the values of iter with f.
///
/// This struct is created by the map() method on Iterator.
type MapIterator<I, F> {
  iter: I
  f: F
}

impl<E, F> Iterator<E> for MapIterator<Iterator<E>, F> {
  fn next(mut self) -> Option<E> {
    self.iter.next().map(self.f)
  }
}

/// An iterator that filters the elements of iter with predicate.
///
/// This struct is created by the filter() method on Iterator.
type FilterIterator<I, P> {
  iter: I
  predicate: P
}

impl<E, P> Iterator<E> for FilterIterator<Iterator<E>, (E) -> Bool> {
  fn next(mut self) -> Option<E> {
    while true {
      if let Some(value) = self.iter.next() {
        if self.predicate(value)
          then return Some(value)
      }
      else return None
    }
    None
  }
}

/// An iterator that uses f to both filter and map elements from iter.
///
/// This struct is created by the filterMap() method on Iterator.
type FilterMapIterator<I, F> {
  iter: I
  f: F
}

impl<E, U, P> Iterator<E> for FilterMapIterator<Iterator<E>, (E) -> Option<U>> {
  fn next(mut self) -> Option<E> {
    while true {
      if let Some(value) = self.iter.next() {
        if let Some(value) = self.f(value)
          then return Some(value)
      }
      else return None
    }
    None
  }
}

export trait Iterator<E> {
  /// Advances the iterator and returns the next value.
  ///
  /// Returns None when iteration is finished. Individual iterator implementations
  /// may choose to resume iteration, and so calling next() again may or may not
  /// eventually start returning Some(Item) again at some point.
  fn next(mut self) -> Option<E>

  /// Consumes the iterator, counting the number of iterations and returning it.
  ///
  /// This method will evaluate the iterator until its next() returns None.
  /// Once None is encountered, count() returns the number of times it called next().
  fn count(mut self) -> Num {
    let mut count_ = 0
    while true {
      if let Some(value) = self.next() {
        count_ += 1
      }
      else return count_
    }
    count_
  }

  fn map<U>(self, f: (E) -> U) -> Iterator<U> {
    let iter: MapIterator<Self, f> = {
      iter: self
      f
    }
    iter
  }

  /// Creates an iterator which uses a closure to determine if an element
  /// should be yielded.
  ///
  /// The closure must return true or false. filter() creates an iterator
  /// which calls this closure on each element. If the closure returns true,
  /// then the element is returned. If the closure returns false, it will
  /// try again, and call the closure on the next element, seeing if it
  /// passes the test.
  fn filter(self, predicate: (E) -> Bool) -> Iterator<E> {
    let iter: FilterIterator<Self, predicate> = {
      iter: self
      predicate
    }
    iter
  }

  /// Creates an iterator that both filters and maps.
  ///
  /// The closure must return an Option<T>. filterMap() creates an iterator
  /// which calls this closure on each element. If the closure returns
  /// Some(element), then that element is returned. If the closure returns
  /// None, it will try again, and call the closure on the next element,
  /// seeing if it will return Some.
  ///
  /// Why filterMap() and not just filter().map()? The key is in this part:
  ///
  ///     If the closure returns Some(element), then that element is returned.
  ///
  /// In other words, it removes the Option<T> layer automatically.
  /// If your mapping is already returning an Option<T> and you want to skip
  /// over Nones, then filterMap() is much, much nicer to use.
  fn filterMap<U>(self, f: (E) -> Option<U>) -> Iterator<U> {
    let iter: FilterMapIterator<Self, f> = {
      iter: self
      f
    }
    iter
  }

  /// Creates an iterator which gives the current iteration count
  /// as well as the next value.
  ///
  /// The iterator returned yields pairs (i, val), where i is the
  /// current index of iteration and val is the value returned by the iterator.
  fn enumerate(self) -> Iterator<(Num, E)> {
    let mut index = -1
    self.map(|e| {
      index += 1
      (index, e)
    })
  }

  /// Tests if all elements of the iterator matches a predicate.
  ///
  /// all() takes a closure that returns true or false. It applies this
  /// closure to each element of the iterator, and if all of them return
  /// true, then so does all(). If any of them return false, it returns false.
  ///
  /// all() is short-circuting; in other words, it will stop processing
  /// as soon as it finds a false, given that no matter what else happens,
  /// the result will also be false.
  ///
  /// An empty iterator returns true.
  fn all(mut self, predicate: (E) -> Bool) -> Bool {
    while true {
      if let Some(value) = self.next() {
        if not predicate(value)
          then return false
      }
      else return true
    }
    true
  }

  /// Tests if any element of the iterator matches a predicate.
  ///
  /// any() takes a closure that returns true or false. It applies this
  /// closure to each element of the iterator, and if any of them return
  /// true, then so does any(). If they all return false, it returns false.
  ///
  /// any() is short-circuting; in other words, it will stop processing
  /// as soon as it finds a true, given that no matter what else happens,
  /// the result will also be true.
  ///
  /// An empty iterator returns false.
  fn any(mut self, predicate: (E) -> Bool) -> Bool {
    while true {
      if let Some(value) = self.next() {
        if predicate(value)
          then return true
      }
      else return false
    }
    false
  }

  /// Searches for an element of an iterator that satisfies a predicate.
  ///
  /// find() takes a closure that returns true or false. It applies this
  /// closure to each element of the iterator, and if any of them return
  /// true, then find() returns Some(element). If they all return false,
  /// it returns None.
  ///
  /// find() is short-circuting; in other words, it will stop processing
  /// as soon as the closure returns true.
  fn find(mut self, predicate: (E) -> Bool) -> Option<E> {
    while true {
      if let Some(value) = self.next() {
        if predicate(value)
          then return Some(value)
      }
      else return None
    }
    None
  }
}
export trait Iterable<E> {
  fn enumerate(self) -> Iterable<(Num, E)>

  fn size(self) -> Num
  fn isEmpty(self) -> Bool
  fn isNotEmpty(self) -> Bool
  fn first(self) -> Option<E>
  fn last(self) -> Option<E>

  fn all(self, predicate: (E) -> Bool) -> Bool
  fn any(self, predicate: (E) -> Bool) -> Bool
  fn find(self, predicate: (E) -> Bool) -> Option<E>

  fn filter(self, func: (E) -> Bool) -> Iterable<E>
  fn forEach(self, func: (E) -> ()) -> ()
  fn map<U>(self, func: (E) -> U) -> Iterable<U>
  fn filterMap<U>(self, func: (E) -> Option<U>) -> Iterable<U>

  /// Returns an Iterable that yields all but the first [count] elements.
  fn skip(self, count: Num) -> Iterable<E>

  /// Returns an Iterable that skips leading elements until [test] is satisfied.
  fn skipUntil(self, test: (E) -> Bool) -> Iterable<E>

  /// Returns an Iterable that yields its first count elements.
  /// If count is greater than the Iterable size the returned Iterable
  /// will end at its size, before count is reached.
  fn take(self, count: Num) -> Iterable<E>

  fn toList(self) -> List<E>
}

type ListIterator<E> {
  index: Num
  list: List<E>
}

impl<E> Iterator<E> for ListIterator<E> {
  fn next(mut self) -> Option<E> {
    let element = self.list.get(self.index)
    if element.isSome() {
      self.index += 1
    }
    element
  }
}

impl<E> IntoIterator<E> for List<E> {
  fn iter(self) -> ListIterator<E> {
    let iterator: ListIterator<E> = {
      index: 0
      list: self
    }
    iterator
  }
}

fn asList<E>(a) -> List<E> {a}

impl<E> Iterable<E> for List<E> {

  fn enumerate(self) -> Iterable<(Num, E)> {
    asList(self->map(|element, index| (index, element)))
  }

  fn size(self) -> Num {
    self->length.transmute()
  }

  fn isEmpty(self) -> Bool {
    self.size() == 0
  }

  fn isNotEmpty(self) -> Bool {
    self.size() > 0
  }

  fn first(self) -> Option<E> {
    if self.size() > 0
      then Some(self[0])
      else None
  }

  fn last(self) -> Option<E> {
    if self.size() > 0
      then Some(self[self.size() - 1])
      else None
  }

  fn all(self, predicate: (E) -> Bool) -> Bool {
    let mut i = 0
    while i < self.size() {
      if not predicate(self[i]) then return false
      i += 1
    }
    true
  }

  fn any(self, predicate: (E) -> Bool) -> Bool {
    let mut i = 0
    while i < self.size() {
      if predicate(self[i]) then return true
      i += 1
    }
    false
  }

  fn find(self, predicate: (E) -> Bool) -> Option<E> {
    let index: Num = self->findIndex(predicate).transmute()

    if index >= 0
      then Some(self[index])
      else None
  }

  fn forEach(self, func: (E) -> ()) -> () {
    anyCast(self).forEach(func)
  }

  fn filter(self, func: (E) -> Bool) -> Iterable<E> {
    asList(anyCast(self).filter(func))
  }

  fn map<U>(self, func: (E) -> U) -> Iterable<U> {
    asList(anyCast(self).map(func))
  }

  fn filterMap<U>(self, func: (E) -> Option<U>) -> Iterable<U> {
    let mut newList: List<U> = []
    self.forEach(|element| {
      if let Option::Some(mappedElement) = func(element) {
        newList.push(mappedElement)
      }
    })
    newList
  }

  fn skip(self, count: Num) -> Iterable<E> {
    asList(self->slice(count))
  }

  fn skipUntil(self, predicate: (E) -> Bool) -> Iterable<E> {
    let index: Num = self->findIndex(predicate).transmute()
    asList(
      if index == -1
        then []
        else self->slice(index).transmute()
    )
  }

  fn take(self, count: Num) -> Iterable<E> {
    asList(self->slice(0, count))
  }

  fn toList(self) -> List<E> {
    self
  }
}

/// A (half-open) range which is bounded at both ends: { x | start <= x < end }.
/// Use start..end (two dots) for its shorthand.
export type Range<Idx=Num> {
  /// The lower bound of the range (inclusive).
  start: Idx
  /// The upper bound of the range (exclusive).
  end: Idx
}
impl<Idx> Range<Idx> {
  fn contains(self, item: Idx) -> Bool {
    self.start <= item and item < self.end
  }
  fn isSubsetOf(self, other: Range<Idx>) -> Bool {
    self.start >= other.start and other.end >= self.end
  }
}

type NumRangeIterator {
  index: Num
  end: Num
}

impl Iterator<Num> for NumRangeIterator {
  fn next(mut self) -> Option<Num> {
    let element = self.index
    if element < self.end {
      self.index += 1
      Some(element)
    }
    else None
  }
}

impl IntoIterator<Num> for Range<Num> {
  fn iter(self) -> NumRangeIterator {
    let iterator: NumRangeIterator = {
      index: self.start
      end: self.end
    }
    iterator
  }
}

export fn print<T>(message, extra: T = ()) -> () {
  console.log.apply(console, [message]->concat(extra))
}

export fn panic(reason: String) -> Never {
  js->panic(reason).transmute()
}

export type ObjectMap<T> {}
impl<T> ObjectMap<T> {
  fn new<T>() -> ObjectMap<T> {
    Object->create(null).transmute()
  }

  fn fromIter<T>(list: Iterable<(String, T)>) -> ObjectMap<T> {
    let mut object = ObjectMap.new()
    list.forEach(|(key, item)| object.set(key, item))
    object
  }

  fn size(self) -> Num {
    self.keys()->length.transmute()
  }

  fn isEmpty(self) -> Bool {
    self.size() == 0
  }

  fn isNotEmpty(self) -> Bool {
    self.size() > 0
  }

  fn keys(self) -> List<String> {
    Object->keys(self).transmute()
  }

  fn values(self) -> List<T> {
    self.keys().map(|key| self[key]).toList()
  }

  fn toList(self) -> List<(String, T)> {
    self.keys().map(|key| (key, self[key])).toList()
  }

  fn all(self, predicate: (T) -> Bool) -> Bool {
    let mut i = 0
    let keys = self.keys()
    while i < keys.size() {
      if not predicate(self[keys[i]]) then return false
      i += 1
    }
    true
  }

  fn any(self, predicate: (T) -> Bool) -> Bool {
    let mut i = 0
    let keys = self.keys()
    while i < keys.size() {
      if predicate(self[keys[i]]) then return true
      i += 1
    }
    false
  }

  fn map<U>(self, mapper: (T) -> U) -> ObjectMap<U> {
    let mut new = ObjectMap.new()
    self.keys().forEach(|key| {
      new[key] = mapper(self[key])
    })
    new
  }

  fn find(self, predicate: ((String, T)) -> Bool) -> Option<(String, T)> {
    let key = self.keys().find(|key| predicate((key, self[key])))

    if let Some(key) = key
      then Some((key, self[key]))
      else None
  }

  fn forEach(self, func: ((String, T)) -> ()) -> () {
    let keys: List<String> = Object->keys(self).transmute()
    keys.forEach(|key| {
      func((key, self[key]))
    })
  }

  fn delete(mut self, key: String) -> () {
    js->delete(self, key)
  }

  fn has(self, key: String) -> Bool {
    Object->prototype->hasOwnProperty->call(self, key).transmute()
  }

  fn get(self, key: String) -> Option<T> {
    if self.has(key)
      then Some(self[key])
      else None
  }

  fn set(mut self, key: String, value: T) -> () {
    self[key] = value
  }
}

export enum Never {}

#[type_id = 'Unknown']
export type Unknown {}
impl Unknown {
  fn from<T>(value) -> Unknown {value}

  fn isNull(self) -> Bool {
    js->isNull(self).transmute()
  }

  fn isUndefined(self) -> Bool {
    js->isUndefined(self).transmute()
  }

  fn isBool(self) -> Bool {
    typeof(self) == 'boolean'
  }

  fn isNum(self) -> Bool {
    typeof(self) == 'number'
  }

  fn isString(self) -> Bool {
    typeof(self) == 'string'
  }

  fn isList(self) -> Bool {
    Array->isArray(self).transmute()
  }

  fn isObject(self) -> Bool {
    self != null and typeof(self) == 'object'
  }

  fn asBool(self) -> Option<Bool> {
    if self.isBool()
      then Some(self.transmute())
      else None
  }

  fn asNum(self) -> Option<Num> {
    if self.isNum()
      then Some(self.transmute())
      else None
  }

  fn asString(self) -> Option<String> {
    if self.isString()
      then Some(self.transmute())
      else None
  }

  fn asList(self) -> Option<List<Unknown>> {
    if self.isList()
      then Some(self.transmute())
      else None
  }

  fn getProp(self, property: String) -> Option<Unknown> {
    if not (self.isNull() or self.isUndefined()) {
      if Object->prototype->hasOwnProperty->call(self, property).transmute()
        then Some(self->[property])
        else None
    }
    else None
  }

  fn transmute<T>(self) -> T {
    self
  }
}

/// The Index trait is used to specify the functionality
/// of indexing operations like list[idx].
#[type_id = 'Index']
export trait Index<Idx, Out> {
  fn index(self, index: Idx) -> Out
}

impl<E> Index<Num, E> for List<E> {
  fn index(self, index: Num) -> E {
    if index < 0 then panic('index out of bounds: index must be positive but is $index')
    if index >= self.size() {
      panic('index out of bounds: the length is ' + self.size() + ' but the index is $index')
    }

    self->[index].transmute()
  }
}

impl<T> Index<String, T> for ObjectMap<T> {
  fn index(self, key: String) -> T {
    if not self.has(key) then panic('The key $key is missing')

    self->[key].transmute()
  }
}
