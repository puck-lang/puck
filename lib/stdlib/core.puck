//#![no_core]
import 'puck:js' as {Error, Object, console, null, undefined}

export type Bool {}
export type Num {}
export type String {}
export trait StringTrait {
  fn contains(self, subStr: String) {
    self.indexOf(subStr) >= 0
  }
}
impl StringTrait for String {}

export enum Result<T, E> = Ok(T) | Err(E)
export let Ok = Result.Ok
export let Err = Result.Err
export enum Maybe<T> = Just(T) | Nothing
export let Just = Maybe.Just
export let Nothing = Maybe.Nothing

export type List<E> {}
export trait ListTrait<E> {
  fn zip<A, B>(a: List<A>, b: List<B>): List<(A, B)> {
    if a.length != b.length
      then throw Error('List a and b are not of the same length')

    a.map(|a, i| (a, b[i]))
  }
}
impl<E> ListTrait<E> for List<E> {}
export trait Iterable<E> {
  fn size(self): Num {
    self.length
  }

  /// Returns an [Iterable] that provides all but the first [count] elements.
  // fn skip(self, count: Num): Iterable<E>
  fn skip(self, count: Num): List<E>

  /// Returns an [Iterable] that skips leading elements until [test] is satisfied.
  // fn skipUntil(self, test: (E) => Bool): Iterable<E>
  fn skipUntil(self, test: (E) => Bool): List<E>
}

impl<E> Iterable<E> for List<E> {
  fn skip(self, count) {
    self.slice(count)
  }

  fn skipUntil(self, test) {
    let index = self.findIndex(test)
    if index == -1
      then []
      else self.slice(index)
  }
}

/// A (half-open) range which is bounded at both ends: { x | start <= x < end }.
/// Use start..end (two dots) for its shorthand.
export type Range<Idx=Num> {
  /// The lower bound of the range (inclusive).
  start: Idx
  /// The upper bound of the range (exclusive).
  end: Idx
}
export trait RangeTrait<Idx> {
  fn contains(self, item: Idx): Bool
  fn isSubsetOf(self, other: Range<Idx>): Bool
}
impl RangeTrait<Num> for Range<Num> {
  fn contains(self, item) {
    self.start <= item and item < self.end
  }
  fn isSubsetOf(self, other) {
    self.start >= other.start and other.end >= self.end
  }
}

export fn print(message, a, b, c) {
  let mut args = [message]
  if a != undefined {
    args.push(a)
  }
  if b != undefined {
    args[2] = b
  }
  if c != undefined {
    args[3] = c
  }

  console.log.apply(console, args)
}

export type ObjectMap<T> {}
export trait ObjectMapTrait<T> {
  fn new<T>(): ObjectMap<T> {
    Object.create(null)
  }

  fn fromList<T>(list: List<(String, T)>): ObjectMap<T> {
    let mut object = Object.create(null)
    list.forEach(|item| object[item[0]] = item[1])
    object
  }

  fn map<U>(self, mapper: (T) => U): ObjectMap<U> {
    let mut new = ObjectMapTrait.new()
    Object.keys(self).forEach(|key| {
      new[key] = mapper(self[key])
    })
    new
  }

  fn size(self): Num {
    Object.keys(self).length
  }
}
impl<T> ObjectMapTrait<T> for ObjectMap<T> {}
