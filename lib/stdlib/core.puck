//#![no_core]
import 'puck:js' as {Error, Object, console, null, undefined}

export type Bool {}
export type Num {}
export type String {}
export trait StringTrait {
  fn contains(self, subStr: String): Bool {
    self.indexOf(subStr) >= 0
  }
}
impl StringTrait for String {}

export enum Result<T, E> = Ok(T) | Err(E)
export let Ok = Result::Ok
export let Err = Result::Err
export trait ResultTrait<T, E> {
  fn isOk(self): Bool then self.kind == 'Ok'
  fn isErr(self: Result<T, E>): Bool {not self.isOk()}

  /// Calls op if the result is Ok, otherwise returns the Err value of self.
  ///
  /// This function can be used for control flow based on Result values.
  fn andThen<U>(self: Result<T, E>, op: (T) => Result<U, E>): Result<U, E> {
    if let Result::Ok(value) = self
      then op(value)
      else self
  }

  /// Maps a Result<T, E> to Result<U, E> by applying a function to a contained Ok value, leaving an Err value untouched.
  ///
  /// This function can be used to compose the results of two functions.
  fn map<U>(self: Result<T, E>, op: (T) => U): Result<U, E> {
    if let Result::Ok(value) = self
      then Ok(op(value))
      else self
  }
}
impl<T, E> ResultTrait<T, E> for Result<T, E> {}

export enum Maybe<T> = Just(T) | Nothing
export let Just = Maybe::Just
export let Nothing = Maybe::Nothing
export trait MaybeTrait<T> {

  fn isJust(self): Bool then self.kind == 'Just'
  fn isNothing(self: Maybe<T>): Bool {not self.isJust()}

  fn map<U>(self: Maybe<T>, f: (T) => U): Maybe<U> {
    if let Maybe::Just(value) = self
      then Just(f(value))
      else self
  }

  fn mapOr<U>(self: Maybe<T>, default: U, f: (T) => U): U {
    if let Maybe::Just(value) = self
      then f(value)
      else default
  }

  fn mapOrElse<U>(self: Maybe<T>, default: () => U, f: (T) => U): U {
    if let Maybe::Just(value) = self
      then f(value)
      else default()
  }

  fn unwrap(self: Maybe<T>): T {
    if self.isNothing()
      then throw Error('Can not unwap empty maybe')

    self.value[0]
  }

  fn unwrapOr(self: Maybe<T>, default: T): T {
    if let Maybe::Just(value) = self
      then value
      else default
  }

  fn unwrapOrElse(self: Maybe<T>, default: () => T): T {
    if let Maybe::Just(value) = self
      then value
      else default()
  }
}
impl<T> MaybeTrait<T> for Maybe<T> {}

export type List<E> {}
export trait ListTrait<E> {
  fn zip<A, B>(a: List<A>, b: List<B>): List<(A, B)> {
    if a.length != b.length
      then throw Error('List a and b are not of the same length')

    a.map(|a, i| (a, b[i]))
  }
}
impl<E> ListTrait<E> for List<E> {}
export trait Iterable<E> {
  fn size(self): Num {
    self.length
  }

  fn find(self, predicate: (E) => Bool): Maybe<E>

  /// Returns an [Iterable] that provides all but the first [count] elements.
  // fn skip(self, count: Num): Iterable<E>
  fn skip(self, count: Num): List<E>

  /// Returns an [Iterable] that skips leading elements until [test] is satisfied.
  // fn skipUntil(self, test: (E) => Bool): Iterable<E>
  fn skipUntil(self, test: (E) => Bool): List<E>
}

impl<E> Iterable<E> for List<E> {
  fn find(self, predicate: (E) => Bool): Maybe<E> {
    let index = self.findIndex(predicate)

    if index >= 0
      then Just(self[index])
      else Nothing
  }

  fn skip(self, count): List<E> {
    self.slice(count)
  }

  fn skipUntil(self, test): List<E>  {
    let index = self.findIndex(test)
    if index == -1
      then []
      else self.slice(index)
  }
}

/// A (half-open) range which is bounded at both ends: { x | start <= x < end }.
/// Use start..end (two dots) for its shorthand.
export type Range<Idx=Num> {
  /// The lower bound of the range (inclusive).
  start: Idx
  /// The upper bound of the range (exclusive).
  end: Idx
}
export trait RangeTrait<Idx> {
  fn contains(self, item: Idx): Bool
  fn isSubsetOf(self, other: Range<Idx>): Bool
}
impl RangeTrait<Num> for Range<Num> {
  fn contains(self, item): Bool {
    self.start <= item and item < self.end
  }
  fn isSubsetOf(self, other): Bool {
    self.start >= other.start and other.end >= self.end
  }
}

export fn print(message, a, b, c) {
  let mut args = [message]
  if a != undefined {
    args.push(a)
  }
  if b != undefined {
    args[2] = b
  }
  if c != undefined {
    args[3] = c
  }

  console.log.apply(console, args)
}

export type ObjectMap<T> {}
export trait ObjectMapTrait<T> {
  fn new<T>(): ObjectMap<T> {
    Object.create(null)
  }

  fn fromList<T>(list: List<(String, T)>): ObjectMap<T> {
    let mut object = Object.create(null)
    list.forEach(|item| object[item[0]] = item[1])
    object
  }

  fn map<U>(self, mapper: (T) => U): ObjectMap<U> {
    let mut new = ObjectMapTrait.new()
    Object.keys(self).forEach(|key| {
      new[key] = mapper(self[key])
    })
    new
  }

  fn find(self, predicate: ((String, T)) => Bool): Maybe<(String, T)> {
    let key = Object.keys(self).find(|key| predicate((key, self[key])))

    if key
      then Just((key, self[key]))
      else Nothing
  }

  fn forEach(self, func: ((String, T)) => ()): () {
    Object.keys(self).forEach(|key| {
      func((key, self[key]))
    })
    (())
  }

  fn size(self): Num {
    Object.keys(self).length
  }
}
impl<T> ObjectMapTrait<T> for ObjectMap<T> {}
