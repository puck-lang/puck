//#![no_core]
import 'puck:js' as {Error, Object, console, null, undefined}

export type Bool {}
export type Num {}
export type String {}
export trait StringTrait {
  fn contains(self, subStr: String) -> Bool {
    self.indexOf(subStr) >= 0
  }
}
impl StringTrait for String {}

export enum Result<T, E> {
  Ok(T)
  Err(E)
}
export let Ok = Result::Ok
export let Err = Result::Err
export trait ResultTrait<T, E> {
  fn isOk(self) -> Bool {self.kind == 'Ok'}
  fn isErr(self: Result<T, E>) -> Bool {not self.isOk()}

  /// Calls op if the result is Ok, otherwise returns the Err value of self.
  ///
  /// This function can be used for control flow based on Result values.
  fn andThen<U>(self: Result<T, E>, op: (T) -> Result<U, E>) -> Result<U, E> {
    if let Result::Ok(value) = self
      then op(value)
      else self
  }

  /// Maps a Result<T, E> to Result<U, E> by applying a function to a contained Ok value, leaving an Err value untouched.
  ///
  /// This function can be used to compose the results of two functions.
  fn map<U>(self: Result<T, E>, op: (T) -> U) -> Result<U, E> {
    if let Result::Ok(value) = self
      then Ok(op(value))
      else self
  }
}
impl<T, E> ResultTrait<T, E> for Result<T, E> {}

export enum Option<T> {
  Some(T)
  None
}
export let Some = Option::Some
export let None = Option::None
export trait MaybeTrait<T> {

  fn isJust(self) -> Bool {self.kind == 'Some'}
  fn isNothing(self: Option<T>) -> Bool {not self.isJust()}

  fn map<U>(self: Option<T>, f: (T) -> U) -> Option<U> {
    if let Option::Some(value) = self
      then Some(f(value))
      else self
  }

  fn mapOr<U>(self: Option<T>, default: U, f: (T) -> U) -> U {
    if let Option::Some(value) = self
      then f(value)
      else default
  }

  fn mapOrElse<U>(self: Option<T>, default: () -> U, f: (T) -> U) -> U {
    if let Option::Some(value) = self
      then f(value)
      else default()
  }

  fn unwrap(self: Option<T>) -> T {
    if self.isNothing()
      then throw Error('Can not unwap empty maybe')

    self.value[0]
  }

  fn unwrapOr(self: Option<T>, default: T) -> T {
    if let Option::Some(value) = self
      then value
      else default
  }

  fn unwrapOrElse(self: Option<T>, default: () -> T) -> T {
    if let Option::Some(value) = self
      then value
      else default()
  }
}
impl<T> MaybeTrait<T> for Option<T> {}

export type List<E> {}
export trait ListTrait<E> {
  fn zip<A, B>(a: List<A>, b: List<B>) -> List<(A, B)> {
    if a.length != b.length
      then throw Error('List a and b are not of the same length')

    a.map(|a, i| (a, b[i]))
  }
}
impl<E> ListTrait<E> for List<E> {}
export trait Iterable<E> {
  fn enumerate(self) -> List<(E, Num)>

  fn size(self) -> Num

  fn find(self, predicate: (E) -> Bool) -> Option<E>

  /// Returns an [Iterable] that provides all but the first [count] elements.
  // fn skip(self, count: Num) -> Iterable<E>
  fn skip(self, count: Num) -> List<E>

  /// Returns an [Iterable] that skips leading elements until [test] is satisfied.
  // fn skipUntil(self, test: (E) -> Bool) -> Iterable<E>
  fn skipUntil(self, test: (E) -> Bool) -> List<E>
}

impl<E> Iterable<E> for List<E> {

  fn enumerate(self) -> List<(E, Num)> {
    self.map(|element, index| (element, index))
  }

  fn size(self) -> Num {
    self.length
  }

  fn find(self, predicate: (E) -> Bool) -> Option<E> {
    let index = self.findIndex(predicate)

    if index >= 0
      then Some(self[index])
      else None
  }

  fn skip(self, count) -> List<E> {
    self.slice(count)
  }

  fn skipUntil(self, test) -> List<E>  {
    let index = self.findIndex(test)
    if index == -1
      then []
      else self.slice(index)
  }
}

/// A (half-open) range which is bounded at both ends: { x | start <= x < end }.
/// Use start..end (two dots) for its shorthand.
export type Range<Idx=Num> {
  /// The lower bound of the range (inclusive).
  start: Idx
  /// The upper bound of the range (exclusive).
  end: Idx
}
export trait RangeTrait<Idx> {
  fn contains(self, item: Idx) -> Bool
  fn isSubsetOf(self, other: Range<Idx>) -> Bool
}
impl RangeTrait<Num> for Range<Num> {
  fn contains(self, item) -> Bool {
    self.start <= item and item < self.end
  }
  fn isSubsetOf(self, other) -> Bool {
    self.start >= other.start and other.end >= self.end
  }
}

export fn print(message, extra = []) {
  console.log.apply(console, [message].concat(extra))
}

export type ObjectMap<T> {}
export trait ObjectMapTrait<T> {
  fn new<T>() -> ObjectMap<T> {
    Object.create(null)
  }

  fn fromList<T>(list: List<(String, T)>) -> ObjectMap<T> {
    let mut object = Object.create(null)
    list.forEach(|item| object[item[0]] = item[1])
    object
  }

  fn map<U>(self, mapper: (T) -> U) -> ObjectMap<U> {
    let mut new = ObjectMapTrait.new()
    Object.keys(self).forEach(|key| {
      new[key] = mapper(self[key])
    })
    new
  }

  fn find(self, predicate: ((String, T)) -> Bool) -> Option<(String, T)> {
    let key = Object.keys(self).find(|key| predicate((key, self[key])))

    if key
      then Some((key, self[key]))
      else None
  }

  fn forEach(self, func: ((String, T)) -> ()) -> () {
    Object.keys(self).forEach(|key| {
      func((key, self[key]))
    });
    (())
  }

  fn size(self) -> Num {
    Object.keys(self).length
  }
}
impl<T> ObjectMapTrait<T> for ObjectMap<T> {}
