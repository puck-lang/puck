import '../entities.puck' as {Type}

export type SyntaxKind {}

export type Token {
  kind: SyntaxKind
}

export type Expression {}

export type CommentNode {
  text: String
}

export type Block {
  expressions: List<Expression>
}

export type EnumDeclaration {
  keyword: Token
  name: Identifier
  typeParameters: List<TypeParameter>
  openBrace: Token
  members: List<EnumMember>
  closeBrace: Token
}

export type EnumMember {
  name: Identifier
  //bound: Option<ObjectTypeBound | TupleTypeBound>
  bound: Option<Expression>
}

export type FunctionDeclaration {
  name: Option<Identifier>
  typeParameters: List<TypeParameter>
  parameterList: List<VariableDeclaration>
  returnType: Option<TypeBound>
  body: Option<Block>

  type_: Type
}

export type Identifier {
  name: String
}

export type ImplDeclaration {
  implKeyword: Token
  typeParameters: List<TypeParameter>

  trait_: TypeBound
  forKeyword: Token
  type_: TypeBound

  openBrace: Token
  members: List<FunctionDeclaration>
  closeBrace: Token
}

export type Module {
  fileName: String
  path: String
  exports: ObjectMap<ExportDirective>
  expressions: List<Expression>
}

export type ObjectDestructure {
  openBrace: Token
  members: List<ObjectDestructureMember>
  closeBrace: Token
}

export type ObjectDestructureMember {
  property: SimpleIdentifier
  local: SimpleIdentifier
}

export type SimpleIdentifier {
  name: String
}

export type TraitDeclaration {
  keyword: Token
  name: Identifier
  typeParameters: List<TypeParameter>
  openBrace: Token
  members: List<FunctionDeclaration>
  closeBrace: Token
}

export type TypeBound {}

export type FunctionTypeBound {
  typeParameters: List<TypeParameter>
  arguments: TupleTypeBound
  returnType: TypeBound
}

export type NamedTypeBound {
  path: TypePath
  typeParameters: List<TypeBound>
}

export type ObjectTypeBound {
  openBrace: Token
  properties: List<TypeProperty>
  closeBrace: Token
}

export type TupleTypeBound {
  openParen: Token
  properties: List<TypeBound>
  closeParen: Token
}

export type TypeDeclaration {
  keyword: Token
  name: Identifier
  typeParameters: List<TypeParameter>
  //bound: Option<ObjectTypeBound | TupleTypeBound>
  bound: Option<Expression>

  type_: Type
}

export type TypeParameter {
  name: Identifier
  defaultValue: Option<TypeBound>
}

export type TypeProperty {
  name: Identifier
  typeBound: TypeBound
}

export type VariableDeclaration {
  pattern: Pattern
  mutable: Bool
  typeBound: Option<TypeBound>
  initializer: Option<Expression>
}

export type ExportDirective {
  keyword: Token
  // expression: FunctionDeclaration|TraitDeclaration|TypeDeclaration|VariableDeclaration
  identifier: Identifier
}

export type ImportDirective {
  importKeyword: Token
  domain: Option<String>
  path: String
  asKeyword: Token
  // specifier: Identifier|ObjectDestructure
}

export type AssignmentExpression {
  // lhs: Identifier|MemberAccess|IndexAccess
  token: Token
  rhs: Expression
}

export type BinaryExpression {
  lhs: Expression
  operator: Token
  rhs: Expression
}

export type CallExpression {
  func: Expression
  openParen: Token
  argumentList: List<Expression>
  closeParen: Token
}

export type ForExpression {
  body: Expression
}

export type IfExpression {
  ifKeyword: Token
  condition: Expression
  then_: Block
  else_: Option<Block>
}

export type IfLetExpression {
  ifKeyword: Token
  letKeyword: Token
  variableDeclaration: VariableDeclaration
  then_: Block
  else_: Option<Block>
}

export type MatchExpression {
  matchKeyword: Token
  expression: Expression
  openBrace: Token
  patterns: List<MatchArm>
  closeBrace: Token
}

export type MatchArm {
  pattern: Pattern
  arrow: Token
  block: Block
}

export type TypePathExpression {
  typePath: TypePath
}

export type UnaryExpression {
  operator: Token
  rhs: Expression
}

export type WhileExpression {
  condition: Expression,
  body: Block,
}

export type IndexAccess {
  object: Expression
  index: Expression
}

export type MemberAccess {
  object: Expression
  member: Identifier
}

export enum TypePath {
  Object(Identifier, TypePath)
  Member(Identifier)
}

export type RecordPattern {
  openBrace: Token
  properties: List<RecordPatternMember>
  closeBrace: Token
}

export type RecordPatternMember {
  property: SimpleIdentifier
  pattern: Pattern
}

export type TuplePattern {
  openParen: Token
  properties: List<Pattern>
  closeParen: Token
}

export enum Pattern {
  CatchAll
  Identifier(Identifier)
  // Boolen(BooleanLiteral)
  // Number(NumberLiteral)
  // String(StringLiteralPart)
  Record(RecordPattern)
  Tuple(TuplePattern)
  RecordType(TypePath, RecordPattern)
  TupleType(TypePath, TuplePattern)
  UnitType(TypePath)
}

export type BreakStatement {
  keyword: Token
}

export type ReturnStatement {
  keyword: Token
  expression: Expression
}

export type ListLiteral {
  members: List<Expression>
}

export type BooleanLiteral {
  value: Bool
}

export type NumberLiteral {
  value: Num
}

export type ObjectLiteral {
  openBrace: Token
  members: List<ObjectLiteralMember>
  closeBrace: Token
}

export type ObjectLiteralMember {
  name: SimpleIdentifier
  value: Expression
}

export type StringLiteralPart {
  value: String
}

export type StringLiteral {
  // parts: List<StringLiteralPart|Identifier>
}

export type TupleLiteral {
  openParen: Token
  expressions: List<Expression>
  closeParen: Token
}
