export type SyntaxKind {}

export type Token {
  kind: SyntaxKind
}

export type Expression {}

export type CommentNode {
  text: String
}

export type Block {
  expressions: List<Expression>
}

export type EnumDeclaration {
  keyword: Token
  name: Identifier
  typeParameters: List<TypeParameter>
  members: List<EnumMember>
}

export type EnumMember {
  name: Identifier
  //bound: Maybe<ObjectTypeBound | TupleTypeBound>
  bound: Maybe<Expression>
}

export type FunctionDeclaration {
  name: Maybe<Identifier>
  typeParameters: List<TypeParameter>
  parameterList: List<VariableDeclaration>
  returnType: Maybe<TypeBound>
  body: Block
}

export type Identifier {
  name: String
}

export type ImplDeclaration {
  implKeyword: Token
  typeParameters: List<TypeParameter>

  tra: TypeBound
  forKeyword: Token
  ty: TypeBound

  openBrace: Token
  members: List<FunctionDeclaration>
  closeBrace: Token
}

export type Module {
  fileName: String
  path: String
  exports: ObjectMap<ExportDirective>
  expressions: List<Expression>
}

export type ObjectDestructure {
  openBrace: Token
  members: List<ObjectDestructureMember>
  closeBrace: Token
}

export type ObjectDestructureMember {
  property: SimpleIdentifier
  local: SimpleIdentifier
}

export type SimpleIdentifier {
  name: String
}

export type TraitDeclaration {
  keyword: Token
  name: Identifier
  typeParameters: List<TypeParameter>
  openBrace: Token
  members: List<FunctionDeclaration>
  closeBrace: Token
}

export type TypeBound {}

export type FunctionTypeBound {
  typeParameters: List<TypeParameter>
  arguments: TupleTypeBound
  returnType: TypeBound
}

export type NamedTypeBound {
  name: SimpleIdentifier
  typeParameters: List<TypeBound>
}

export type ObjectTypeBound {
  openBrace: Token
  properties: List<TypeProperty>
  closeBrace: Token
}

export type TupleTypeBound {
  openParen: Token
  properties: List<TypeBound>
  closeParen: Token
}

export type TypeDeclaration {
  keyword: Token
  name: Identifier
  typeParameters: List<TypeParameter>
  //bound: Maybe<ObjectTypeBound | TupleTypeBound>
  bound: Maybe<Expression>
}

export type TypeParameter {
  name: Identifier
  defaultValue: Maybe<TypeBound>
}

export type TypeProperty {
  name: Identifier
  typeBound: TypeBound
}

export type VariableDeclaration {
  pattern: Pattern
  mutable: Bool
  typeBound: Maybe<TypeBound>
  initializer: Maybe<Expression>
}

export type ExportDirective {
  keyword: Token
  // expression: FunctionDeclaration|TraitDeclaration|TypeDeclaration|VariableDeclaration
  identifier: Identifier
}

export type ImportDirective {
  importKeyword: Token
  domain: Maybe<String>
  path: String
  asKeyword: Token
  // specifier: Identifier|ObjectDestructure
}

export type AssignmentExpression {
  // lhs: Identifier|MemberAccess|IndexAccess
  token: Token
  rhs: Expression
}

export type BinaryExpression {
  lhs: Expression
  operator: Token
  rhs: Expression
}

export type CallExpression {
  func: Expression
  openParen: Token
  argumentList: List<Expression>
  closeParen: Token
}

export type ForExpression {
  body: Expression
}

export type IfExpression {
  condition: Expression
  _then: Block
  _else: Maybe<Block>
}

export type LoopExpression {
  body: Block
}

export type UnaryExpression {
  operator: Token
  rhs: Expression
}

export type WhileExpression {
  condition: Expression,
  body: Block,
}

export type IndexAccess {
  object: Expression
  index: Expression
}

export type MemberAccess {
  object: Expression
  member: Identifier
}

export type TypePath {
  object: Expression
  member: Identifier
}

export type RecordPattern {
  openBrace: Token
  properties: List<RecordPatternMember>
  closeBrace: Token
}

export type RecordPatternMember {
  property: SimpleIdentifier
  pattern: Pattern
}

export type TuplePattern {
  openParen: Token
  properties: List<Pattern>
  closeParen: Token
}

export enum Pattern
  = CatchAll
  | Identifier(Identifier)
  // | Boolen(BooleanLiteral)
  // | Number(NumberLiteral)
  // | String(StringLiteralPart)
  | Record(RecordPattern)
  | Tuple(TuplePattern)
  | RecordType(SimpleIdentifier, RecordPattern)
  | TupleType(SimpleIdentifier, TuplePattern)

export type BreakStatement {
  keyword: Token
}

export type ReturnStatement {
  keyword: Token
  expression: Expression
}

export type ListLiteral {
  members: List<Expression>
}

export type BooleanLiteral {
  value: Bool
}

export type NumberLiteral {
  value: Num
}

export type ObjectLiteral {
  openBrace: Token
  members: List<ObjectLiteralMember>
  closeBrace: Token
}

export type ObjectLiteralMember {
  name: SimpleIdentifier
  value: Expression
}

export type StringLiteralPart {
  value: String
}

export type StringLiteral {
  // parts: List<StringLiteralPart|Identifier>
}

export type TupleLiteral {
  openParen: Token
  expressions: List<Expression>
  closeParen: Token
}
