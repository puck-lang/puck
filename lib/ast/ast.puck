import '../entities.puck' as {Type}

export type SyntaxKind {}

export type Token {
  kind: SyntaxKind
}

export type Module {
  fileName: String
  path: String
  exports: ObjectMap<ExportDirective>
  statements: List<TopLevelStatement>
}

export enum TopLevelStatement {
  ExportDirective(ExportDirective)
  ImportDirective(ImportDirective)

  EnumDeclaration(EnumDeclaration)
  ImplDeclaration(ImplDeclaration)
  ImplShorthandDeclaration(ImplShorthandDeclaration)
  TraitDeclaration(TraitDeclaration)
  TypeDeclaration(TypeDeclaration)

  BlockLevelStatement(BlockLevelStatement)
}

export enum BlockLevelStatement {
  Block(Block)
  BreakStatement(BreakStatement)
  ReturnStatement(ReturnStatement)
  WhileLoop(WhileLoop)

  Expression(Expression)
}

export enum Expression {
  ThrowStatement({expression: Expression})
  Comment(Comment)
  Identifier(Identifier)

  FunctionDeclaration(FunctionDeclaration)
  VariableDeclaration(VariableDeclaration)

  AssignmentExpression(AssignmentExpression)
  BinaryExpression(BinaryExpression)
  CallExpression(CallExpression)
  IfExpression(IfExpression)
  IfLetExpression(IfLetExpression)
  MatchExpression(MatchExpression)
  TypePathExpression(TypePathExpression)
  UnaryExpression(UnaryExpression)

  IndexAccess(IndexAccess)
  MemberAccess(MemberAccess)

  BooleanLiteral(BooleanLiteral)
  ListLiteral(ListLiteral)
  NumberLiteral(NumberLiteral)
  RecordLiteral(RecordLiteral)
  StringLiteral(StringLiteral)
  TupleLiteral(TupleLiteral)
}

impl TopLevelStatement {
  fn getType(self) -> Type {
    match self {
      TopLevelStatement::ExportDirective(e) => throw 'type on export'
      TopLevelStatement::ImportDirective(e) => throw 'type on import'

      TopLevelStatement::EnumDeclaration(e) => e.type_
      TopLevelStatement::ImplDeclaration(e) => e.type_
      TopLevelStatement::ImplShorthandDeclaration(e) => e.type_
      TopLevelStatement::TraitDeclaration(e) => e.type_
      TopLevelStatement::TypeDeclaration(e) => e.type_

      TopLevelStatement::BlockLevelStatement(e) => e.getType()
    }
  }
}

impl BlockLevelStatement {
  fn getType(self) -> Type {
    match self {
      BlockLevelStatement::Block(e) => e.type_
      BlockLevelStatement::BreakStatement(e) => e.type_
      BlockLevelStatement::ReturnStatement(e) => e.type_
      BlockLevelStatement::WhileLoop(e) => e.type_

      BlockLevelStatement::Expression(e) =>  e.getType()
    }
  }
}

impl Expression {
  fn getType(self) -> Type {
    match self {
      Expression::ThrowStatement(e) => e.type_
      Expression::Comment(_) => {}

      Expression::Identifier(e) => e.type_
      Expression::FunctionDeclaration(e) => e.type_
      Expression::VariableDeclaration(e) => e.type_

      Expression::AssignmentExpression(e) => e.type_
      Expression::BinaryExpression(e) => e.type_
      Expression::CallExpression(e) => e.type_
      Expression::IfExpression(e) => e.type_
      Expression::IfLetExpression(e) => e.type_
      Expression::MatchExpression(e) => e.type_
      Expression::TypePathExpression(e) => e.type_
      Expression::UnaryExpression(e) => e.type_

      Expression::IndexAccess(e) => e.type_
      Expression::MemberAccess(e) => e.type_

      Expression::BooleanLiteral(e) => e.type_
      Expression::ListLiteral(e) => e.type_
      Expression::NumberLiteral(e) => e.type_
      Expression::RecordLiteral(e) => e.type_
      Expression::StringLiteral(e) => e.type_
      Expression::TupleLiteral(e) => e.type_
    }
  }
}

export type EnumDeclaration {
  keyword: Token
  name: Identifier
  typeParameters: List<TypeParameter>
  openBrace: Token
  members: List<EnumMember>
  closeBrace: Token
}

export type EnumMember {
  name: Identifier
  bound: Option<TypeBound>
}

export type ImplDeclaration {
  implKeyword: Token
  typeParameters: List<TypeParameter>

  trait_: TypeBound
  forKeyword: Token
  type_: TypeBound

  openBrace: Token
  members: List<FunctionDeclaration>
  closeBrace: Token
}

export type ImplShorthandDeclaration {
  implKeyword: Token
  typeParameters: List<TypeParameter>

  type_: TypeBound

  openBrace: Token
  members: List<FunctionDeclaration>
  closeBrace: Token
}

export type TraitDeclaration {
  keyword: Token
  name: Identifier
  typeParameters: List<TypeParameter>
  openBrace: Token
  members: List<FunctionDeclaration>
  closeBrace: Token
}

export type TypeDeclaration {
  keyword: Token
  name: Identifier
  typeParameters: List<TypeParameter>
  bound: Option<TypeBound>

  type_: Type
}

export type ExportDirective {
  keyword: Token
  statement: ExportedStatement
  identifier: Identifier
}

export enum ExportedStatement {
  EnumDeclaration(EnumDeclaration)
  TraitDeclaration(TraitDeclaration)
  TypeDeclaration(TypeDeclaration)
  FunctionDeclaration(FunctionDeclaration)
  VariableDeclaration(VariableDeclaration)
}

export type ImportDirective {
  importKeyword: Token
  domain: Option<String>
  path: String
  asKeyword: Token
  specifier: ImportSpecifier
}
export enum ImportSpecifier {
  Asterisk(Token)
  Identifier(Identifier)
  ObjectDestructure(ObjectDestructure)
}

export type ObjectDestructure {
  openBrace: Token
  members: List<ObjectDestructureMember>
  closeBrace: Token
}

export type ObjectDestructureMember {
  property: Identifier
  local: Identifier
}

export type Block {
  statements: List<BlockLevelStatement>
  type_: Type
}

export type BreakStatement {
  keyword: Token
}

export type ReturnStatement {
  keyword: Token
  expression: Expression
}

export type WhileLoop {
  condition: Expression,
  body: Block,
}

export type Comment {
  text: String
}

export type Identifier {
  name: String
}

export type FunctionDeclaration {
  name: Option<Identifier>
  typeParameters: List<TypeParameter>
  parameterList: List<VariableDeclaration>
  returnType: Option<TypeBound>
  body: Option<Block>

  type_: Type
}

export type VariableDeclaration {
  pattern: Pattern
  mutable: Bool
  typeBound: Option<TypeBound>
  initializer: Option<Expression>
}

export type AssignmentExpression {
  lhs: Expression
  token: Token
  rhs: Expression
}

export type BinaryExpression {
  lhs: Expression
  operator: Token
  rhs: Expression
}

export type CallExpression {
  func: Expression
  openParen: Token
  argumentList: List<Expression>
  closeParen: Token
}

export type IfExpression {
  ifKeyword: Token
  condition: Expression
  then_: Block
  else_: Option<Block>
}

export type IfLetExpression {
  ifKeyword: Token
  letKeyword: Token
  pattern: Pattern
  expression: Expression
  then_: Block
  else_: Option<Block>
}

export type MatchExpression {
  matchKeyword: Token
  expression: Expression
  openBrace: Token
  patterns: List<MatchArm>
  closeBrace: Token
}

export type MatchArm {
  pattern: Pattern
  arrow: Token
  block: Block
}

export type TypePathExpression {
  typePath: TypePath
}

export enum TypePath {
  Object(Identifier, TypePath)
  Member(Identifier)
}

export type UnaryExpression {
  operator: Token
  rhs: Expression
}

export type IndexAccess {
  object: Expression
  index: Expression
}

export type MemberAccess {
  object: Expression
  member: Identifier
}

export type BooleanLiteral {
  value: Bool
}

export type ListLiteral {
  members: List<Expression>
}

export type NumberLiteral {
  value: Num
}

export type RecordLiteral {
  openBrace: Token
  members: List<RecordLiteralMember>
  closeBrace: Token
}

export type RecordLiteralMember {
  name: Identifier
  value: Expression
}

export type StringLiteral {
  // parts: List<StringLiteralPart|Identifier>
}

export type StringLiteralPart {
  value: String
}

export type TupleLiteral {
  openParen: Token
  expressions: List<Expression>
  closeParen: Token
}

export enum Pattern {
  CatchAll
  Identifier(Identifier)
  // Boolen(BooleanLiteral)
  // Number(NumberLiteral)
  // String(StringLiteralPart)
  Record(RecordPattern)
  Tuple(TuplePattern)
  RecordType(TypePath, RecordPattern)
  TupleType(TypePath, TuplePattern)
  UnitType(TypePath)
}

export type RecordPattern {
  openBrace: Token
  properties: List<RecordPatternMember>
  closeBrace: Token
}

export type RecordPatternMember {
  property: Identifier
  pattern: Pattern
}

export type TuplePattern {
  openParen: Token
  properties: List<Pattern>
  closeParen: Token
}

export enum TypeBound {
  FunctionTypeBound(FunctionTypeBound)
  NamedTypeBound(NamedTypeBound)
  RecordTypeBound(RecordTypeBound)
  TupleTypeBound(TupleTypeBound)
}

impl TypeBound {
  fn getType(self) -> Type {
    match self {
      TypeBound::FunctionTypeBound(t) => t.type_
      TypeBound::NamedTypeBound(t) => t.type_
      TypeBound::RecordTypeBound(t) => t.type_
      TypeBound::TupleTypeBound(t) => t.type_
    }
  }

  fn getRecordTypeBound(self) -> RecordTypeBound {
    match self {
      TypeBound::RecordTypeBound(record) => record
      _ => throw 'TypeBound is not a RecordTypeBound'
    }
  }

  fn getTupleTypeBound(self) -> TupleTypeBound {
    match self {
      TypeBound::TupleTypeBound(tuple) => tuple
      _ => throw 'TypeBound is not a TupleTypeBound'
    }
  }
}

export type FunctionTypeBound {
  typeParameters: List<TypeParameter>
  parameters: TupleTypeBound
  returnType: TypeBound
}

export type NamedTypeBound {
  path: TypePath
  typeParameters: List<TypeBound>
}

export type RecordTypeBound {
  openBrace: Token
  properties: List<RecordTypeBoundMember>
  closeBrace: Token
}

export type RecordTypeBoundMember {
  name: Identifier
  typeBound: TypeBound
}

export type TupleTypeBound {
  openParen: Token
  properties: List<TypeBound>
  closeParen: Token
}

export type TypeParameter {
  name: Identifier
  defaultValue: Option<TypeBound>
}
