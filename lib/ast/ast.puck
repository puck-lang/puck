import '../entities.puck' as {File, Type}
import 'span.puck' as {Span, ToSpan}

export type SyntaxKind {}

export type Token {
  kind: SyntaxKind
  span: Span
}

export type Module {
  fileName: String
  path: String
  exports: ObjectMap<ExportDirective>
  statements: List<TopLevelStatement>
  file: File
}

export enum TopLevelStatement {
  ExportDirective(ExportDirective)
  ImportDirective(ImportDirective)

  EnumDeclaration(EnumDeclaration)
  ImplDeclaration(ImplDeclaration)
  ImplShorthandDeclaration(ImplShorthandDeclaration)
  TraitDeclaration(TraitDeclaration)
  TypeDeclaration(TypeDeclaration)

  BlockLevelStatement(BlockLevelStatement)
}

export enum BlockLevelStatement {
  Block(Block)
  BreakStatement(BreakStatement)
  ReturnStatement(ReturnStatement)
  WhileLoop(WhileLoop)

  Expression(Expression)
}

export enum Expression {
  ThrowStatement({expression: Expression})
  Comment(Comment)
  Identifier(Identifier)

  FunctionDeclaration(FunctionDeclaration)
  VariableDeclaration(VariableDeclaration)

  AssignmentExpression(AssignmentExpression)
  BinaryExpression(BinaryExpression)
  CallExpression(CallExpression)
  IfExpression(IfExpression)
  IfLetExpression(IfLetExpression)
  MatchExpression(MatchExpression)
  TypePathExpression(TypePathExpression)
  UnaryExpression(UnaryExpression)

  IndexAccess(IndexAccess)
  MemberAccess(MemberAccess)

  BooleanLiteral(BooleanLiteral)
  ListLiteral(ListLiteral)
  NumberLiteral(NumberLiteral)
  RecordLiteral(RecordLiteral)
  StringLiteral(StringLiteral)
  TupleLiteral(TupleLiteral)
}

export enum SimpleLiteral {
  BooleanLiteral(BooleanLiteral)
  NumberLiteral(NumberLiteral)
  StringLiteral(SimpleStringLiteral)
}

impl TopLevelStatement {
  fn getType(self) -> Type {
    match self {
      TopLevelStatement::ExportDirective(e) => throw 'type on export'
      TopLevelStatement::ImportDirective(e) => throw 'type on import'

      TopLevelStatement::EnumDeclaration(e) => e.type_
      TopLevelStatement::ImplDeclaration(e) => e.type_
      TopLevelStatement::ImplShorthandDeclaration(e) => e.type_
      TopLevelStatement::TraitDeclaration(e) => e.type_
      TopLevelStatement::TypeDeclaration(e) => e.type_

      TopLevelStatement::BlockLevelStatement(e) => e.getType()
    }
  }
}

impl ToSpan for TopLevelStatement {
  fn span(self) -> Span {
    match self {
      TopLevelStatement::ExportDirective(e) => e.span()
      TopLevelStatement::ImportDirective(e) => e.span()

      TopLevelStatement::EnumDeclaration(e) => e.span()
      TopLevelStatement::ImplDeclaration(e) => e.span()
      TopLevelStatement::ImplShorthandDeclaration(e) => e.span()
      TopLevelStatement::TraitDeclaration(e) => e.span()
      TopLevelStatement::TypeDeclaration(e) => e.span()

      TopLevelStatement::BlockLevelStatement(e) => e.span()
    }
  }
}

impl BlockLevelStatement {
  fn getType(self) -> Type {
    match self {
      BlockLevelStatement::Block(e) => e.type_
      BlockLevelStatement::BreakStatement(e) => e.type_
      BlockLevelStatement::ReturnStatement(e) => e.type_
      BlockLevelStatement::WhileLoop(e) => e.type_

      BlockLevelStatement::Expression(e) =>  e.getType()
    }
  }
}

impl ToSpan for BlockLevelStatement {
  fn span(self) -> Span {
    match self {
      BlockLevelStatement::Block(e) => e.span()
      BlockLevelStatement::BreakStatement(e) => e.span()
      BlockLevelStatement::ReturnStatement(e) => e.span()
      BlockLevelStatement::WhileLoop(e) => e.span()
      BlockLevelStatement::Expression(e) =>  e.span()
    }
  }
}

impl Expression {
  fn getType(self) -> Type {
    match self {
      Expression::ThrowStatement(e) => e.type_
      Expression::Comment(_) => {}

      Expression::Identifier(e) => e.type_
      Expression::FunctionDeclaration(e) => e.type_
      Expression::VariableDeclaration(e) => e.type_

      Expression::AssignmentExpression(e) => e.type_
      Expression::BinaryExpression(e) => e.type_
      Expression::CallExpression(e) => e.type_
      Expression::IfExpression(e) => e.type_
      Expression::IfLetExpression(e) => e.type_
      Expression::MatchExpression(e) => e.type_
      Expression::TypePathExpression(e) => e.type_
      Expression::UnaryExpression(e) => e.type_

      Expression::IndexAccess(e) => e.type_
      Expression::MemberAccess(e) => e.type_

      Expression::BooleanLiteral(e) => e.type_
      Expression::ListLiteral(e) => e.type_
      Expression::NumberLiteral(e) => e.type_
      Expression::RecordLiteral(e) => e.type_
      Expression::StringLiteral(e) => e.type_
      Expression::TupleLiteral(e) => e.type_
    }
  }
}

impl ToSpan for Expression {
  fn span(self) -> Span {
    match self {
      Expression::ThrowStatement(e) => e.expression.span()
      Expression::Comment(_) => throw 'No span for Comment'

      Expression::Identifier(e) => e.span()
      Expression::FunctionDeclaration(e) => e.span()
      Expression::VariableDeclaration(e) => e.span()

      Expression::AssignmentExpression(e) => e.span()
      Expression::BinaryExpression(e) => e.span()
      Expression::CallExpression(e) => e.span()
      Expression::IfExpression(e) => e.span()
      Expression::IfLetExpression(e) => e.span()
      Expression::MatchExpression(e) => e.span()
      Expression::TypePathExpression(e) => e.span()
      Expression::UnaryExpression(e) => e.span()

      Expression::IndexAccess(e) => e.span()
      Expression::MemberAccess(e) => e.span()

      Expression::BooleanLiteral(e) => e.span()
      Expression::ListLiteral(e) => e.span()
      Expression::NumberLiteral(e) => e.span
      Expression::RecordLiteral(e) => e.span()
      Expression::StringLiteral(e) => e.span()
      Expression::TupleLiteral(e) => e.span()
    }
  }
}

export type EnumDeclaration {
  attributes: List<Attribute>
  keyword: Token
  name: Identifier
  typeParameters: List<TypeParameter>
  openBrace: Token
  members: List<EnumMember>
  closeBrace: Token
}

impl ToSpan for EnumDeclaration {
  fn span(self) -> Span {{
    start: self.keyword.span.start
    end: self.closeBrace.span.end
  }}
}

export type EnumMember {
  name: Identifier
  bound: Option<TypeBound>
}

impl ToSpan for EnumMember {
  fn span(self) -> Span {{
    start: self.name.span.start
    end: self.bound.mapOr(self.name.span, |b| b.span()).end
  }}
}

export type ImplDeclaration {
  implKeyword: Token
  typeParameters: List<TypeParameter>

  trait_: TypeBound
  forKeyword: Token
  type_: TypeBound

  openBrace: Token
  members: List<FunctionDeclaration>
  closeBrace: Token
}

impl ToSpan for ImplDeclaration {
  fn span(self) -> Span {{
    start: self.implKeyword.span.start
    end: self.closeBrace.span.end
  }}
}

export type ImplShorthandDeclaration {
  implKeyword: Token
  typeParameters: List<TypeParameter>

  type_: TypeBound

  openBrace: Token
  members: List<FunctionDeclaration>
  closeBrace: Token
}

impl ToSpan for ImplShorthandDeclaration {
  fn span(self) -> Span {{
    start: self.implKeyword.span.start
    end: self.closeBrace.span.end
  }}
}

export type TraitDeclaration {
  attributes: List<Attribute>
  keyword: Token
  name: Identifier
  typeParameters: List<TypeParameter>
  openBrace: Token
  members: List<FunctionDeclaration>
  closeBrace: Token
}

impl ToSpan for TraitDeclaration {
  fn span(self) -> Span {{
    start: self.keyword.span.start
    end: self.closeBrace.span.end
  }}
}

export type TypeDeclaration {
  attributes: List<Attribute>
  keyword: Token
  name: Identifier
  typeParameters: List<TypeParameter>
  bound: Option<TypeBound>

  type_: Type
}

impl ToSpan for TypeDeclaration {
  fn span(self) -> Span {{
    start: self.keyword.span.start
    end: self.bound.unwrap().span().end
  }}
}

export type ExportDirective {
  keyword: Token
  statement: ExportedStatement
  identifier: Identifier
}

impl ExportDirective {
  fn getType(self) -> Type {
    match self.statement {
      ExportedStatement::EnumDeclaration(d) => d.type_
      ExportedStatement::TraitDeclaration(d) => d.type_
      ExportedStatement::TypeDeclaration(d) => d.type_
      ExportedStatement::FunctionDeclaration(d) => d.type_
      ExportedStatement::VariableDeclaration(d) => d.type_
    }
  }
}

impl ToSpan for ExportDirective {
  fn span(self) -> Span {{
    start: self.keyword.span.start
    end: self.statement.span().end
  }}
}

export enum ExportedStatement {
  EnumDeclaration(EnumDeclaration)
  TraitDeclaration(TraitDeclaration)
  TypeDeclaration(TypeDeclaration)
  FunctionDeclaration(FunctionDeclaration)
  VariableDeclaration(VariableDeclaration)
}

impl ToSpan for ExportedStatement {
  fn span(self) -> Span {
    match self {
      ExportedStatement::EnumDeclaration(d) => d.span()
      ExportedStatement::TraitDeclaration(d) => d.span()
      ExportedStatement::TypeDeclaration(d) => d.span()
      ExportedStatement::FunctionDeclaration(d) => d.span()
      ExportedStatement::VariableDeclaration(d) => d.span()
    }
  }
}

export type ImportDirective {
  importKeyword: Token
  domain: Option<String>
  path: String
  asKeyword: Token
  specifier: ImportSpecifier
  module: Option<Module>
}

impl ToSpan for ImportDirective {
  fn span(self) -> Span {{
    start: self.importKeyword.span.start
    end: self.specifier.span().end
  }}
}

export enum ImportSpecifier {
  Asterisk(Token)
  Identifier(Identifier)
  ObjectDestructure(ObjectDestructure)
}

impl ToSpan for ImportSpecifier {
  fn span(self) -> Span {
    match self {
      ImportSpecifier::Asterisk(token) => token.span
      ImportSpecifier::Identifier(identifier) => identifier.span
      ImportSpecifier::ObjectDestructure(objectDestructure) => objectDestructure.span()
    }
  }
}

export type ObjectDestructure {
  openBrace: Token
  members: List<ObjectDestructureMember>
  closeBrace: Token
}

impl ToSpan for ObjectDestructure {
  fn span(self) -> Span {{
    start: self.openBrace.span.start
    end: self.closeBrace.span.end
  }}
}

export type ObjectDestructureMember {
  property: Identifier
  local: Identifier
}

impl ToSpan for ObjectDestructureMember {
  fn span(self) -> Span {{
    start: self.property.span.start
    end: self.local.span.end
  }}
}

export type Block {
  openBrace: Option<Token>
  statements: List<BlockLevelStatement>
  closeBrace: Option<Token>
  type_: Type
}

impl ToSpan for Block {
  fn span(self) -> Span {{
    start: self.openBrace.mapOrElse(|| self.statements.first().unwrap().span(), |t| t.span).start
    end: self.closeBrace.mapOrElse(|| self.statements.last().unwrap().span(), |t| t.span).end
  }}
}

export type BreakStatement {
  keyword: Token
}

export type ReturnStatement {
  keyword: Token
  expression: Expression
}

export type WhileLoop {
  condition: Expression,
  body: Block,
}

export type Comment {
  text: String
}

export type Attribute {
  hash: Token
  openBracket: Token
  name: Identifier
  data: AttributeData
  closeBracket: Token
}

impl ToSpan for Attribute {
  fn span(self) -> Span {{
    start: self.hash.span.start
    end: self.closeBracket.span.end
  }}
}

export enum AttributeData {
  None
  Value(SimpleLiteral)
  Arguments(List<AttributeArgument>)
}

export type AttributeArgument {
  name: Identifier
  value: Option<SimpleLiteral>
}

export type Identifier {
  name: String
  span: Span
}

impl ToSpan for Identifier {
  fn span(self) -> Span {self.span}
}

export type FunctionDeclaration {
  name: Option<Identifier>
  typeParameters: List<TypeParameter>
  openParenOrBar: Token
  parameterList: List<VariableDeclaration>
  closeParenOrBar: Token
  returnType: Option<TypeBound>
  body: Option<Block>

  type_: Type
}

impl ToSpan for FunctionDeclaration {
  fn span(self) -> Span {{
    start: self.name.mapOrElse(
      || {
        self.typeParameters.first().mapOrElse(
          || self.openParenOrBar.span
          |p| p.span()
        )
      }
      |i| i.span
    ).start
    end: self.body.mapOrElse(|| self.returnType.span(), |b| b.span()).end
  }}
}

export type VariableDeclaration {
  pattern: Pattern
  mutable: Bool
  typeBound: Option<TypeBound>
  initializer: Option<Expression>
}

impl ToSpan for VariableDeclaration {
  fn span(self) -> Span {{
    start: self.pattern.span().start
    end: self.initializer.mapOrElse(|| self.typeBound.mapOrElse(|| self.pattern.span(), |t| t.span()), |i| i.span()).end
  }}
}

export type AssignmentExpression {
  lhs: Expression
  token: Token
  rhs: Expression
}

impl ToSpan for AssignmentExpression {
  fn span(self) -> Span {{
    start: self.lhs.span().start
    end: self.rhs.span().end
  }}
}

export type BinaryExpression {
  lhs: Expression
  operator: Token
  rhs: Expression
}

export type CallExpression {
  func: Expression
  openParen: Token
  argumentList: List<Expression>
  closeParen: Token
}

impl ToSpan for CallExpression {
  fn span(self) -> Span {{
    start: self.func.span().start
    end: self.closeParen.span.end
  }}
}

export type IfExpression {
  ifKeyword: Token
  condition: Expression
  then_: Block
  else_: Option<Block>
}

impl ToSpan for IfExpression {
  fn span(self) -> Span {{
    start: self.ifKeyword.span.start
    end: self.else_.unwrapOr(self.then_).span().end
  }}
}

export type IfLetExpression {
  ifKeyword: Token
  letKeyword: Token
  pattern: Pattern
  expression: Expression
  then_: Block
  else_: Option<Block>
}

impl ToSpan for IfLetExpression {
  fn span(self) -> Span {{
    start: self.ifKeyword.span.start
    end: self.else_.unwrapOr(self.then_).span().end
  }}
}

export type MatchExpression {
  matchKeyword: Token
  expression: Expression
  openBrace: Token
  patterns: List<MatchArm>
  closeBrace: Token
}

impl ToSpan for MatchExpression {
  fn span(self) -> Span {{
    start: self.matchKeyword.span.start
    end: self.closeBrace.span.end
  }}
}

export type MatchArm {
  pattern: Pattern
  arrow: Token
  block: Block
}

impl ToSpan for MatchArm {
  fn span(self) -> Span {{
    start: self.pattern.span().start
    end: self.block.span().end
  }}
}

export type TypePathExpression {
  typePath: TypePath
}

impl ToSpan for TypePathExpression {
  fn span(self) -> Span {{
    start: self.typePath.span().start
    end: self.typePath.span().end
  }}
}

export enum TypePath {
  Object(Identifier, TypePath)
  Member(Identifier)
}

impl ToSpan for TypePath {
  fn span(self) -> Span {
    match self {
      TypePath::Object(identifier, typePath) => {{
        start: identifier.span.start
        end: typePath.span().end
      }}
      TypePath::Member(identifier) => identifier.span
    }
  }
}

export type UnaryExpression {
  operator: Token
  rhs: Expression
}

impl ToSpan for UnaryExpression {
  fn span(self) -> Span {{
    start: self.operator.span.start
    end: self.rhs.span().end
  }}
}

export type IndexAccess {
  object: Expression
  openBracket: Token
  index: Expression
  closeBracket: Token
}

impl ToSpan for IndexAccess {
  fn span(self) -> Span {{
    start: self.object.span().start
    end: self.closeBracket.span.end
  }}
}

export type MemberAccess {
  object: Expression
  member: Identifier
}

impl ToSpan for MemberAccess {
  fn span(self) -> Span {{
    start: self.object.span().start
    end: self.member.span().end
  }}
}

export type BooleanLiteral {
  keyword: Token
  value: Bool
}

impl ToSpan for BooleanLiteral {
  fn span(self) -> Span {self.keyword.span}
}

export type ListLiteral {
  openBracket: Token
  members: List<Expression>
  closeBracket: Token
}

impl ToSpan for ListLiteral {
  fn span(self) -> Span {{
    start: self.openBracket.span.start
    end: self.closeBracket.span.end
  }}
}

export type NumberLiteral {
  value: Num
  span: Span
}

impl ToSpan for NumberLiteral {
  fn span(self) -> Span {self.span}
}

export type RecordLiteral {
  openBrace: Token
  members: List<RecordLiteralMember>
  closeBrace: Token
}

impl ToSpan for RecordLiteral {
  fn span(self) -> Span {{
    start: self.openBrace.span.start
    end: self.closeBrace.span.end
  }}
}

export type RecordLiteralMember {
  name: Identifier
  value: Expression
}

export type StringLiteral {
  parts: List<StringLiteralPart>
}

impl ToSpan for StringLiteral {
  fn span(self) -> Span {{
    start: self.parts.first().unwrap().span().start
    end: self.parts.last().unwrap().span().end
  }}
}

export type SimpleStringLiteral {
  value: String
  span: Span
}

export enum StringLiteralPart {
  Literal(SimpleStringLiteral)
  Identifier(Identifier)
}

impl ToSpan for StringLiteralPart {
  fn span(self) -> Span {
    match self {
      StringLiteralPart::Literal({span}) => span
      StringLiteralPart::Identifier({span}) => span
    }
  }
}

export type TupleLiteral {
  openParen: Token
  expressions: List<Expression>
  closeParen: Token
}

impl ToSpan for TupleLiteral {
  fn span(self) -> Span {{
    start: self.openParen.span.start
    end: self.closeParen.span.end
  }}
}

export enum Pattern {
  CatchAll(Token)
  Identifier(Identifier)
  // Boolen(BooleanLiteral)
  // Number(NumberLiteral)
  // String(SimpleStringLiteral)
  Record(RecordPattern)
  Tuple(TuplePattern)
  RecordType(TypePath, RecordPattern)
  TupleType(TypePath, TuplePattern)
  UnitType(TypePath)
}

impl Pattern {
  fn displayName(self) -> String {
    match self {
      Pattern::CatchAll(_) => '_'
      Pattern::Identifier(identifier) => identifier.name
      Pattern::Record(recordPattern) => recordPattern.displayName()
      Pattern::Tuple(tuplePattern) => tuplePattern.displayName()
      Pattern::RecordType(_, recordPattern) => recordPattern.displayName()
      Pattern::TupleType(_, tuplePattern) => tuplePattern.displayName()
      Pattern::UnitType(_) => ''
    }
  }
}

impl ToSpan for Pattern {
  fn span(self) -> Span {
    match self {
      Pattern::CatchAll(token) => token.span
      Pattern::Identifier(identifier) => identifier.span
      Pattern::Record(recordPattern) => {{
        start: recordPattern.openBrace.span.start
        end: recordPattern.closeBrace.span.end
      }}
      Pattern::Tuple(tuplePattern) => {{
        start: tuplePattern.openParen.span.start
        end: tuplePattern.closeParen.span.end
      }}
      Pattern::RecordType(typePath, recordPattern) => {{
        start: typePath.span().start
        end: recordPattern.closeBrace.span.end
      }}
      Pattern::TupleType(typePath, tuplePattern) => {{
        start: typePath.span().start
        end: tuplePattern.closeParen.span.end
      }}
      Pattern::UnitType(typePath) => typePath.span()
    }
  }
}

export type RecordPattern {
  openBrace: Token
  properties: List<RecordPatternMember>
  closeBrace: Token
}

impl RecordPattern {
  fn displayName(self) -> String {
    '{' +
      self.properties.map(|p| {
        let shorthand =
          if let Pattern::Identifier({name}) = p.pattern
            then name == p.property.name
            else false

        if shorthand
          then p.property.name
          else p.property.name + ': ' + p.pattern.displayName()
      }).join(', ') +
    '}'
  }
}

export type RecordPatternMember {
  property: Identifier
  pattern: Pattern
}

export type TuplePattern {
  openParen: Token
  properties: List<Pattern>
  closeParen: Token
}

impl TuplePattern {
  fn displayName(self) -> String {
    '(' + self.properties.map(|p| p.displayName()).join(', ') + ')'
  }
}

export enum TypeBound {
  FunctionTypeBound(FunctionTypeBound)
  NamedTypeBound(NamedTypeBound)
  RecordTypeBound(RecordTypeBound)
  TupleTypeBound(TupleTypeBound)
}

impl TypeBound {
  fn getType(self) -> Type {
    match self {
      TypeBound::FunctionTypeBound(t) => t.type_
      TypeBound::NamedTypeBound(t) => t.type_
      TypeBound::RecordTypeBound(t) => t.type_
      TypeBound::TupleTypeBound(t) => t.type_
    }
  }

  fn getRecordTypeBound(self) -> RecordTypeBound {
    match self {
      TypeBound::RecordTypeBound(record) => record
      _ => throw 'TypeBound is not a RecordTypeBound'
    }
  }

  fn getTupleTypeBound(self) -> TupleTypeBound {
    match self {
      TypeBound::TupleTypeBound(tuple) => tuple
      _ => throw 'TypeBound is not a TupleTypeBound'
    }
  }
}

impl ToSpan for TypeBound {
  fn span(self) -> Span {
    match self {
      TypeBound::FunctionTypeBound(t) => t.span()
      TypeBound::NamedTypeBound(t) => t.span()
      TypeBound::RecordTypeBound(t) => t.span()
      TypeBound::TupleTypeBound(t) => t.span()
    }
  }
}

export type FunctionTypeBound {
  typeParameters: List<TypeParameter>
  parameters: TupleTypeBound
  returnType: TypeBound
}

impl ToSpan for FunctionTypeBound {
  fn span(self) -> Span {{
    start: self.typeParameters.first().mapOrElse(|| self.parameters.span(), |p| p.span()).start
    end: self.returnType.span().end
  }}
}

export type NamedTypeBound {
  path: TypePath
  typeParameters: List<TypeBound>
}

impl ToSpan for NamedTypeBound {
  fn span(self) -> Span {{
    start: self.path.span().start
    end: self.typeParameters.last().mapOr(self.path.span(), |p| p.span()).end
  }}
}

export type RecordTypeBound {
  openBrace: Token
  properties: List<RecordTypeBoundMember>
  closeBrace: Token
}

impl ToSpan for RecordTypeBound {
  fn span(self) -> Span {{
    start: self.openBrace.span.start
    end: self.closeBrace.span.end
  }}
}

export type RecordTypeBoundMember {
  name: Identifier
  typeBound: TypeBound
}

export type TupleTypeBound {
  openParen: Token
  properties: List<TypeBound>
  closeParen: Token
}

impl ToSpan for TupleTypeBound {
  fn span(self) -> Span {{
    start: self.openParen.span.start
    end: self.closeParen.span.end
  }}
}

export type TypeParameter {
  name: Identifier
  defaultValue: Option<TypeBound>
}

impl ToSpan for TypeParameter {
  fn span(self) -> Span {{
    start: self.name.span.start
    end: self.name.span.end
  }}
}
