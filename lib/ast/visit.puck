import 'ast.puck' as {
  Module
  TopLevelStatement
  BlockLevelStatement
  Expression

  EnumDeclaration
  EnumMember
  ImplDeclaration
  ImplShorthandDeclaration
  TraitDeclaration

  ExportDirective
  ExportedStatement
  ImportDirective
  ObjectDestructure
  TypeDeclaration

  Block
  ReturnStatement
  WhileLoop

  Identifier
  FunctionDeclaration
  VariableDeclaration

  AssignmentExpression
  BinaryExpression
  CallExpression
  IfExpression
  IfLetExpression
  MatchExpression
  MatchArm
  TypePathExpression
  TypePath
  UnaryExpression

  IndexAccess
  MemberAccess

  BooleanLiteral
  ListLiteral
  NumberLiteral
  RecordLiteral
  StringLiteral
  StringLiteralPart
  TupleLiteral

  Pattern
  RecordPattern
  TuplePattern

  TypeBound
  FunctionTypeBound
  NamedTypeBound
  RecordTypeBound
  RecordTypeBoundMember
  TupleTypeBound
  TypeParameter
}
import '../compiler/ast.ts' as {SyntaxKind}

export type Visitor {}

// Comments and Design based on [Rust](https://github.com/rust-lang/rust/blob/86dde9bbda92c02c61282b5df5d38338a798ef3b/src/libsyntax/visit.rs)

//! AST walker. Each overridden visit method has full control over what
//! happens with its node, it can do its own traversal of the node's children,
//! call `visit::walk*` to apply the default traversal algorithm, or prevent
//! deeper traversal by doing nothing.
//!
//! Note: it is an important invariant that the default visitor walks the body
//! of a function in "execution order" (more concretely, reverse post-order
//! with respect to the CFG implied by the AST), meaning that if AST node A may
//! execute before AST node B, then A is visited first.  The borrow checker in
//! particular relies on this property.
//!
//! Note: walking an AST before macro expansion is probably a bad idea. For
//! instance, a walker looking for item names in a module will miss all of
//! those that are created by the expansion of a macro.

/// Each method of the Visitor trait is a hook to be potentially
/// overridden.  Each method's default implementation recursively visits
/// the substructure of the input via the corresponding `walk` function;
/// e.g. the `visitBlock` method by default calls `walkMod`.
///
/// If you want to ensure that your code handles every variant
/// explicitly, you need to override each method.  (And you also need
/// to monitor future changes to `Visitor` in case a new method with a
/// new default implementation gets introduced.)
export let walkingVisitor = {
  visitModule: |self, m: Module| walkModule(self, m)
  visitTopLevelStatement: |self, e: TopLevelStatement| walkTopLevelStatement(self, e)
  visitBlockLevelStatement: |self, e: BlockLevelStatement| walkBlockLevelStatement(self, e)
  visitExpression: |self, e: Expression| walkExpression(self, e)

  visitEnumDeclaration: |self, e: EnumDeclaration| walkEnumDeclaration(self, e)
  visitEnumMember: |self, e: EnumMember| walkEnumMember(self, e)
  visitImplDeclaration: |self, i: ImplDeclaration| walkImplDeclaration(self, i)
  visitImplShorthandDeclaration: |self, i: ImplShorthandDeclaration| walkImplShorthandDeclaration(self, i)
  visitMethodDeclaration: |self, f: FunctionDeclaration| walkFunctionDeclaration(self, f)
  visitTraitDeclaration: |self, t: TraitDeclaration| walkTraitDeclaration(self, t)
  visitTypeDeclaration: |self, t: TypeDeclaration| walkTypeDeclaration(self, t)

  visitExportDirective: |self, e: ExportDirective| walkExportDirective(self, e)
  visitImportDirective: |self, i: ImportDirective| walkImportDirective(self, i)
  visitObjectDestructure: |self, o: ObjectDestructure| walkObjectDestructure(self, o)

  visitBlock: |self, b: Block| walkBlock(self, b)
  visitBreak: || {}
  visitReturn: |self, r: ReturnStatement| walkReturn(self, r)
  visitWhileLoop: |self, e: WhileLoop| walkWhileLoop(self, e)

  visitIdentifier: |self, i: Identifier| walkIdentifier(self, i)
  visitFunctionDeclaration: |self, f: FunctionDeclaration| walkFunctionDeclaration(self, f)
  visitVariableDeclaration: |self, d: VariableDeclaration| walkVariableDeclaration(self, d)

  visitAssignmentExpression: |self, e: AssignmentExpression| walkAssignmentExpression(self, e)
  visitBinaryExpression: |self, e: BinaryExpression| walkBinaryExpression(self, e)
  visitCallExpression: |self, e: CallExpression| walkCallExpression(self, e)
  visitIfExpression: |self, e: IfExpression| walkIfExpression(self, e)
  visitIfLetExpression: |self, e: IfLetExpression| walkIfLetExpression(self, e)
  visitMatchExpression: |self, e: MatchExpression| walkMatchExpression(self, e)
  visitMatchArm: |self, e: MatchArm| walkMatchArm(self, e)
  visitUnaryExpression: |self, e: UnaryExpression| walkUnaryExpression(self, e)

  visitIndexAccess: |self, a: IndexAccess| walkIndexAccess(self, a)
  visitMemberAccess: |self, a: MemberAccess| walkMemberAccess(self, a)

  visitListLiteral: |self, l: ListLiteral| walkListLiteral(self, l)
  visitBooleanLiteral: |self, l: BooleanLiteral| walkBooleanLiteral(self, l)
  visitNumberLiteral: |self, l: NumberLiteral| walkNumberLiteral(self, l)
  visitRecordLiteral: |self, l: RecordLiteral| walkRecordLiteral(self, l)
  visitStringLiteral: |self, l: StringLiteral| walkStringLiteral(self, l)
  visitTupleLiteral: |self, l: TupleLiteral| walkTupleLiteral(self, l)

  visitPattern: |self, p: Pattern| walkPattern(self, p)
  visitIdentifierPattern: |self, p: Identifier| walkIdentifierPattern(self, p)
  visitRecordPattern: |self, p: RecordPattern| walkRecordPattern(self, p)
  visitTuplePattern: |self, p: TuplePattern| walkTuplePattern(self, p)

  visitTypeBound: |self, t: TypeBound| walkTypeBound(self, t)
  visitFunctionTypeBound: |self, t: FunctionTypeBound| walkFunctionTypeBound(self, t)
  visitNamedTypeBound: |self, t: NamedTypeBound| walkNamedTypeBound(self, t)
  visitRecordTypeBound: |self, t: RecordTypeBound| walkRecordTypeBound(self, t)
  visitRecordTypeBoundMember: |self, t: RecordTypeBoundMember| walkRecordTypeBoundMember(self, t)
  visitTupleTypeBound: |self, t: TupleTypeBound| walkTupleTypeBound(self, t)
  visitTypeParameter: |self, t: TypeParameter| walkTypeParameter(self, t)
}

export let emptyVisitor = {
  visitModule: || {}
  visitTopLevelStatement: |self, e: TopLevelStatement| walkTopLevelStatement(self, e)
  visitBlockLevelStatement: |self, e: BlockLevelStatement| walkBlockLevelStatement(self, e)
  visitExpression: |self, e: Expression| walkExpression(self, e)

  visitEnumDeclaration: || {}
  visitEnumMember: || {}
  visitMethodDeclaration: || {}
  visitImplDeclaration: || {}
  visitImplShorthandDeclaration: || {}
  visitTraitDeclaration: || {}
  visitTypeDeclaration: || {}

  visitExportDirective: || {}
  visitImportDirective: || {}
  visitObjectDestructure: || {}

  visitBlock: || {}
  visitBreak: || {}
  visitReturn: || {}
  visitWhileLoop: || {}


  visitIdentifier: || {}
  visitFunctionDeclaration: || {}
  visitVariableDeclaration: || {}

  visitAssignmentExpression: || {}
  visitBinaryExpression: || {}
  visitCallExpression: || {}
  visitIfExpression: || {}
  visitIfLetExpression: || {}
  visitMatchExpression: || {}
  visitMatchArm: || {}
  visitTypePath: || {}
  visitTypePathExpression: || {}
  visitUnaryExpression: || {}

  visitIndexAccess: || {}
  visitMemberAccess: || {}

  visitBooleanLiteral: || {}
  visitListLiteral: || {}
  visitNumberLiteral: || {}
  visitRecordLiteral: || {}
  visitStringLiteral: || {}
  visitTupleLiteral: || {}

  visitPattern: || {}
  visitIdentifierPattern: || {}
  visitRecordPattern: || {}
  visitTuplePattern: || {}
  visitTypeParameter: || {}

  visitTypeBound: |self, t: TypeBound| walkTypeBound(self, t)
  visitFunctionTypeBound: || {}
  visitNamedTypeBound: || {}
  visitRecordTypeBound: || {}
  visitRecordTypeBoundMember: || {}
  visitTupleTypeBound: || {}
}

export fn walkModule(visitor: Visitor, m: Module) {
  m.statements.forEach(|s| visitor.visitTopLevelStatement(s))
}
export fn walkTopLevelStatement(visitor: Visitor, s: TopLevelStatement) {
  match s {
    TopLevelStatement::ExportDirective(e) => visitor.visitExportDirective(e)
    TopLevelStatement::ImportDirective(e) => visitor.visitImportDirective(e)

    TopLevelStatement::EnumDeclaration(e) => visitor.visitEnumDeclaration(e)
    TopLevelStatement::ImplDeclaration(e) => visitor.visitImplDeclaration(e)
    TopLevelStatement::ImplShorthandDeclaration(e) => visitor.visitImplShorthandDeclaration(e)
    TopLevelStatement::TraitDeclaration(e) => visitor.visitTraitDeclaration(e)
    TopLevelStatement::TypeDeclaration(e) => visitor.visitTypeDeclaration(e)

    TopLevelStatement::BlockLevelStatement(e) => walkBlockLevelStatement(visitor, e)
  }
}
export fn walkBlockLevelStatement(visitor: Visitor, s: BlockLevelStatement) {
  match s {
    BlockLevelStatement::Block(e) => visitor.visitBlock(e)
    BlockLevelStatement::BreakStatement(e) => visitor.visitBreak(e)
    BlockLevelStatement::ReturnStatement(e) => visitor.visitReturn(e)
    BlockLevelStatement::WhileLoop(e) => visitor.visitWhileLoop(e)

    BlockLevelStatement::Expression(e) => walkExpression(visitor, e)
  }
}
export fn walkExpression(visitor: Visitor, e: Expression) {
  match e {
    Expression::ThrowStatement(e) => visitor.visitExpression(e.expression)
    Expression::Comment(_) => {}

    Expression::Identifier(e) => visitor.visitIdentifier(e)
    Expression::FunctionDeclaration(e) => visitor.visitFunctionDeclaration(e)
    Expression::VariableDeclaration(e) => visitor.visitVariableDeclaration(e)

    Expression::AssignmentExpression(e) => visitor.visitAssignmentExpression(e)
    Expression::BinaryExpression(e) => visitor.visitBinaryExpression(e)
    Expression::CallExpression(e) => visitor.visitCallExpression(e)
    Expression::IfExpression(e) => visitor.visitIfExpression(e)
    Expression::IfLetExpression(e) => visitor.visitIfLetExpression(e)
    Expression::MatchExpression(e) => visitor.visitMatchExpression(e)
    Expression::TypePathExpression(e) => visitor.visitTypePathExpression(e)
    Expression::UnaryExpression(e) => visitor.visitUnaryExpression(e)

    Expression::IndexAccess(e) => visitor.visitIndexAccess(e)
    Expression::MemberAccess(e) => visitor.visitMemberAccess(e)

    Expression::BooleanLiteral(e) => visitor.visitBooleanLiteral(e)
    Expression::ListLiteral(e) => visitor.visitListLiteral(e)
    Expression::NumberLiteral(e) => visitor.visitNumberLiteral(e)
    Expression::RecordLiteral(e) => visitor.visitRecordLiteral(e)
    Expression::StringLiteral(e) => visitor.visitStringLiteral(e)
    Expression::TupleLiteral(e) => visitor.visitTupleLiteral(e)
  }
}

export fn walkEnumDeclaration(visitor: Visitor, e: EnumDeclaration) {
  // visitor.visitIdentifier(e.name)
  e.typeParameters.forEach(|t| visitor.visitTypeParameter(t))
  e.members.forEach(|t| visitor.visitEnumMember(t))
}
export fn walkEnumMember(visitor: Visitor, e: EnumMember) {
  // visitor.visitIdentifier(e.name)
  if let Option::Some(typeBound) = e.bound then visitor.visitTypeBound(typeBound)
}
export fn walkImplDeclaration(visitor: Visitor, i: ImplDeclaration) {
  i.typeParameters.forEach(visitor.visitTypeParameter.bind(visitor))
  visitor.visitTypeBound(i.trait_)
  visitor.visitTypeBound(i.type_)
  i.members.forEach(visitor.visitFunctionDeclaration.bind(visitor))
}
export fn walkImplShorthandDeclaration(visitor: Visitor, i: ImplShorthandDeclaration) {
  i.typeParameters.forEach(visitor.visitTypeParameter.bind(visitor))
  visitor.visitTypeBound(i.type_)
  i.members.forEach(visitor.visitFunctionDeclaration.bind(visitor))
}
export fn walkTraitDeclaration(visitor: Visitor, t: TraitDeclaration) {
  if t.typeParameters
    then t.typeParameters.forEach(visitor.visitTypeParameter.bind(visitor))
  t.members.forEach(|t| visitor.visitFunctionDeclaration(t))
}
export fn walkTypeDeclaration(visitor: Visitor, t: TypeDeclaration) {
  // visitor.visitIdentifier(t.name)
  t.typeParameters.forEach(|t| visitor.visitTypeParameter(t))
  if let Option::Some(typeBound) = t.bound then visitor.visitTypeBound(typeBound)
}

export fn walkExportDirective(visitor: Visitor, e: ExportDirective) {
   match e.statement {
    ExportedStatement::EnumDeclaration(d) => visitor.visitEnumDeclaration(d)
    ExportedStatement::FunctionDeclaration(d) => visitor.visitFunctionDeclaration(d)
    ExportedStatement::TraitDeclaration(d) => visitor.visitTraitDeclaration(d)
    ExportedStatement::TypeDeclaration(d) => visitor.visitTypeDeclaration(d)
    ExportedStatement::VariableDeclaration(d) => visitor.visitVariableDeclaration(d)
  }
}
export fn walkImportDirective(visitor: Visitor, i: ImportDirective) {
  if i.specifier.kind == SyntaxKind.Identifier
    then visitor.visitIdentifier(i.specifier)
  else if i.specifier.kind == SyntaxKind.ObjectDestructure
    then visitor.visitObjectDestructure(i.specifier)
}
export fn walkObjectDestructure(visitor: Visitor, o: ObjectDestructure) {
  o.members.forEach(|m| {
    visitor.visitIdentifier(m.property)
    visitor.visitIdentifier(m.local)
  })
}

export fn walkBlock(visitor: Visitor, b: Block) {
  b.statements.forEach(|s| visitor.visitBlockLevelStatement(s))
}
export fn walkReturn(visitor: Visitor, r: ReturnStatement) {
  visitor.visitExpression(r.expression)
}
export fn walkWhileLoop(visitor: Visitor, e: WhileLoop) {
  visitor.visitExpression(e.condition)
  visitor.visitBlock(e.body)
}

export fn walkIdentifier(visitor: Visitor, i: Identifier) {}
export fn walkFunctionDeclaration(visitor: Visitor, f: FunctionDeclaration) {
  if f.typeParameters
    then f.typeParameters.forEach(visitor.visitTypeParameter.bind(visitor))
  f.parameterList.forEach(visitor.visitVariableDeclaration.bind(visitor))
  if let Option::Some(returnType) = f.returnType then visitor.visitTypeBound(returnType)
  if let Option::Some(body) = f.body then visitor.visitBlock(body)
}
export fn walkVariableDeclaration(visitor: Visitor, d: VariableDeclaration) {
  visitor.visitPattern(d.pattern)
  if let Option::Some(typeBound) = d.typeBound then visitor.visitTypeBound(typeBound)
  if let Option::Some(initializer) = d.initializer then visitor.visitExpression(initializer)
}

export fn walkAssignmentExpression(visitor: Visitor, e: AssignmentExpression) {
  visitor.visitExpression(e.lhs)
  visitor.visitExpression(e.rhs)
}
export fn walkBinaryExpression(visitor: Visitor, e: BinaryExpression) {
  visitor.visitExpression(e.lhs)
  visitor.visitExpression(e.rhs)
}
export fn walkCallExpression(visitor: Visitor, e: CallExpression) {
  visitor.visitExpression(e.func)
  e.argumentList.forEach(visitor.visitExpression.bind(visitor))
}
export fn walkIfExpression(visitor: Visitor, e: IfExpression) {
  visitor.visitExpression(e.condition)
  visitor.visitBlock(e.then_)
  if let Option::Some(else_) = e.else_ then visitor.visitBlock(else_)
}
export fn walkIfLetExpression(visitor: Visitor, e: IfLetExpression) {
  visitor.visitPattern(e.pattern)
  visitor.visitExpression(e.expression)
  visitor.visitBlock(e.then_)
  if let Option::Some(else_) = e.else_ then visitor.visitBlock(else_)
}
export fn walkMatchExpression(visitor: Visitor, e: MatchExpression) {
  visitor.visitExpression(e.expression)
  e.patterns.forEach(|p| visitor.visitMatchArm(p))
}
export fn walkMatchArm(visitor: Visitor, e: MatchArm) {
  visitor.visitPattern(e.pattern)
  visitor.visitBlock(e.block)
}
export fn walkUnaryExpression(visitor: Visitor, e: UnaryExpression) {
  visitor.visitExpression(e.rhs)
}

export fn walkIndexAccess(visitor: Visitor, a: IndexAccess) {
  visitor.visitExpression(a.object)
  visitor.visitExpression(a.index)
}
export fn walkMemberAccess(visitor: Visitor, a: MemberAccess) {
  visitor.visitExpression(a.object)
  visitor.visitExpression(a.member)
}

export fn walkBooleanLiteral(visitor: Visitor, l: BooleanLiteral) {}
export fn walkListLiteral(visitor: Visitor, l: ListLiteral) {
  l.members.forEach(visitor.visitExpression.bind(visitor))
}
export fn walkNumberLiteral(visitor: Visitor, l: NumberLiteral) {}
export fn walkRecordLiteral(visitor: Visitor, l: RecordLiteral) {
  l.members.forEach(|m| {
    visitor.visitIdentifier(m.name)
    visitor.visitExpression(m.value)
  })
}
export fn walkStringLiteral(visitor: Visitor, l: StringLiteral) {
  l.parts
    .filterMap(|p| match p {
      StringLiteralPart::Identifier(identifier) => Some(identifier)
      _ => None
    })
    .forEach(|i| visitor.visitIdentifier(i))
}
export fn walkTupleLiteral(visitor: Visitor, l: TupleLiteral) {
  l.expressions.forEach(visitor.visitExpression.bind(visitor))
}

export fn walkPattern(visitor: Visitor, p: Pattern) {
  match p {
    Pattern::CatchAll => {}
    Pattern::Identifier(identifier) => visitor.visitIdentifierPattern(identifier)
    Pattern::Record(record) => visitor.visitRecordPattern(record)
    Pattern::RecordType(typePath, record) => {
      visitor.visitTypePath(typePath)
      visitor.visitRecordPattern(record)
    }
    Pattern::Tuple(tuple) => visitor.visitTuplePattern(tuple)
    Pattern::TupleType(typePath, tuple) => {
      visitor.visitTypePath(typePath)
      visitor.visitTuplePattern(tuple)
    }
    Pattern::UnitType(typePath) => {
      visitor.visitTypePath(typePath)
    }
  }
}
export fn walkIdentifierPattern(visitor: Visitor, p: Identifier) {
  // visitor.visitIdentifier(p)
}
export fn walkRecordPattern(visitor: Visitor, p: RecordPattern) {
  p.properties.forEach(|p| {
    // visitor.visitIdentifier(p.property)
    visitor.visitPattern(p.pattern)
  })
}
export fn walkTuplePattern(visitor: Visitor, p: TuplePattern) {
  p.properties.forEach(|p| visitor.visitPattern(p))
}

export fn walkTypeBound(visitor: Visitor, t: TypeBound) {
  match t {
    TypeBound::FunctionTypeBound(t) => visitor.visitFunctionTypeBound(t)
    TypeBound::NamedTypeBound(t) => visitor.visitNamedTypeBound(t)
    TypeBound::RecordTypeBound(t) => visitor.visitRecordTypeBound(t)
    TypeBound::TupleTypeBound(t) => visitor.visitTupleTypeBound(t)
  }
}
export fn walkFunctionTypeBound(visitor: Visitor, t: FunctionTypeBound) {
  t.typeParameters.forEach(visitor.visitTypeParameter.bind(visitor))
  visitor.visitTupleTypeBound(t.parameters)
  visitor.visitTypeBound(t.returnType)
}
export fn walkNamedTypeBound(visitor: Visitor, t: NamedTypeBound) {
  t.typeParameters.forEach(visitor.visitTypeBound.bind(visitor))
}
export fn walkRecordTypeBound(visitor: Visitor, t: RecordTypeBound) {
  t.properties.forEach(|t| visitor.visitRecordTypeBoundMember(t))
}
export fn walkRecordTypeBoundMember(visitor: Visitor, t: RecordTypeBoundMember) {
  // visitor.visitIdentifier(t.name)
  visitor.visitTypeBound(t.typeBound)
}
export fn walkTupleTypeBound(visitor: Visitor, t: TupleTypeBound) {
  t.properties.forEach(visitor.visitTypeBound.bind(visitor))
}
export fn walkTypeParameter(visitor: Visitor, t: TypeParameter) {
  // visitor.visitIdentifier(t.name)
  if let Option::Some(defaultValue) = t.defaultValue then visitor.visitTypeBound(defaultValue)
}
