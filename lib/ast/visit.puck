import 'ast.puck' as {
  Expression

  Block
  EnumDeclaration
  FunctionDeclaration
  Identifier
  ImplDeclaration
  Module
  ObjectDestructure
  TraitDeclaration
  TypeBound
  FunctionTypeBound
  NamedTypeBound
  ObjectTypeBound
  TupleTypeBound
  TypeDeclaration
  TypeParameter
  TypeProperty
  VariableDeclaration

  ExportDirective
  ImportDirective

  Pattern
  RecordPattern
  TuplePattern

  AssignmentExpression
  BinaryExpression
  CallExpression
  ForExpression
  IfExpression
  IfLetExpression
  MatchExpression
  MatchArm
  TypePathExpression
  UnaryExpression
  WhileExpression

  IndexAccess
  MemberAccess
  TypePath

  Token
  ReturnStatement

  ListLiteral
  BooleanLiteral
  NumberLiteral
  ObjectLiteral
  StringLiteral
  TupleLiteral

  EnumMember
}
import '../compiler/ast.ts' as {SyntaxKind}

export type Visitor {}

// Comments and Design based on [Rust](https://github.com/rust-lang/rust/blob/86dde9bbda92c02c61282b5df5d38338a798ef3b/src/libsyntax/visit.rs)

//! AST walker. Each overridden visit method has full control over what
//! happens with its node, it can do its own traversal of the node's children,
//! call `visit::walk*` to apply the default traversal algorithm, or prevent
//! deeper traversal by doing nothing.
//!
//! Note: it is an important invariant that the default visitor walks the body
//! of a function in "execution order" (more concretely, reverse post-order
//! with respect to the CFG implied by the AST), meaning that if AST node A may
//! execute before AST node B, then A is visited first.  The borrow checker in
//! particular relies on this property.
//!
//! Note: walking an AST before macro expansion is probably a bad idea. For
//! instance, a walker looking for item names in a module will miss all of
//! those that are created by the expansion of a macro.

/// Each method of the Visitor trait is a hook to be potentially
/// overridden.  Each method's default implementation recursively visits
/// the substructure of the input via the corresponding `walk` function;
/// e.g. the `visitBlock` method by default calls `walkMod`.
///
/// If you want to ensure that your code handles every variant
/// explicitly, you need to override each method.  (And you also need
/// to monitor future changes to `Visitor` in case a new method with a
/// new default implementation gets introduced.)
export let walkingVisitor = {
  visitExpression: |self, e: Expression| walkExpression(self, e)

  visitBlock: |self, b: Block| walkBlock(self, b)
  visitEnumDeclaration: |self, e: EnumDeclaration| walkEnumDeclaration(self, e)
  visitEnumMember: |self, e: EnumMember| walkEnumMember(self, e)
  visitFunctionDeclaration: |self, f: FunctionDeclaration| walkFunction(self, f)
  visitIdentifier: |self, i: Identifier| walkIdentifier(self, i)
  visitImplDeclaration: |self, i: ImplDeclaration| walkImplDeclaration(self, i)
  visitModule: |self, m: Module| walkModule(self, m)
  visitObjectDestructure: |self, o: ObjectDestructure| walkObjectDestructure(self, o)
  visitTraitDeclaration: |self, t: TraitDeclaration| walkTraitDeclaration(self, t)
  visitTypeBound: |self, t: TypeBound| walkTypeBound(self, t)
  visitFunctionTypeBound: |self, t: FunctionTypeBound| walkFunctionTypeBound(self, t)
  visitNamedTypeBound: |self, t: NamedTypeBound| walkNamedTypeBound(self, t)
  visitObjectTypeBound: |self, t: ObjectTypeBound| walkObjectTypeBound(self, t)
  visitTupleTypeBound: |self, t: TupleTypeBound| walkTupleTypeBound(self, t)
  visitTypeDeclaration: |self, t: TypeDeclaration| walkTypeDeclaration(self, t)
  visitTypeParameter: |self, t: TypeParameter| walkTypeParameter(self, t)
  // visitTypePath: |self, t: TypeParameter| walkTypeParameter(self, t)
  visitTypeProperty: |self, t: TypeProperty| walkTypeProperty(self, t)
  visitVariableDeclaration: |self, d: VariableDeclaration| walkVariableDeclaration(self, d)

  visitExportDirective: |self, e: ExportDirective| walkExportDirective(self, e)
  visitImportDirective: |self, i: ImportDirective| walkImportDirective(self, i)

  visitPattern: |self, p: Pattern| walkPattern(self, p)
  visitIdentifierPattern: |self, p: Identifier| walkIdentifierPattern(self, p)
  visitRecordPattern: |self, p: RecordPattern| walkRecordPattern(self, p)
  visitTuplePattern: |self, p: TuplePattern| walkTuplePattern(self, p)

  visitAssignmentExpression: |self, e: AssignmentExpression| walkAssignmentExpression(self, e)
  visitBinaryExpression: |self, e: BinaryExpression| walkBinaryExpression(self, e)
  visitCallExpression: |self, e: CallExpression| walkCallExpression(self, e)
  visitForExpression: |self, e: ForExpression| walkForExpression(self, e)
  visitIfExpression: |self, e: IfExpression| walkIfExpression(self, e)
  visitIfLetExpression: |self, e: IfLetExpression| walkIfLetExpression(self, e)
  visitMatchExpression: |self, e: MatchExpression| walkMatchExpression(self, e)
  visitMatchArm: |self, e: MatchArm| walkMatchArm(self, e)
  visitUnaryExpression: |self, e: UnaryExpression| walkUnaryExpression(self, e)
  visitWhileExpression: |self, e: WhileExpression| walkWhileExpression(self, e)

  visitIndexAccess: |self, a: IndexAccess| walkIndexAccess(self, a)
  visitMemberAccess: |self, a: MemberAccess| walkMemberAccess(self, a)

  visitBreak: |self, b: Token| walkBreak(self, b)
  visitReturn: |self, r: ReturnStatement| walkReturn(self, r)

  visitListLiteral: |self, l: ListLiteral| walkListLiteral(self, l)
  visitBooleanLiteral: |self, l: BooleanLiteral| walkBooleanLiteral(self, l)
  visitNumberLiteral: |self, l: NumberLiteral| walkNumberLiteral(self, l)
  visitObjectLiteral: |self, l: ObjectLiteral| walkObjectLiteral(self, l)
  visitStringLiteral: |self, l: StringLiteral| walkStringLiteral(self, l)
  visitTupleLiteral: |self, l: TupleLiteral| walkTupleLiteral(self, l)
}

export let emptyVisitor = {
  visitExpression: |self, e: Expression| walkExpression(self, e)

  visitBlock: || {}
  visitEnumDeclaration: || {}
  visitEnumMember: || {}
  visitFunctionDeclaration: || {}
  visitIdentifier: || {}
  visitImplDeclaration: || {}
  visitModule: || {}
  visitObjectDestructure: || {}
  visitTraitDeclaration: || {}
  visitTypeBound: |self, t: TypeBound| walkTypeBound(self, t)
  visitFunctionTypeBound: || {}
  visitNamedTypeBound: || {}
  visitObjectTypeBound: || {}
  visitTupleTypeBound: || {}
  visitTypeDeclaration: || {}
  visitTypeParameter: || {}
  visitTypePath: || {}
  visitTypeProperty: || {}
  visitVariableDeclaration: || {}

  visitExportDirective: || {}
  visitImportDirective: || {}

  visitPattern: || {}
  visitIdentifierPattern: || {}
  visitRecordPattern: || {}
  visitTuplePattern: || {}

  visitAssignmentExpression: || {}
  visitBinaryExpression: || {}
  visitCallExpression: || {}
  visitForExpression: || {}
  visitIfExpression: || {}
  visitIfLetExpression: || {}
  visitMatchExpression: || {}
  visitMatchArm: || {}
  visitTypePathExpression: || {}
  visitUnaryExpression: || {}
  visitWhileExpression: || {}

  visitIndexAccess: || {}
  visitMemberAccess: || {}

  visitBreak: || {}
  visitReturn: || {}

  visitListLiteral: || {}
  visitBooleanLiteral: || {}
  visitNumberLiteral: || {}
  visitObjectLiteral: || {}
  visitStringLiteral: || {}
  visitTupleLiteral: || {}
}

export fn walkExpression(visitor: Visitor, e: Expression) {
  if e.kind == SyntaxKind.Block then visitor.visitBlock(e)
  else if e.kind == SyntaxKind.EnumDeclaration then visitor.visitEnumDeclaration(e)
  else if e.kind == SyntaxKind.Function then visitor.visitFunctionDeclaration(e)
  else if e.kind == SyntaxKind.Identifier then visitor.visitIdentifier(e)
  else if e.kind == SyntaxKind.ImplDeclaration then visitor.visitImplDeclaration(e)
  else if e.kind == SyntaxKind.ObjectDestructure then visitor.visitObjectDestructure(e)
  else if e.kind == SyntaxKind.TraitDeclaration then visitor.visitTraitDeclaration(e)
  else if e.kind == SyntaxKind.FunctionTypeBound then visitor.visitFunctionTypeBound(e)
  else if e.kind == SyntaxKind.NamedTypeBound then visitor.visitNamedTypeBound(e)
  else if e.kind == SyntaxKind.ObjectTypeBound then visitor.visitObjectTypeBound(e)
  else if e.kind == SyntaxKind.TupleTypeBound then visitor.visitTupleTypeBound(e)
  else if e.kind == SyntaxKind.TypeDeclaration then visitor.visitTypeDeclaration(e)
  else if e.kind == SyntaxKind.TypeParameter then visitor.visitTypeParameter(e)
  else if e.kind == SyntaxKind.TypeProperty then visitor.visitTypeProperty(e)
  else if e.kind == SyntaxKind.VariableDeclaration then visitor.visitVariableDeclaration(e)

  else if e.kind == SyntaxKind.ExportDirective then visitor.visitExportDirective(e)
  else if e.kind == SyntaxKind.ImportDirective then visitor.visitImportDirective(e)

  else if e.kind == SyntaxKind.Pattern then visitor.visitPattern(e)

  else if e.kind == SyntaxKind.AssignmentExpression then visitor.visitAssignmentExpression(e)
  else if e.kind == SyntaxKind.BinaryExpression then visitor.visitBinaryExpression(e)
  else if e.kind == SyntaxKind.CallExpression then visitor.visitCallExpression(e)
  else if e.kind == SyntaxKind.ForExpression then visitor.visitForExpression(e)
  else if e.kind == SyntaxKind.IfExpression then visitor.visitIfExpression(e)
  else if e.kind == SyntaxKind.IfLetExpression then visitor.visitIfLetExpression(e)
  else if e.kind == SyntaxKind.MatchExpression then visitor.visitMatchExpression(e)
  else if e.kind == SyntaxKind.TypePathExpression then visitor.visitTypePathExpression(e)
  else if e.kind == SyntaxKind.UnaryExpression then visitor.visitUnaryExpression(e)
  else if e.kind == SyntaxKind.WhileExpression then visitor.visitWhileExpression(e)

  else if e.kind == SyntaxKind.IndexAccess then visitor.visitIndexAccess(e)
  else if e.kind == SyntaxKind.MemberAccess then visitor.visitMemberAccess(e)

  else if e.kind == SyntaxKind.BreakKeyword then visitor.visitBreak(e)
  else if e.kind == SyntaxKind.ReturnStatement then visitor.visitReturn(e)

  else if e.kind == SyntaxKind.ListLiteral then visitor.visitListLiteral(e)
  else if e.kind == SyntaxKind.BooleanLiteral then visitor.visitBooleanLiteral(e)
  else if e.kind == SyntaxKind.NumberLiteral then visitor.visitNumberLiteral(e)
  else if e.kind == SyntaxKind.ObjectLiteral then visitor.visitObjectLiteral(e)
  else if e.kind == SyntaxKind.StringLiteral then visitor.visitStringLiteral(e)
  else if e.kind == SyntaxKind.TupleLiteral then visitor.visitTupleLiteral(e)
}

export fn walkBlock(visitor: Visitor, b: Block) {
  b.expressions.forEach(visitor.visitExpression.bind(visitor))
}
export fn walkEnumDeclaration(visitor: Visitor, e: EnumDeclaration) {
  // visitor.visitIdentifier(e.name)
  e.typeParameters.forEach(|t| visitor.visitTypeParameter(t))
  e.members.forEach(|t| visitor.visitEnumMember(t))
}
export fn walkEnumMember(visitor: Visitor, e: EnumMember) {
  // visitor.visitIdentifier(e.name)
  if let Option::Some(typeBound) = e.bound then visitor.visitTypeBound(typeBound)
}
export fn walkFunction(visitor: Visitor, f: FunctionDeclaration) {
  if f.typeParameters
    then f.typeParameters.forEach(visitor.visitTypeParameter.bind(visitor))
  f.parameterList.forEach(visitor.visitVariableDeclaration.bind(visitor))
  if let Option::Some(returnType) = f.returnType then visitor.visitTypeBound(returnType)
  if let Option::Some(body) = f.body then visitor.visitBlock(body)
}
export fn walkIdentifier(visitor: Visitor, i: Identifier) {}
export fn walkImplDeclaration(visitor: Visitor, i: ImplDeclaration) {
  if i.typeParameters
    then i.typeParameters.forEach(visitor.visitTypeParameter.bind(visitor))
  visitor.visitTypeBound(i.trait_)
  visitor.visitTypeBound(i.type_)
  i.members.forEach(visitor.visitFunctionDeclaration.bind(visitor))
}
export fn walkModule(visitor: Visitor, m: Module) {
  m.expressions.forEach(visitor.visitExpression.bind(visitor))
}
export fn walkObjectDestructure(visitor: Visitor, o: ObjectDestructure) {
  o.members.forEach(|m| {
    visitor.visitIdentifier(m.property)
    visitor.visitIdentifier(m.local)
  })
}
export fn walkTraitDeclaration(visitor: Visitor, t: TraitDeclaration) {
  if t.typeParameters
    then t.typeParameters.forEach(visitor.visitTypeParameter.bind(visitor))
  t.members.forEach(|t| visitor.visitFunctionDeclaration(t))
}
export fn walkTypeBound(visitor: Visitor, t: TypeBound) {
  if t.kind == SyntaxKind.FunctionTypeBound
    then visitor.visitFunctionTypeBound(t)
  else if t.kind == SyntaxKind.NamedTypeBound
    then visitor.visitNamedTypeBound(t)
  else if t.kind == SyntaxKind.ObjectTypeBound
    then visitor.visitObjectTypeBound(t)
  else if t.kind == SyntaxKind.TupleTypeBound
    then visitor.visitTupleTypeBound(t)
  else {
    print('Unknown typebound ' + SyntaxKind[t.kind], t)
    throw Error('Unknown typebound ' + SyntaxKind[t.kind])
  }
}
export fn walkFunctionTypeBound(visitor: Visitor, t: FunctionTypeBound) {
  t.typeParameters.forEach(visitor.visitTypeParameter.bind(visitor))
  visitor.visitTypeBound(t.arguments)
  visitor.visitTypeBound(t.returnType)
}
export fn walkNamedTypeBound(visitor: Visitor, t: NamedTypeBound) {
  t.typeParameters.forEach(visitor.visitTypeBound.bind(visitor))
}
export fn walkObjectTypeBound(visitor: Visitor, t: ObjectTypeBound) {
  t.properties.forEach(|t| visitor.visitTypeProperty(t))
}
export fn walkTupleTypeBound(visitor: Visitor, t: TupleTypeBound) {
  t.properties.forEach(visitor.visitTypeBound.bind(visitor))
}
export fn walkTypeDeclaration(visitor: Visitor, t: TypeDeclaration) {
  // visitor.visitIdentifier(t.name)
  t.typeParameters.forEach(|t| visitor.visitTypeParameter(t))
  if let Option::Some(typeBound) = t.bound then visitor.visitTypeBound(typeBound)
}
export fn walkTypeParameter(visitor: Visitor, t: TypeParameter) {
  // visitor.visitIdentifier(t.name)
  if let Option::Some(defaultValue) = t.defaultValue then visitor.visitTypeBound(defaultValue)
}
export fn walkTypeProperty(visitor: Visitor, t: TypeProperty) {
  // visitor.visitIdentifier(t.name)
  visitor.visitTypeBound(t.typeBound)
}
export fn walkVariableDeclaration(visitor: Visitor, d: VariableDeclaration) {
  visitor.visitPattern(d.pattern)
  if let Option::Some(typeBound) = d.typeBound then visitor.visitTypeBound(typeBound)
  if let Option::Some(initializer) = d.initializer then visitor.visitExpression(initializer)
}

export fn walkExportDirective(visitor: Visitor, e: ExportDirective) {
  visitor.visitExpression(e.expression)
}
export fn walkImportDirective(visitor: Visitor, i: ImportDirective) {
  if i.specifier.kind == SyntaxKind.Identifier
    then visitor.visitIdentifier(i.specifier)
  else if i.specifier.kind == SyntaxKind.ObjectDestructure
    then visitor.visitObjectDestructure(i.specifier)
}

export fn walkPattern(visitor: Visitor, p: Pattern) {
  if p.kind == 'Identifier' {
    visitor.visitIdentifierPattern(p.value[0])
  }
  else if p.kind == 'Record' {
    visitor.visitRecordPattern(p.value[0])
  }
  else if p.kind == 'RecordType' {
    visitor.visitTypePath(p.value[0])
    visitor.visitRecordPattern(p.value[1])
  }
  else if p.kind == 'Tuple' {
    visitor.visitTuplePattern(p.value[0])
  }
  else if p.kind == 'TupleType' {
    visitor.visitTypePath(p.value[0])
    visitor.visitTuplePattern(p.value[1])
  }
}
export fn walkIdentifierPattern(visitor: Visitor, p: Identifier) {
  visitor.visitIdentifier(p)
}
export fn walkRecordPattern(visitor: Visitor, p: RecordPattern) {
  p.properties.forEach(|p| {
    visitor.visitIdentifier(p.property)
    visitor.visitPattern(p.local)
  })
}
export fn walkTuplePattern(visitor: Visitor, p: TuplePattern) {
  p.properties.forEach(|p| visitor.visitPattern(p))
}

export fn walkAssignmentExpression(visitor: Visitor, e: AssignmentExpression) {
  visitor.visitExpression(e.lhs)
  visitor.visitExpression(e.rhs)
}
export fn walkBinaryExpression(visitor: Visitor, e: BinaryExpression) {
  visitor.visitExpression(e.lhs)
  visitor.visitExpression(e.rhs)
}
export fn walkCallExpression(visitor: Visitor, e: CallExpression) {
  visitor.visitExpression(e.func)
  e.argumentList.forEach(visitor.visitExpression.bind(visitor))
}
export fn walkForExpression(visitor: Visitor, e: ForExpression) {

}
export fn walkIfExpression(visitor: Visitor, e: IfExpression) {
  visitor.visitExpression(e.condition)
  visitor.visitBlock(e.then_)
  if let Option::Some(else_) = e.else_ then visitor.visitBlock(else_)
}
export fn walkIfLetExpression(visitor: Visitor, e: IfLetExpression) {
  visitor.visitVariableDeclaration(e.variableDeclaration)
  visitor.visitBlock(e.then_)
  if let Option::Some(else_) = e.else_ then visitor.visitBlock(else_)
}
export fn walkMatchExpression(visitor: Visitor, e: MatchExpression) {
  visitor.visitExpression(e.expression)
  e.patterns.forEach(|p| visitor.visitMatchArm(p))
}
export fn walkMatchArm(visitor: Visitor, e: MatchArm) {
  visitor.visitPattern(e.pattern)
  visitor.visitBlock(e.block)
}
export fn walkUnaryExpression(visitor: Visitor, e: UnaryExpression) {
  visitor.visitExpression(e.rhs)
}
export fn walkWhileExpression(visitor: Visitor, e: WhileExpression) {
  visitor.visitExpression(e.condition)
  visitor.visitBlock(e.body)
}

export fn walkIndexAccess(visitor: Visitor, a: IndexAccess) {
  visitor.visitExpression(a.object)
  visitor.visitExpression(a.index)
}
export fn walkMemberAccess(visitor: Visitor, a: MemberAccess) {
  visitor.visitExpression(a.object)
  visitor.visitExpression(a.member)
}

export fn walkBreak(visitor: Visitor, b: Token) {}
export fn walkReturn(visitor: Visitor, r: ReturnStatement) {
  visitor.visitExpression(r.expression)
}

export fn walkBooleanLiteral(visitor: Visitor, l: BooleanLiteral) {}
export fn walkListLiteral(visitor: Visitor, l: ListLiteral) {
  l.members.forEach(visitor.visitExpression.bind(visitor))
}
export fn walkNumberLiteral(visitor: Visitor, l: NumberLiteral) {}
export fn walkObjectLiteral(visitor: Visitor, l: ObjectLiteral) {
  l.members.forEach(|m| {
    visitor.visitIdentifier(m.name)
    visitor.visitExpression(m.value)
  })
}
export fn walkStringLiteral(visitor: Visitor, l: StringLiteral) {
  l.parts
    .filter(|p| p.kind == SyntaxKind.Identifier)
    .forEach(visitor.visitIdentifier.bind(visitor))
}
export fn walkTupleLiteral(visitor: Visitor, l: TupleLiteral) {
  l.expressions.forEach(visitor.visitExpression.bind(visitor))
}
