import 'ast.puck' as {
  Module
  TopLevelStatement
  BlockLevelStatement
  Expression

  EnumDeclaration
  EnumMember
  ImplDeclaration
  ImplShorthandDeclaration
  TraitDeclaration

  ExportDirective
  ExportedStatement
  ImportDirective
  ImportSpecifier
  ObjectDestructure
  TypeDeclaration

  Block
  BreakStatement
  ReturnStatement
  ForLoop
  WhileLoop

  Identifier
  FunctionDeclaration
  VariableDeclaration

  AssignmentExpression
  BinaryExpression
  CallExpression
  IfExpression
  IfLetExpression
  MatchExpression
  MatchArm
  TypePathExpression
  TypePath
  UnaryExpression

  IndexAccess
  MemberAccess
  TupleIndexAccess
  UnknownAccess
  UnknownIndexAccess

  BooleanLiteral
  ListLiteral
  NumberLiteral
  RangeLiteral
  RecordLiteral
  RecordLiteralMember
  StringLiteral
  StringLiteralPart
  TupleLiteral

  Pattern
  RecordPattern
  TuplePattern

  TypeBound
  FunctionTypeBound
  NamedTypeBound
  RecordTypeBound
  RecordTypeBoundMember
  TupleTypeBound
  TypeParameter
}
import '../compiler/ast.ts' as {SyntaxKind}

// Comments and Design based on [Rust](https://github.com/rust-lang/rust/blob/86dde9bbda92c02c61282b5df5d38338a798ef3b/src/libsyntax/visit.rs)

//! AST walker. Each overridden visit method has full control over what
//! happens with its node, it can do its own traversal of the node's children,
//! call `visit::walk*` to apply the default traversal algorithm, or prevent
//! deeper traversal by doing nothing.
//!
//! Note: it is an important invariant that the default visitor walks the body
//! of a function in "execution order".
//!
//! Note: walking an AST before macro expansion is probably a bad idea. For
//! instance, a walker looking for item names in a module will miss all of
//! those that are created by the expansion of a macro.

/// Each method of the Visitor trait is a hook to be potentially
/// overridden.  Each method's default implementation recursively visits
/// the substructure of the input via the corresponding `walk` function;
/// e.g. the `visitBlock` method by default calls `walkMod`.
///
/// If you want to ensure that your code handles every variant
/// explicitly, you need to override each method.  (And you also need
/// to monitor future changes to `Visitor` in case a new method with a
/// new default implementation gets introduced.)
export let walkingVisitor = {
  visitModule: |self, m: Module| walkModule(self, m)
  visitTopLevelStatement: |self, e: TopLevelStatement| walkTopLevelStatement(self, e)
  visitBlockLevelStatement: |self, e: BlockLevelStatement| walkBlockLevelStatement(self, e)
  visitExpression: |self, e: Expression| walkExpression(self, e)

  visitEnumDeclaration: |self, e: EnumDeclaration| walkEnumDeclaration(self, e)
  visitEnumMember: |self, e: EnumMember| walkEnumMember(self, e)
  visitImplDeclaration: |self, i: ImplDeclaration| walkImplDeclaration(self, i)
  visitImplShorthandDeclaration: |self, i: ImplShorthandDeclaration| walkImplShorthandDeclaration(self, i)
  visitMethodDeclaration: |self, f: FunctionDeclaration| walkFunctionDeclaration(self, f)
  visitTraitDeclaration: |self, t: TraitDeclaration| walkTraitDeclaration(self, t)
  visitTypeDeclaration: |self, t: TypeDeclaration| walkTypeDeclaration(self, t)

  visitExportDirective: |self, e: ExportDirective| walkExportDirective(self, e)
  visitImportDirective: |self, i: ImportDirective| walkImportDirective(self, i)
  visitObjectDestructure: |self, o: ObjectDestructure| walkObjectDestructure(self, o)

  visitBlock: |self, b: Block| walkBlock(self, b)
  visitBreak: || {}
  visitReturn: |self, r: ReturnStatement| walkReturnStatement(self, r)
  visitForLoop: |self, e: ForLoop| walkForLoop(self, e)
  visitWhileLoop: |self, e: WhileLoop| walkWhileLoop(self, e)

  visitIdentifier: |self, i: Identifier| {}
  visitFunctionDeclaration: |self, f: FunctionDeclaration| walkFunctionDeclaration(self, f)
  visitVariableDeclaration: |self, d: VariableDeclaration| walkVariableDeclaration(self, d)

  visitAssignmentExpression: |self, e: AssignmentExpression| walkAssignmentExpression(self, e)
  visitBinaryExpression: |self, e: BinaryExpression| walkBinaryExpression(self, e)
  visitCallExpression: |self, e: CallExpression| walkCallExpression(self, e)
  visitIfExpression: |self, e: IfExpression| walkIfExpression(self, e)
  visitIfLetExpression: |self, e: IfLetExpression| walkIfLetExpression(self, e)
  visitMatchExpression: |self, e: MatchExpression| walkMatchExpression(self, e)
  visitMatchArm: |self, e: MatchArm| walkMatchArm(self, e)
  visitUnaryExpression: |self, e: UnaryExpression| walkUnaryExpression(self, e)

  visitIndexAccess: |self, a: IndexAccess| walkIndexAccess(self, a)
  visitMemberAccess: |self, a: MemberAccess| walkMemberAccess(self, a)
  visitTupleIndexAccess: |self, a: TupleIndexAccess| walkTupleIndexAccess(self, a)
  visitUnknownAccess: |self, a: UnknownAccess| walkUnknownAccess(self, a)
  visitUnknownIndexAccess: |self, a: UnknownIndexAccess| walkUnknownIndexAccess(self, a)

  visitBooleanLiteral: |self, l: BooleanLiteral| {}
  visitListLiteral: |self, l: ListLiteral| walkListLiteral(self, l)
  visitNumberLiteral: |self, l: NumberLiteral| {}
  visitRangeLiteral: |self, l: RangeLiteral| walkRangeLiteral(self, l)
  visitRecordLiteral: |self, l: RecordLiteral| walkRecordLiteral(self, l)
  visitRecordLiteralMember: |self, l: RecordLiteralMember| walkRecordLiteralMember(self, l)
  visitStringLiteral: |self, l: StringLiteral| walkStringLiteral(self, l)
  visitTupleLiteral: |self, l: TupleLiteral| walkTupleLiteral(self, l)

  visitPattern: |self, p: Pattern| walkPattern(self, p)
  visitIdentifierPattern: |self, p: Identifier| walkIdentifierPattern(self, p)
  visitRecordPattern: |self, p: RecordPattern| walkRecordPattern(self, p)
  visitTuplePattern: |self, p: TuplePattern| walkTuplePattern(self, p)

  visitTypeBound: |self, t: TypeBound| walkTypeBound(self, t)
  visitFunctionTypeBound: |self, t: FunctionTypeBound| walkFunctionTypeBound(self, t)
  visitNamedTypeBound: |self, t: NamedTypeBound| walkNamedTypeBound(self, t)
  visitRecordTypeBound: |self, t: RecordTypeBound| walkRecordTypeBound(self, t)
  visitRecordTypeBoundMember: |self, t: RecordTypeBoundMember| walkRecordTypeBoundMember(self, t)
  visitTupleTypeBound: |self, t: TupleTypeBound| walkTupleTypeBound(self, t)
  visitTypeParameter: |self, t: TypeParameter| walkTypeParameter(self, t)
}

export let emptyVisitor = {
  visitModule: || {}
  visitTopLevelStatement: |self, e: TopLevelStatement| walkTopLevelStatement(self, e)
  visitBlockLevelStatement: |self, e: BlockLevelStatement| walkBlockLevelStatement(self, e)
  visitExpression: |self, e: Expression| walkExpression(self, e)

  visitEnumDeclaration: || {}
  visitEnumMember: || {}
  visitMethodDeclaration: || {}
  visitImplDeclaration: || {}
  visitImplShorthandDeclaration: || {}
  visitTraitDeclaration: || {}
  visitTypeDeclaration: || {}

  visitExportDirective: || {}
  visitImportDirective: || {}
  visitObjectDestructure: || {}

  visitBlock: || {}
  visitBreak: || {}
  visitReturn: || {}
  visitForLoop: || {}
  visitWhileLoop: || {}


  visitIdentifier: || {}
  visitFunctionDeclaration: || {}
  visitVariableDeclaration: || {}

  visitAssignmentExpression: || {}
  visitBinaryExpression: || {}
  visitCallExpression: || {}
  visitIfExpression: || {}
  visitIfLetExpression: || {}
  visitMatchExpression: || {}
  visitMatchArm: || {}
  visitTypePath: || {}
  visitTypePathExpression: || {}
  visitUnaryExpression: || {}

  visitIndexAccess: || {}
  visitMemberAccess: || {}
  visitUnknownAccess: || {}
  visitUnknownIndexAccess: || {}

  visitBooleanLiteral: || {}
  visitListLiteral: || {}
  visitNumberLiteral: || {}
  visitRangeLiteral: || {}
  visitRecordLiteral: || {}
  visitStringLiteral: || {}
  visitTupleLiteral: || {}

  visitPattern: || {}
  visitIdentifierPattern: || {}
  visitRecordPattern: || {}
  visitTuplePattern: || {}
  visitTypeParameter: || {}

  visitTypeBound: |self, t: TypeBound| walkTypeBound(self, t)
  visitFunctionTypeBound: || {}
  visitNamedTypeBound: || {}
  visitRecordTypeBound: || {}
  visitRecordTypeBoundMember: || {}
  visitTupleTypeBound: || {}
}

export fn walkModule(visitor, m: Module) {
  m.statements.forEach(|s| visitor.visitTopLevelStatement(s))
}
export fn walkTopLevelStatement(visitor, s: TopLevelStatement) {
  match s {
    TopLevelStatement::ExportDirective(e) => visitor.visitExportDirective(e)
    TopLevelStatement::ImportDirective(e) => visitor.visitImportDirective(e)

    TopLevelStatement::EnumDeclaration(e) => visitor.visitEnumDeclaration(e)
    TopLevelStatement::ImplDeclaration(e) => visitor.visitImplDeclaration(e)
    TopLevelStatement::ImplShorthandDeclaration(e) => visitor.visitImplShorthandDeclaration(e)
    TopLevelStatement::TraitDeclaration(e) => visitor.visitTraitDeclaration(e)
    TopLevelStatement::TypeDeclaration(e) => visitor.visitTypeDeclaration(e)

    TopLevelStatement::BlockLevelStatement(e) => walkBlockLevelStatement(visitor, e)
  }
}
export fn walkBlockLevelStatement(visitor, s: BlockLevelStatement) {
  match s {
    BlockLevelStatement::Block(e) => visitor.visitBlock(e)
    BlockLevelStatement::BreakStatement(e) => visitor.visitBreak(e)
    BlockLevelStatement::ReturnStatement(e) => visitor.visitReturn(e)
    BlockLevelStatement::ForLoop(e) => visitor.visitForLoop(e)
    BlockLevelStatement::WhileLoop(e) => visitor.visitWhileLoop(e)

    BlockLevelStatement::Expression(e) => walkExpression(visitor, e)
  }
}
export fn walkExpression(visitor, e: Expression) {
  match e {
    Expression::ThrowStatement(e) => visitor.visitExpression(e.expression)
    Expression::Comment(_) => {}

    Expression::Identifier(e) => visitor.visitIdentifier(e)
    Expression::FunctionDeclaration(e) => visitor.visitFunctionDeclaration(e)
    Expression::VariableDeclaration(e) => visitor.visitVariableDeclaration(e)

    Expression::AssignmentExpression(e) => visitor.visitAssignmentExpression(e)
    Expression::BinaryExpression(e) => visitor.visitBinaryExpression(e)
    Expression::CallExpression(e) => visitor.visitCallExpression(e)
    Expression::IfExpression(e) => visitor.visitIfExpression(e)
    Expression::IfLetExpression(e) => visitor.visitIfLetExpression(e)
    Expression::MatchExpression(e) => visitor.visitMatchExpression(e)
    Expression::TypePathExpression(e) => visitor.visitTypePathExpression(e)
    Expression::UnaryExpression(e) => visitor.visitUnaryExpression(e)

    Expression::IndexAccess(e) => visitor.visitIndexAccess(e)
    Expression::MemberAccess(e) => visitor.visitMemberAccess(e)
    Expression::TupleIndexAccess(e) => visitor.visitTupleIndexAccess(e)
    Expression::UnknownAccess(e) => visitor.visitUnknownAccess(e)
    Expression::UnknownIndexAccess(e) => visitor.visitUnknownIndexAccess(e)

    Expression::BooleanLiteral(e) => visitor.visitBooleanLiteral(e)
    Expression::ListLiteral(e) => visitor.visitListLiteral(e)
    Expression::NumberLiteral(e) => visitor.visitNumberLiteral(e)
    Expression::RangeLiteral(e) => visitor.visitRangeLiteral(e)
    Expression::RecordLiteral(e) => visitor.visitRecordLiteral(e)
    Expression::StringLiteral(e) => visitor.visitStringLiteral(e)
    Expression::TupleLiteral(e) => visitor.visitTupleLiteral(e)
  }
}

export fn walkEnumDeclaration(visitor, e: EnumDeclaration) {
  // visitor.visitIdentifier(e.name)
  e.typeParameters.forEach(|t| visitor.visitTypeParameter(t))
  e.members.forEach(|t| visitor.visitEnumMember(t))
}
export fn walkEnumMember(visitor, e: EnumMember) {
  // visitor.visitIdentifier(e.name)
  if let Option::Some(typeBound) = e.bound then visitor.visitTypeBound(typeBound)
}
export fn walkImplDeclaration(visitor, i: ImplDeclaration) {
  i.typeParameters.forEach(visitor.visitTypeParameter.bind(visitor))
  visitor.visitNamedTypeBound(i.trait_)
  visitor.visitNamedTypeBound(i.type_)
  i.members.forEach(visitor.visitFunctionDeclaration.bind(visitor))
}
export fn walkImplShorthandDeclaration(visitor, i: ImplShorthandDeclaration) {
  i.typeParameters.forEach(visitor.visitTypeParameter.bind(visitor))
  visitor.visitNamedTypeBound(i.type_)
  i.members.forEach(visitor.visitFunctionDeclaration.bind(visitor))
}
export fn walkTraitDeclaration(visitor, t: TraitDeclaration) {
  if t.typeParameters
    then t.typeParameters.forEach(visitor.visitTypeParameter.bind(visitor))
  t.members.forEach(|t| visitor.visitFunctionDeclaration(t))
}
export fn walkTypeDeclaration(visitor, t: TypeDeclaration) {
  // visitor.visitIdentifier(t.name)
  t.typeParameters.forEach(|t| visitor.visitTypeParameter(t))
  if let Option::Some(typeBound) = t.bound then visitor.visitTypeBound(typeBound)
}

export fn walkExportDirective(visitor, e: ExportDirective) {
   match e.statement {
    ExportedStatement::EnumDeclaration(d) => visitor.visitEnumDeclaration(d)
    ExportedStatement::FunctionDeclaration(d) => visitor.visitFunctionDeclaration(d)
    ExportedStatement::Identifier(d) => visitor.visitIdentifier(d)
    ExportedStatement::TraitDeclaration(d) => visitor.visitTraitDeclaration(d)
    ExportedStatement::TypeDeclaration(d) => visitor.visitTypeDeclaration(d)
    ExportedStatement::VariableDeclaration(d) => visitor.visitVariableDeclaration(d)
  }
}
export fn walkImportDirective(visitor, i: ImportDirective) {
  match i.specifier {
    ImportSpecifier::Identifier(identifier) => visitor.visitIdentifier(identifier)
    ImportSpecifier::ObjectDestructure(d) => visitor.visitObjectDestructure(d)
    ImportSpecifier::Asterisk => {}
  }
}
export fn walkObjectDestructure(visitor, o: ObjectDestructure) {
  o.members.forEach(|m| {
    visitor.visitIdentifier(m.property)
    visitor.visitIdentifier(m.local)
  })
}

export fn walkBlock(visitor, b: Block) {
  b.statements.forEach(|s| visitor.visitBlockLevelStatement(s))
}
export fn walkReturnStatement(visitor, r: ReturnStatement) {
  visitor.visitExpression(r.expression)
}
export fn walkForLoop(visitor, e: ForLoop) {
  visitor.visitPattern(e.pattern)
  visitor.visitExpression(e.expression)
  visitor.visitBlock(e.body)
}
export fn walkWhileLoop(visitor, e: WhileLoop) {
  visitor.visitExpression(e.condition)
  visitor.visitBlock(e.body)
}

export fn walkFunctionDeclaration(visitor, f: FunctionDeclaration) {
  if f.typeParameters
    then f.typeParameters.forEach(visitor.visitTypeParameter.bind(visitor))
  f.parameterList.forEach(visitor.visitVariableDeclaration.bind(visitor))
  if let Option::Some(returnType) = f.returnType then visitor.visitTypeBound(returnType)
  if let Option::Some(body) = f.body then visitor.visitBlock(body)
}
export fn walkVariableDeclaration(visitor, d: VariableDeclaration) {
  visitor.visitPattern(d.pattern)
  if let Option::Some(typeBound) = d.typeBound then visitor.visitTypeBound(typeBound)
  if let Option::Some(initializer) = d.initializer then visitor.visitExpression(initializer)
}

export fn walkAssignmentExpression(visitor, e: AssignmentExpression) {
  visitor.visitExpression(e.lhs)
  visitor.visitExpression(e.rhs)
}
export fn walkBinaryExpression(visitor, e: BinaryExpression) {
  visitor.visitExpression(e.lhs)
  visitor.visitExpression(e.rhs)
}
export fn walkCallExpression(visitor, e: CallExpression) {
  visitor.visitExpression(e.func)
  e.argumentList.forEach(|e| visitor.visitExpression(e))
}
export fn walkIfExpression(visitor, e: IfExpression) {
  visitor.visitExpression(e.condition)
  visitor.visitBlock(e.then_)
  if let Option::Some(else_) = e.else_ then visitor.visitBlock(else_)
}
export fn walkIfLetExpression(visitor, e: IfLetExpression) {
  visitor.visitPattern(e.pattern)
  visitor.visitExpression(e.expression)
  visitor.visitBlock(e.then_)
  if let Option::Some(else_) = e.else_ then visitor.visitBlock(else_)
}
export fn walkMatchExpression(visitor, e: MatchExpression) {
  visitor.visitExpression(e.expression)
  e.patterns.forEach(|p| visitor.visitMatchArm(p))
}
export fn walkMatchArm(visitor, e: MatchArm) {
  visitor.visitPattern(e.pattern)
  visitor.visitBlock(e.block)
}
export fn walkUnaryExpression(visitor, e: UnaryExpression) {
  visitor.visitExpression(e.rhs)
}

export fn walkIndexAccess(visitor, a: IndexAccess) {
  visitor.visitExpression(a.object)
  visitor.visitExpression(a.index)
}
export fn walkMemberAccess(visitor, a: MemberAccess) {
  visitor.visitExpression(a.object)
  visitor.visitExpression(a.member)
}
export fn walkTupleIndexAccess(visitor, a: TupleIndexAccess) {
  visitor.visitExpression(a.object)
  visitor.visitExpression(a.index)
}
export fn walkUnknownAccess(visitor, a: UnknownAccess) {
  visitor.visitExpression(a.object)
  visitor.visitExpression(a.member)
}
export fn walkUnknownIndexAccess(visitor, a: UnknownIndexAccess) {
  visitor.visitExpression(a.object)
  visitor.visitExpression(a.index)
}

export fn walkListLiteral(visitor, l: ListLiteral) {
  l.members.forEach(|e| visitor.visitExpression(e))
}
export fn walkRangeLiteral(visitor, a: RangeLiteral) {
  visitor.visitExpression(a.start)
  visitor.visitExpression(a.end)
}
export fn walkRecordLiteral(visitor, l: RecordLiteral) {
  l.members.forEach(|m| visitor.visitRecordLiteralMember(m))
}
export fn walkRecordLiteralMember(visitor, l: RecordLiteralMember) {
  match l {
    RecordLiteralMember::Property {name, value} => {
      // visitor.visitIdentifier(name)
      visitor.visitExpression(value)
    }
    RecordLiteralMember::Spread(e) => visitor.visitExpression(e)
  }
}
export fn walkStringLiteral(visitor, l: StringLiteral) {
  l.parts
    .filterMap(|p| match p {
      StringLiteralPart::Identifier(identifier) => Some(identifier)
      _ => None
    })
    .forEach(|i| visitor.visitIdentifier(i))
}
export fn walkTupleLiteral(visitor, l: TupleLiteral) {
  l.expressions.forEach(|e| visitor.visitExpression(e))
}

export fn walkPattern(visitor, p: Pattern) {
  match p {
    Pattern::CatchAll => {}
    Pattern::Identifier {identifier, mutable} => visitor.visitIdentifierPattern(identifier, mutable)
    Pattern::Record(record) => visitor.visitRecordPattern(record)
    Pattern::RecordType(typePath, record) => {
      visitor.visitTypePath(typePath)
      visitor.visitRecordPattern(record)
    }
    Pattern::Tuple(tuple) => visitor.visitTuplePattern(tuple)
    Pattern::TupleType(typePath, tuple) => {
      visitor.visitTypePath(typePath)
      visitor.visitTuplePattern(tuple)
    }
    Pattern::UnitType(typePath) => {
      visitor.visitTypePath(typePath)
    }
  }
}
export fn walkIdentifierPattern(visitor, p: Identifier) {
  // visitor.visitIdentifier(p)
}
export fn walkRecordPattern(visitor, p: RecordPattern) {
  p.properties.forEach(|p| {
    // visitor.visitIdentifier(p.property)
    visitor.visitPattern(p.pattern)
  })
}
export fn walkTuplePattern(visitor, p: TuplePattern) {
  p.properties.forEach(|p| visitor.visitPattern(p))
}

export fn walkTypeBound(visitor, t: TypeBound) {
  match t {
    TypeBound::FunctionTypeBound(t) => visitor.visitFunctionTypeBound(t)
    TypeBound::NamedTypeBound(t) => visitor.visitNamedTypeBound(t)
    TypeBound::RecordTypeBound(t) => visitor.visitRecordTypeBound(t)
    TypeBound::TupleTypeBound(t) => visitor.visitTupleTypeBound(t)
  }
}
export fn walkFunctionTypeBound(visitor, t: FunctionTypeBound) {
  t.typeParameters.forEach(visitor.visitTypeParameter.bind(visitor))
  visitor.visitTupleTypeBound(t.parameters)
  visitor.visitTypeBound(t.returnType)
}
export fn walkNamedTypeBound(visitor, t: NamedTypeBound) {
  t.typeParameters.forEach(visitor.visitTypeBound.bind(visitor))
}
export fn walkRecordTypeBound(visitor, t: RecordTypeBound) {
  t.properties.forEach(|t| visitor.visitRecordTypeBoundMember(t))
}
export fn walkRecordTypeBoundMember(visitor, t: RecordTypeBoundMember) {
  match t {
    RecordTypeBoundMember::Property {name, typeBound} => {
      // visitor.visitIdentifier(name)
      visitor.visitTypeBound(typeBound)
    }
    RecordTypeBoundMember::Spread(t) => visitor.visitTypeBound(t)
  }
}
export fn walkTupleTypeBound(visitor, t: TupleTypeBound) {
  t.properties.forEach(visitor.visitTypeBound.bind(visitor))
}
export fn walkTypeParameter(visitor, t: TypeParameter) {
  // visitor.visitIdentifier(t.name)
  if let Option::Some(defaultValue) = t.defaultValue then visitor.visitTypeBound(defaultValue)
}
