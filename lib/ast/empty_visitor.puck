import 'ast.puck' as {
  Module
  TopLevelStatement
  BlockLevelStatement
  Expression

  EnumDeclaration
  EnumMember
  ImplDeclaration
  ImplShorthandDeclaration
  TraitDeclaration

  ExportDirective
  ExportedStatement
  ImportDirective
  ImportSpecifier
  ObjectDestructure
  ObjectDestructureMember
  TypeDeclaration

  Block
  BreakStatement
  ReturnStatement
  ForLoop
  WhileLoop

  Identifier
  FunctionDeclaration
  VariableDeclaration

  AssignmentExpression
  BinaryExpression
  CallExpression
  IfExpression
  IfLetExpression
  MatchExpression
  MatchArm
  TypePathExpression
  TypePath
  UnaryExpression

  IndexAccess
  MemberAccess
  TupleIndexAccess
  UnknownAccess
  UnknownIndexAccess

  BooleanLiteral
  ListLiteral
  NumberLiteral
  RangeLiteral
  RecordLiteral
  RecordLiteralMember
  StringLiteral
  StringLiteralPart
  TupleLiteral

  Pattern
  RecordPattern
  TuplePattern

  TypeBound
  FunctionTypeBound
  IntersectionTypeBound
  NamedTypeBound
  RecordTypeBound
  RecordTypeBoundMember
  TupleTypeBound
  TypeParameter
}
import 'span.puck' as {
  Position
  Span
  ToSpan
}

/// A visitor that does nothing by default
export trait EmptyVisitor {
  fn visitModule(mut self, mut m: Module) -> () {}
  fn visitTopLevelStatement(mut self, e: TopLevelStatement) -> () {}
  fn visitBlockLevelStatement(mut self, e: BlockLevelStatement) -> () {}
  fn visitExpression(mut self, e: Expression) -> () {}

  fn visitEnumDeclaration(mut self, e: EnumDeclaration) -> () {}
  fn visitEnumMember(mut self, e: EnumMember) -> () {}
  fn visitImplDeclaration(mut self, i: ImplDeclaration) -> () {}
  fn visitImplShorthandDeclaration(mut self, i: ImplShorthandDeclaration) -> () {}
  fn visitMethodDeclaration(mut self, f: FunctionDeclaration) -> () {}
  fn visitTraitDeclaration(mut self, t: TraitDeclaration) -> () {}
  fn visitTypeDeclaration(mut self, t: TypeDeclaration) -> () {}

  fn visitExportDirective(mut self, e: ExportDirective) -> () {}
  fn visitImportDirective(mut self, mut i: ImportDirective) -> () {}
  fn visitObjectDestructure(mut self, o: ObjectDestructure) -> () {}
  fn visitObjectDestructureMember(mut self, m: ObjectDestructureMember) -> () {}

  fn visitBlock(mut self, b: Block) -> () {}
  fn visitBreakStatement(mut self, b: BreakStatement) -> () {}
  fn visitReturnStatement(mut self, r: ReturnStatement) -> () {}
  fn visitForLoop(mut self, e: ForLoop) -> () {}
  fn visitWhileLoop(mut self, e: WhileLoop) -> () {}

  fn visitIdentifier(mut self, i: Identifier) -> () {}
  fn visitFunctionDeclaration(mut self, f: FunctionDeclaration) -> () {}
  fn visitVariableDeclaration(mut self, d: VariableDeclaration) -> () {}

  fn visitAssignmentExpression(mut self, e: AssignmentExpression) -> () {}
  fn visitBinaryExpression(mut self, e: BinaryExpression) -> () {}
  fn visitCallExpression(mut self, e: CallExpression) -> () {}
  fn visitIfExpression(mut self, e: IfExpression) -> () {}
  fn visitIfLetExpression(mut self, e: IfLetExpression) -> () {}
  fn visitMatchExpression(mut self, e: MatchExpression) -> () {}
  fn visitMatchArm(mut self, e: MatchArm) -> () {}
  fn visitTypePath(mut self, e: TypePath) -> () {}
  fn visitTypePathExpression(mut self, e: TypePathExpression) -> () {}
  fn visitUnaryExpression(mut self, e: UnaryExpression) -> () {}
  fn visitIndexAccess(mut self, a: IndexAccess) -> () {}
  fn visitMemberAccess(mut self, a: MemberAccess) -> () {}
  fn visitTupleIndexAccess(mut self, a: TupleIndexAccess) -> () {}
  fn visitUnknownAccess(mut self, a: UnknownAccess) -> () {}
  fn visitUnknownIndexAccess(mut self, a: UnknownIndexAccess) -> () {}
  fn visitListLiteral(mut self, l: ListLiteral) -> () {}
  fn visitBooleanLiteral(mut self, l: BooleanLiteral) -> () {}
  fn visitNumberLiteral(mut self, l: NumberLiteral) -> () {}
  fn visitRangeLiteral(mut self, l: RangeLiteral) -> () {}
  fn visitRecordLiteral(mut self, l: RecordLiteral) -> () {}
  fn visitRecordLiteralMember(mut self, l: RecordLiteralMember) -> () {}
  fn visitStringLiteral(mut self, l: StringLiteral) -> () {}
  fn visitStringLiteralPart(mut self, l: StringLiteralPart) -> () {}
  fn visitTupleLiteral(mut self, l: TupleLiteral) -> () {}

  fn visitPattern(mut self, p: Pattern) -> () {}
  fn visitIdentifierPattern(mut self, p: Identifier, mutable: Bool) -> () {}
  fn visitRecordPattern(mut self, p: RecordPattern) -> () {}
  fn visitRecordTypePattern(mut self, t: TypePath, p: RecordPattern) -> () {}
  fn visitTuplePattern(mut self, p: TuplePattern) -> () {}
  fn visitTupleTypePattern(mut self, t: TypePath, p: TuplePattern) -> () {}

  fn visitTypeBound(mut self, t: TypeBound) -> () {}
  fn visitFunctionTypeBound(mut self, t: FunctionTypeBound) -> () {}
  fn visitIntersectionTypeBound(mut self, t: IntersectionTypeBound) -> () {}
  fn visitNamedTypeBound(mut self, t: NamedTypeBound) -> () {}
  fn visitRecordTypeBound(mut self, t: RecordTypeBound) -> () {}
  fn visitRecordTypeBoundMember(mut self, t: RecordTypeBoundMember) -> () {}
  fn visitTupleTypeBound(mut self, t: TupleTypeBound) -> () {}
  fn visitTypeParameter(mut self, t: TypeParameter) -> () {}
}

export fn walkModule(mut visitor: EmptyVisitor, m: Module) {
  m.statements.forEach(|s| visitor.visitTopLevelStatement(s))
}
export fn walkTopLevelStatement(mut visitor: EmptyVisitor, s: TopLevelStatement) {
  match s {
    TopLevelStatement::ExportDirective(e) => visitor.visitExportDirective(e)
    TopLevelStatement::ImportDirective(mut e) => visitor.visitImportDirective(e)

    TopLevelStatement::EnumDeclaration(e) => visitor.visitEnumDeclaration(e)
    TopLevelStatement::ImplDeclaration(e) => visitor.visitImplDeclaration(e)
    TopLevelStatement::ImplShorthandDeclaration(e) => visitor.visitImplShorthandDeclaration(e)
    TopLevelStatement::TraitDeclaration(e) => visitor.visitTraitDeclaration(e)
    TopLevelStatement::TypeDeclaration(e) => visitor.visitTypeDeclaration(e)

    TopLevelStatement::BlockLevelStatement(e) => walkBlockLevelStatement(visitor, e)
  }
}
export fn walkBlockLevelStatement(mut visitor: EmptyVisitor, s: BlockLevelStatement) {
  match s {
    BlockLevelStatement::Block(e) => visitor.visitBlock(e)
    BlockLevelStatement::BreakStatement(e) => visitor.visitBreakStatement(e)
    BlockLevelStatement::ReturnStatement(e) => visitor.visitReturnStatement(e)
    BlockLevelStatement::ForLoop(e) => visitor.visitForLoop(e)
    BlockLevelStatement::WhileLoop(e) => visitor.visitWhileLoop(e)

    BlockLevelStatement::Expression(e) => walkExpression(visitor, e)
  }
}
export fn walkExpression(mut visitor: EmptyVisitor, e: Expression) {
  match e {
    Expression::Comment(_) => {}

    Expression::Identifier(e) => visitor.visitIdentifier(e)
    Expression::FunctionDeclaration(e) => visitor.visitFunctionDeclaration(e)
    Expression::VariableDeclaration(e) => visitor.visitVariableDeclaration(e)

    Expression::AssignmentExpression(e) => visitor.visitAssignmentExpression(e)
    Expression::BinaryExpression(e) => visitor.visitBinaryExpression(e)
    Expression::CallExpression(e) => visitor.visitCallExpression(e)
    Expression::IfExpression(e) => visitor.visitIfExpression(e)
    Expression::IfLetExpression(e) => visitor.visitIfLetExpression(e)
    Expression::MatchExpression(e) => visitor.visitMatchExpression(e)
    Expression::TypePathExpression(e) => visitor.visitTypePathExpression(e)
    Expression::UnaryExpression(e) => visitor.visitUnaryExpression(e)

    Expression::IndexAccess(e) => visitor.visitIndexAccess(e)
    Expression::MemberAccess(e) => visitor.visitMemberAccess(e)
    Expression::TupleIndexAccess(e) => visitor.visitTupleIndexAccess(e)
    Expression::UnknownAccess(e) => visitor.visitUnknownAccess(e)
    Expression::UnknownIndexAccess(e) => visitor.visitUnknownIndexAccess(e)

    Expression::BooleanLiteral(e) => visitor.visitBooleanLiteral(e)
    Expression::ListLiteral(e) => visitor.visitListLiteral(e)
    Expression::NumberLiteral(e) => visitor.visitNumberLiteral(e)
    Expression::RangeLiteral(e) => visitor.visitRangeLiteral(e)
    Expression::RecordLiteral(e) => visitor.visitRecordLiteral(e)
    Expression::StringLiteral(e) => visitor.visitStringLiteral(e)
    Expression::TupleLiteral(e) => visitor.visitTupleLiteral(e)
  }
}

export fn walkEnumDeclaration(mut visitor: EmptyVisitor, e: EnumDeclaration) {
  // visitor.visitIdentifier(e.name)
  e.typeParameters.forEach(|t| visitor.visitTypeParameter(t))
  e.members.forEach(|t| visitor.visitEnumMember(t))
}
export fn walkEnumMember(mut visitor: EmptyVisitor, e: EnumMember) {
  // visitor.visitIdentifier(e.name)
  if let Option::Some(typeBound) = e.bound then visitor.visitTypeBound(typeBound)
}
export fn walkImplDeclaration(mut visitor: EmptyVisitor, i: ImplDeclaration) {
  i.typeParameters.forEach(|p| visitor.visitTypeParameter(p))
  visitor.visitNamedTypeBound(i.trait_)
  visitor.visitNamedTypeBound(i.type_)
  i.members.forEach(|m| visitor.visitFunctionDeclaration(m))
}
export fn walkImplShorthandDeclaration(mut visitor: EmptyVisitor, i: ImplShorthandDeclaration) {
  i.typeParameters.forEach(|p| visitor.visitTypeParameter(p))
  visitor.visitNamedTypeBound(i.type_)
  i.members.forEach(|m| visitor.visitFunctionDeclaration(m))
}
export fn walkTraitDeclaration(mut visitor: EmptyVisitor, t: TraitDeclaration) {
  if t.typeParameters
    then t.typeParameters.forEach(|p| visitor.visitTypeParameter(p))
  t.members.forEach(|t| visitor.visitFunctionDeclaration(t))
}
export fn walkTypeDeclaration(mut visitor: EmptyVisitor, t: TypeDeclaration) {
  // visitor.visitIdentifier(t.name)
  t.typeParameters.forEach(|t| visitor.visitTypeParameter(t))
  if let Option::Some(typeBound) = t.bound then visitor.visitTypeBound(typeBound)
}

export fn walkExportDirective(mut visitor: EmptyVisitor, e: ExportDirective) {
   match e.statement {
    ExportedStatement::EnumDeclaration(d) => visitor.visitEnumDeclaration(d)
    ExportedStatement::FunctionDeclaration(d) => visitor.visitFunctionDeclaration(d)
    ExportedStatement::Identifier(d) => visitor.visitIdentifier(d)
    ExportedStatement::TraitDeclaration(d) => visitor.visitTraitDeclaration(d)
    ExportedStatement::TypeDeclaration(d) => visitor.visitTypeDeclaration(d)
    ExportedStatement::VariableDeclaration(d) => visitor.visitVariableDeclaration(d)
  }
}
export fn walkImportDirective(mut visitor: EmptyVisitor, i: ImportDirective) {
  match i.specifier {
    ImportSpecifier::Identifier(identifier) => visitor.visitIdentifier(identifier)
    ImportSpecifier::ObjectDestructure(d) => visitor.visitObjectDestructure(d)
    ImportSpecifier::Asterisk => {}
  }
}
export fn walkObjectDestructure(mut visitor: EmptyVisitor, o: ObjectDestructure) {
  o.members.forEach(|m| {
    visitor.visitIdentifier(m.property)
    visitor.visitIdentifier(m.local)
  })
}

export fn walkBlock(mut visitor: EmptyVisitor, b: Block) {
  b.statements.forEach(|s| visitor.visitBlockLevelStatement(s))
}
export fn walkReturnStatement(mut visitor: EmptyVisitor, r: ReturnStatement) {
  visitor.visitExpression(r.expression)
}
export fn walkForLoop(mut visitor: EmptyVisitor, e: ForLoop) {
  visitor.visitPattern(e.pattern)
  visitor.visitExpression(e.expression)
  visitor.visitBlock(e.body)
}
export fn walkWhileLoop(mut visitor: EmptyVisitor, e: WhileLoop) {
  visitor.visitExpression(e.condition)
  visitor.visitBlock(e.body)
}

export fn walkFunctionDeclaration(mut visitor: EmptyVisitor, f: FunctionDeclaration) {
  if f.typeParameters
    then f.typeParameters.forEach(|p| visitor.visitTypeParameter(p))
  f.parameterList.forEach(|p| visitor.visitVariableDeclaration(p))
  if let Option::Some(returnType) = f.returnType then visitor.visitTypeBound(returnType)
  if let Option::Some(body) = f.body then visitor.visitBlock(body)
}
export fn walkVariableDeclaration(mut visitor: EmptyVisitor, d: VariableDeclaration) {
  visitor.visitPattern(d.pattern)
  if let Option::Some(typeBound) = d.typeBound then visitor.visitTypeBound(typeBound)
  if let Option::Some(initializer) = d.initializer then visitor.visitExpression(initializer)
}

export fn walkAssignmentExpression(mut visitor: EmptyVisitor, e: AssignmentExpression) {
  visitor.visitExpression(e.lhs)
  visitor.visitExpression(e.rhs)
}
export fn walkBinaryExpression(mut visitor: EmptyVisitor, e: BinaryExpression) {
  visitor.visitExpression(e.lhs)
  visitor.visitExpression(e.rhs)
}
export fn walkCallExpression(mut visitor: EmptyVisitor, e: CallExpression) {
  visitor.visitExpression(e.func)
  e.argumentList.forEach(|e| visitor.visitExpression(e))
}
export fn walkIfExpression(mut visitor: EmptyVisitor, e: IfExpression) {
  visitor.visitExpression(e.condition)
  visitor.visitBlock(e.then_)
  if let Option::Some(else_) = e.else_ then visitor.visitBlock(else_)
}
export fn walkIfLetExpression(mut visitor: EmptyVisitor, e: IfLetExpression) {
  visitor.visitPattern(e.pattern)
  visitor.visitExpression(e.expression)
  visitor.visitBlock(e.then_)
  if let Option::Some(else_) = e.else_ then visitor.visitBlock(else_)
}
export fn walkMatchExpression(mut visitor: EmptyVisitor, e: MatchExpression) {
  visitor.visitExpression(e.expression)
  e.patterns.forEach(|p| visitor.visitMatchArm(p))
}
export fn walkMatchArm(mut visitor: EmptyVisitor, e: MatchArm) {
  visitor.visitPattern(e.pattern)
  visitor.visitBlock(e.block)
}
export fn walkUnaryExpression(mut visitor: EmptyVisitor, e: UnaryExpression) {
  visitor.visitExpression(e.rhs)
}

export fn walkIndexAccess(mut visitor: EmptyVisitor, a: IndexAccess) {
  visitor.visitExpression(a.object)
  visitor.visitExpression(a.index)
}
export fn walkMemberAccess(mut visitor: EmptyVisitor, a: MemberAccess) {
  visitor.visitExpression(a.object)
}
export fn walkTupleIndexAccess(mut visitor: EmptyVisitor, a: TupleIndexAccess) {
  visitor.visitExpression(a.object)
}
export fn walkUnknownAccess(mut visitor: EmptyVisitor, a: UnknownAccess) {
  visitor.visitExpression(a.object)
}
export fn walkUnknownIndexAccess(mut visitor: EmptyVisitor, a: UnknownIndexAccess) {
  visitor.visitExpression(a.object)
  visitor.visitExpression(a.index)
}

export fn walkListLiteral(mut visitor: EmptyVisitor, l: ListLiteral) {
  l.members.forEach(|e| visitor.visitExpression(e))
}
export fn walkRangeLiteral(mut visitor: EmptyVisitor, a: RangeLiteral) {
  visitor.visitExpression(a.start)
  visitor.visitExpression(a.end)
}
export fn walkRecordLiteral(mut visitor: EmptyVisitor, l: RecordLiteral) {
  l.members.forEach(|m| visitor.visitRecordLiteralMember(m))
}
export fn walkRecordLiteralMember(mut visitor: EmptyVisitor, l: RecordLiteralMember) {
  match l {
    RecordLiteralMember::Property {name, value} => {
      // visitor.visitIdentifier(name)
      visitor.visitExpression(value)
    }
    RecordLiteralMember::Spread(e) => visitor.visitExpression(e)
  }
}
export fn walkStringLiteral(mut visitor: EmptyVisitor, l: StringLiteral) {
  l.parts
    .filterMap(|p| match p {
      StringLiteralPart::Identifier(identifier) => Some(identifier)
      _ => None
    })
    .forEach(|i| visitor.visitIdentifier(i))
}
export fn walkTupleLiteral(mut visitor: EmptyVisitor, l: TupleLiteral) {
  l.expressions.forEach(|e| visitor.visitExpression(e))
}

export fn walkPattern(mut visitor: EmptyVisitor, p: Pattern) {
  match p {
    Pattern::CatchAll => {}
    Pattern::Identifier {identifier, mutable} => visitor.visitIdentifierPattern(identifier, mutable)
    Pattern::Record(record) => visitor.visitRecordPattern(record)
    Pattern::RecordType(typePath, record) => {
      visitor.visitTypePath(typePath)
      visitor.visitRecordPattern(record)
    }
    Pattern::Tuple(tuple) => visitor.visitTuplePattern(tuple)
    Pattern::TupleType(typePath, tuple) => {
      visitor.visitTypePath(typePath)
      visitor.visitTuplePattern(tuple)
    }
    Pattern::UnitType(typePath) => {
      visitor.visitTypePath(typePath)
    }
  }
}
export fn walkIdentifierPattern(mut visitor: EmptyVisitor, p: Identifier) {
  // visitor.visitIdentifier(p)
}
export fn walkRecordPattern(mut visitor: EmptyVisitor, p: RecordPattern) {
  p.properties.forEach(|p| {
    // visitor.visitIdentifier(p.property)
    visitor.visitPattern(p.pattern)
  })
}
export fn walkTuplePattern(mut visitor: EmptyVisitor, p: TuplePattern) {
  p.properties.forEach(|p| visitor.visitPattern(p))
}

export fn walkTypeBound(mut visitor: EmptyVisitor, t: TypeBound) {
  match t {
    TypeBound::FunctionTypeBound(t) => visitor.visitFunctionTypeBound(t)
    TypeBound::IntersectionTypeBound(t) => visitor.visitIntersectionTypeBound(t)
    TypeBound::NamedTypeBound(t) => visitor.visitNamedTypeBound(t)
    TypeBound::RecordTypeBound(t) => visitor.visitRecordTypeBound(t)
    TypeBound::TupleTypeBound(t) => visitor.visitTupleTypeBound(t)
  }
}
export fn walkFunctionTypeBound(mut visitor: EmptyVisitor, t: FunctionTypeBound) {
  t.typeParameters.forEach(|p| visitor.visitTypeParameter(p))
  visitor.visitTupleTypeBound(t.parameters)
  visitor.visitTypeBound(t.returnType)
}
export fn walkNamedTypeBound(mut visitor: EmptyVisitor, t: NamedTypeBound) {
  t.typeParameters.forEach(|p| visitor.visitTypeBound(p))
}
export fn walkRecordTypeBound(mut visitor: EmptyVisitor, t: RecordTypeBound) {
  t.properties.forEach(|t| visitor.visitRecordTypeBoundMember(t))
}
export fn walkRecordTypeBoundMember(mut visitor: EmptyVisitor, t: RecordTypeBoundMember) {
  match t {
    RecordTypeBoundMember::Property {name, typeBound} => {
      // visitor.visitIdentifier(name)
      visitor.visitTypeBound(typeBound)
    }
    RecordTypeBoundMember::Spread(t) => visitor.visitTypeBound(t)
  }
}
export fn walkTupleTypeBound(mut visitor: EmptyVisitor, t: TupleTypeBound) {
  t.properties.forEach(|p| visitor.visitTypeBound(p))
}
export fn walkTypeParameter(mut visitor: EmptyVisitor, t: TypeParameter) {
  // visitor.visitIdentifier(t.name)
  if let Option::Some(defaultValue) = t.defaultValue then visitor.visitTypeBound(defaultValue)
}
