import 'puck:js' as {Array, asResult, console, process}
import 'node:child_process' as {execSync}
import 'node:fs' as fs
import 'node:path' as path
import 'ast/ast.puck' as {Token}
import 'compiler/ast.ts' as {SyntaxKind}

export fn cmd(cmd) {
  let result: Result<String, {}> = asResult(fn () {
    execSync(
      cmd
      {
        cwd: process.cwd()
        shell: '/bin/bash'
        env: {
          BASHOPTS: 'globstar:extglob'
          PATH: process.env.PATH
        }
      }
    )
  })

  match result {
    Result::Ok(output) => {
      if output.toString()
        then console.log(output.toString().trim())
    }
    Result::Err(error) => {
      let stdout = error.stdout.toString()
      let stderr = error.stderr.toString()
      if stdout then console.log(stdout.trim())
      if stderr then console.error(stderr.trim())
      if error.stack then console.error(error.stack)
      process.exit(1)
    }
  }
}

/// Recursively and synchronously list all files in [directory]
export fn walkSync(directory, mut filelist = []) {
  if not fs.existsSync(directory) or not fs.statSync(directory).isDirectory()
    then return []
  let mut files = fs.readdirSync(directory)

  files.forEach(|fileName| {
    let file = path.join(directory, fileName)
    if fs.statSync(file).isDirectory()
      then walkSync(file, filelist)
      else filelist.push(file)
  })

  filelist
}

export fn flag(arguments, name, defaultValue = '') {
  let index = arguments.indexOf(name)
  if index >= 0 {
    let value = arguments[index + 1]
    arguments.splice(index, 2)
    value
  } else defaultValue
}

export fn isTypeScopeDeclaration(t: Token) {
  t.kind == SyntaxKind.TraitDeclaration or
  t.kind == SyntaxKind.TypeDeclaration
}
