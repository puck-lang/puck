import 'puck:js' as {RegExp, global, null, undefined}
import 'ast.ts' as {SyntaxKind, operators, textToToken}

export fn TokenStream(input) {
  let mut current = null
  let mut currentDummy = null
  let mut inImport = false

  let longestOperator = operators.reduce(fn (longest, curr) {
    if curr.length > longest then curr.length else longest
  }, 0)

  fn tryParseOperator() {
    let mut length = 0
    let mut searchString = ''
    let mut found

    while length < longestOperator {
      let ch = input.peek(length)
      if isWhitespaceOrNewline(ch) then break
      searchString += ch

      let hasMatches = operators
        .filter(fn (token) {
          if token.length < length
            then false
            else token.substr(0, length + 1) == searchString
        })
        .length > 0

      if hasMatches {
        length += 1
        found = searchString
      }
      else break
    }

    if textToToken[found] {
      let mut i = 0
      while i < length {
        input.next()
        i += 1
      }
      {kind: textToToken[found]}
    }
  }

  fn isDigit(ch) {
    // /[0-9]/i.test(ch)
    RegExp('[0-9]').test(ch)
  }

  fn isIdStart(ch) {
    // /[a-z_]/i.test(ch)
    RegExp('[a-z_]', 'i').test(ch)
  }

  fn isId(ch) {
    isIdStart(ch) or isDigit(ch)
  }

  fn isNewline(ch) {
    ch == '\n'
  }

  fn isWhitespace(ch) {
    ' \t'.indexOf(ch) >= 0
  }

  fn isWhitespaceOrNewline(ch) {
    isNewline(ch) or isWhitespace(ch)
  }

  fn readWhile(predicate) {
    let mut str = ''
    while not input.eof() and predicate(input.peek()) {
      str += input.next()
    }
    str
  }

  fn readNumber() {
    let mut hasDot = false
    let number = readWhile(fn (ch) {
      if ch == '.' {
        if hasDot or not isDigit(input.peek(1))
          then false
          else {
            hasDot = true
            true
          }
      } else isDigit(ch)
    })

    {kind: SyntaxKind.NumberLiteral, value: global.parseFloat(number)}
  }

  fn readIdent() {
    let id = readWhile(isId)
    if id == 'import' {
      inImport = true
      {kind: SyntaxKind.ImportKeyword}
    }
    else if id == 'as' {
      inImport = false
      {kind: SyntaxKind.AsKeyword}
    }
    else if textToToken[id] != undefined then {kind: textToToken[id]}
    else {{
      kind: SyntaxKind.Identifier,
      name: id,
    }}
  }

  fn readString() {
    let mut escaped = false
    let mut parts = []
    let mut str = ''

    let delimiter = input.next()

    while not input.eof() {
      let ch = input.next()
      if escaped {
        if ch == '$' then str += '$'
        else if ch == 'n' then str += '\n'
        else if ch == 'r' then str += '\r'
        else if ch == 't' then str += '\t'
        else if ch == '\'' then str += '\''
        else if ch == '\"' then str += '\"'
        else if ch == '\\' then str += '\\'
        else if ch == '\n' then null
        else input.croak('Invalid escape character $ch')
        escaped = false
      }
      else if ch == '\\' then escaped = true
      else if ch == '$' and isIdStart(input.peek()) and not inImport {
        parts.push({kind: SyntaxKind.StringLiteralPart, value: str})
        parts.push(readIdent())
        str = ''
      }
      else if ch == delimiter then break
      else str += ch
    }
    parts.push({kind: SyntaxKind.StringLiteralPart, value: str})

    {kind: SyntaxKind.StringLiteral, parts}
  }

  fn readComment() {
    input.next()
    input.next()
    readWhile(isWhitespace)
    let comment = readWhile(fn (ch) {ch != '\n'})
    input.next()

    {
      kind: SyntaxKind.Comment,
      text: comment,
    }
  }

  fn readNext() {
    readWhile(isWhitespace)
    if input.eof() then return null

    let ch = input.peek()
    if isNewline(ch) {
      input.next()
      return {kind: SyntaxKind.NewlineToken}
    }
    if ch == '/' and input.peek(1) == '/' then return readComment()
    if ch == '\'' or ch == '"' then return readString()
    if isDigit(ch) then return readNumber()
    if isIdStart(ch) then return readIdent()
    let operator = tryParseOperator()
    if not operator then input.croak('Unexpected token: $ch')
    operator
  }

  fn isDummy(token) {
    if not token then return false

    token.kind == SyntaxKind.NewlineToken
      or token.kind == SyntaxKind.Comment
  }

  fn peek(returnDummy = false) {
    if returnDummy and currentDummy then return currentDummy
    if current then
      if returnDummy or not isDummy(current) then return current

    current = readNext()
    currentDummy = current

    while isDummy(current) and not returnDummy {
      current = readNext()
    }

    current
  }

  fn next(returnDummy) {
    if currentDummy {
      let token = currentDummy
      currentDummy = null

      if returnDummy then return token
    }
    if current {
      let token = current
      current = null

      if returnDummy or not isDummy(token) then return token
    }

    let mut token = readNext()

    while isDummy(token) and not returnDummy {
      token = readNext()
    }
    token
  }

  fn eof() {
    peek() == null
  }

  {next, peek, eof, croak: input.croak, file: input.file}
}
