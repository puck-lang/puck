import 'puck:js' as {RegExp, global, null, undefined}
import '../ast/ast.puck' as {
  Token
  Comment
  NumberLiteral
  StringLiteral
  StringLiteralPart
}
import '../ast/span.puck' as {Span}
import 'ast.ts' as {SyntaxKind, operators, textToToken}

export fn TokenStream(input) {
  let mut current = null
  let mut currentDummy = null
  let mut inImport = false

  let longestOperator = operators.reduce(fn (longest, curr) {
    if curr.length > longest then curr.length else longest
  }, 0)

  fn tryParseOperator() -> Option<Token> {
    let mut length = 0
    let mut searchString = ''
    let mut found

    while length < longestOperator {
      let ch = input.peek(length)
      if isWhitespaceOrNewline(ch) then break
      searchString += ch

      let hasMatches = operators
        .filter(fn (token) {
          if token.length < length
            then false
            else token.substr(0, length + 1) == searchString
        })
        .length > 0

      if hasMatches {
        length += 1
        found = searchString
      }
      else break
    }

    if textToToken[found] {
      let start = input.getPosition()
      let mut i = 0
      while i < length {
        input.next()
        i += 1
      }
      let end = input.getPosition()
      Some({kind: textToToken[found], span: {start, end}})
    }
    else None
  }

  fn isDigit(ch) {
    RegExp('[0-9]').test(ch)
  }

  fn isIdStart(ch) {
    RegExp('[a-z_]', 'i').test(ch)
  }

  fn isId(ch) {
    isIdStart(ch) or isDigit(ch)
  }

  fn isNewline(ch) {
    ch == '\n'
  }

  fn isWhitespace(ch) {
    ' \t'.indexOf(ch) >= 0
  }

  fn isWhitespaceOrNewline(ch) {
    isNewline(ch) or isWhitespace(ch)
  }

  fn readWhile(predicate) {
    let mut str = ''
    while not input.eof() and predicate(input.peek()) {
      str += input.next()
    }
    str
  }

  fn readNumber() -> NumberLiteral {
    let mut hasDot = false
    let start = input.getPosition()
    let number = readWhile(fn (ch) {
      if ch == '.' {
        if hasDot or not isDigit(input.peek(1))
          then false
          else {
            hasDot = true
            true
          }
      }
      else isDigit(ch)
    })
    let end = input.getPosition()

    {
      kind: SyntaxKind.NumberLiteral
      span: {start, end}
      value: global.parseFloat(number)
    }
  }

  fn readIdentifier() {
    let start = input.getPosition()
    let id = readWhile(isId)
    let end = input.getPosition()
    {
      kind: SyntaxKind.Identifier
      span: {start, end}
      name: id
    }
  }

  fn readIdentifierOrKeyword() {
    let start = input.getPosition()
    let id = readWhile(isId)
    let end = input.getPosition()
    let span = {start, end}
    if id == 'import' {
      inImport = true
      {kind: SyntaxKind.ImportKeyword, span}
    }
    else if id == 'as' {
      inImport = false
      {kind: SyntaxKind.AsKeyword, span}
    }
    else if textToToken[id] != undefined then {kind: textToToken[id], span}
    else {{
      kind: SyntaxKind.Identifier
      span
      name: id
    }}
  }

  fn readString() -> StringLiteral {
    let mut escaped = false
    let mut parts = []
    let mut str = ''

    let mut start = input.getPosition()
    let delimiter = input.next()

    while not input.eof() {
      let ch = input.next()
      if escaped {
        if ch == '$' then str += '$'
        else if ch == 'n' then str += '\n'
        else if ch == 'r' then str += '\r'
        else if ch == 't' then str += '\t'
        else if ch == '\'' then str += '\''
        else if ch == '\"' then str += '\"'
        else if ch == '\\' then str += '\\'
        else if ch == '\n' then null
        else input.croak('Invalid escape character $ch')
        escaped = false
      }
      else if ch == '\\' then escaped = true
      else if ch == '$' and isIdStart(input.peek()) and not inImport {
        let end = input.getPosition()
        parts.push(StringLiteralPart::Literal({span: {start, end}, value: str}))
        parts.push(StringLiteralPart::Identifier(readIdentifier()))
        str = ''
        start = input.getPosition()
      }
      else if ch == delimiter then break
      else str += ch
    }
    let end = input.getPosition()
    parts.push(StringLiteralPart::Literal({span: {start, end}, value: str}))

    {kind: SyntaxKind.StringLiteral, parts}
  }

  fn readComment() -> Comment {
    let start = input.getPosition()
    input.next()
    input.next()
    readWhile(isWhitespace)
    let comment = readWhile(fn (ch) {ch != '\n'})
    input.next()
    let end = input.getPosition()

    {
      kind: SyntaxKind.Comment
      span: {start, end}
      text: comment
    }
  }

  fn readNext() {
    readWhile(isWhitespace)
    if input.eof() then return null

    let ch = input.peek()
    if isNewline(ch) {
      input.next()
      return {kind: SyntaxKind.NewlineToken}
    }
    if ch == '/' and input.peek(1) == '/' then return readComment()
    if ch == '\'' or ch == '"' then return readString()
    if isDigit(ch) then return readNumber()
    if isIdStart(ch) then return readIdentifierOrKeyword()

    if let Option::Some(operator) = tryParseOperator()
      then operator
      else input.croak('Unexpected token: $ch')
  }

  fn isDummy(token) {
    if not token then return false

    token.kind == SyntaxKind.NewlineToken
      or token.kind == SyntaxKind.Comment
  }

  fn peek(returnDummy = false) {
    if returnDummy and currentDummy then return currentDummy
    if current and not isDummy(current) or returnDummy then return current

    current = readNext()
    currentDummy = current

    while not returnDummy and isDummy(current) {
      current = readNext()
    }

    current
  }

  fn next(returnDummy) {
    if currentDummy {
      let token = currentDummy
      currentDummy = null

      if returnDummy then return token
    }
    if current {
      let token = current
      current = null

      if returnDummy or not isDummy(token) then return token
    }

    let mut token = readNext()

    while isDummy(token) and not returnDummy {
      token = readNext()
    }
    token
  }

  fn eof() {
    peek() == null
  }

  {next, peek, eof, croak: input.croak, file: input.file}
}
