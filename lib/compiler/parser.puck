import 'puck:js' as {Error, Object, global, null, typeof, undefined}
import '../ast/ast.puck' as {
  Module
  TopLevelStatement
  BlockLevelStatement
  Expression
  SimpleLiteral
  Attribute
  AttributeData

  EnumDeclaration
  EnumMember
  ImplDeclaration
  ImplShorthandDeclaration
  TraitDeclaration
  TypeDeclaration

  ExportDirective
  ExportedStatement
  ImportDirective
  ImportSpecifier
  ObjectDestructure
  ObjectDestructureMember

  Block
  ReturnStatement
  ForLoop
  WhileLoop

  Identifier
  FunctionDeclaration
  VariableDeclaration

  AssignmentExpression
  BinaryExpression
  CallExpression
  IfExpression
  IfLetExpression
  MatchExpression
  MatchArm
  TypePathExpression
  TypePath
  UnaryExpression

  IndexAccess
  MemberAccess
  TupleIndexAccess

  BooleanLiteral
  ListLiteral
  NumberLiteral
  RecordLiteral
  RecordLiteralMember
  StringLiteral
  StringLiteralPart
  TupleLiteral

  Pattern
  RecordPattern
  RecordPatternMember
  TuplePattern

  TypeBound
  FunctionTypeBound
  NamedTypeBound
  RecordTypeBound
  RecordTypeBoundMember
  TupleTypeBound
  TypeParameter
}
import '../ast/span.puck' as {Span, ToSpan}
import '../ast/token.puck' as {SyntaxKind, SimpleToken, Token}
import '../entities.puck' as {File}
import 'token_stream.puck' as {TokenStream}

fn isAssignment(token: SimpleToken) -> Bool {
  match token.kind {
    SyntaxKind::EqualsToken => true
    SyntaxKind::PlusEqualsToken => true
    SyntaxKind::MinusEqualsToken => true
    SyntaxKind::AsteriskEqualsToken => true
    SyntaxKind::AsteriskAsteriskEqualsToken => true
    SyntaxKind::SlashEqualsToken => true
    SyntaxKind::PercentEqualsToken => true
    _ => false
  }
}

fn isAssignable(expression: Expression) {
  match expression {
    Expression::Identifier(_) => true
    Expression::MemberAccess(_) => true
    Expression::IndexAccess(_) => true
    Expression::UnknownAccess(_) => true
    Expression::UnknownIndexAccess(_) => true
    _ => false
  }
}

export fn parse(mut input: TokenStream, file: File, recover = false) {

  fn isToken(kind: SyntaxKind, withDummy = false) -> Bool {
    match input.peek(withDummy) {
      Token::SimpleToken(token) => identical(token.kind, kind)
      _ => false
    }
  }

  fn butGot() {
    let token =
    match input.peek() {
      Token::SimpleToken({kind: SyntaxKind::EndOfFileToken}) => 'but reached end of file'
      token => 'but got "' ++ token.name() ++ '"'
    }
  }

  fn expect(kind: SyntaxKind) -> SimpleToken {
    let token = input.peek()
    match token {
      Token::SimpleToken(token) => {
        if not identical(token.kind, kind) {
          input.croak('Expected token: "' ++ kind.name() ++ '", ' ++ butGot())
        }
        token
      }
      _ => input.croak('Expected token: "' ++ kind.name() ++ '", ' ++ butGot())
    }
  }

  fn consumeToken(kind: SyntaxKind) -> SimpleToken {
    let token = expect(kind)
    input.next()
    token
  }

  fn consumeIdentifier() -> Identifier {
    if recover {
      match input.peek() {
        Token::SimpleToken({span}) => return {name: '', span}
        _ => {}
      }
    }
    match input.next() {
      Token::Identifier(identifier) => identifier
      _ => input.croak('Expected identifier, ' ++ butGot())
    }
  }

  fn maybeConsumeToken(kind: SyntaxKind) -> Option<SimpleToken> {
    if isToken(kind)
      then Some(consumeToken(kind))
      else None
  }

  fn unexpected() {
    let name = input.peek().name()
    input.croak('Unexpected token: $name')
  }

  fn attributeNotSupported() {
    input.croak('Attributes are only supported on enum, trait and type declarations')
  }

  fn consumeSeparator(kind: SyntaxKind) -> () {
    let mut token = input.peek(true)

    match token {
      Token::SimpleToken({kind: SyntaxKind::NewlineToken}) => input.next(true)
      Token::Comment => input.next(true)
      _ => consumeToken(kind)
    }
  }

  /// Creates a false block, used for recovery
  fn mockBlock() {
    {
      openBrace: None
      statements: [
        BlockLevelStatement::Expression(Expression::Identifier(consumeIdentifier()))
      ]
      closeBrace: None
      type_: undefined
    }
  }

  fn maybeParseOperator() -> Option<SimpleToken> {
    match input.peek() {
      Token::SimpleToken(token) => match token.kind {
        SyntaxKind::EqualsEqualsToken => Some(token)
        SyntaxKind::ExclamationEqualsToken => Some(token)
        SyntaxKind::GreaterThanToken => Some(token)
        SyntaxKind::GreaterThanEqualsToken => Some(token)
        SyntaxKind::LessThanToken => Some(token)
        SyntaxKind::LessThanEqualsToken => Some(token)
        SyntaxKind::PlusToken => Some(token)
        SyntaxKind::PlusPlusToken => Some(token)
        SyntaxKind::MinusToken => Some(token)
        SyntaxKind::AsteriskToken => Some(token)
        SyntaxKind::AsteriskAsteriskToken => Some(token)
        SyntaxKind::SlashToken => Some(token)
        SyntaxKind::PercentToken => Some(token)
        SyntaxKind::AndKeyword => Some(token)
        SyntaxKind::OrKeyword => Some(token)
        SyntaxKind::NotKeyword => Some(token)
        _ => if isAssignment(token)
          then Some(token)
          else None
      }
      _ => None
    }
  }

  fn maybeBinary(left: Expression, myPrecedence: Num) -> Expression {
    if let Some(operator) = maybeParseOperator() {
      let mut hisPrecedence = operator.kind.precedence()

      if (hisPrecedence > myPrecedence) {
        input.next()
        let mut innerExpression = maybeBinary(parseAtom(), hisPrecedence)
        let e =
          if isAssignment(operator) {
            if not isAssignable(left) then input.croak('Can only assign to an identifier')

            Expression::AssignmentExpression({
              lhs: left,
              token: operator,
              rhs: innerExpression,
            })
          }
          else {
            Expression::BinaryExpression({
              lhs: left
              operator
              rhs: innerExpression
            })
          }
        return maybeBinary(e, myPrecedence)
      }
    }
    left
  }

  fn maybeCall(expression: Expression) -> Expression {
    if isToken(SyntaxKind::ColonColonLessThanToken)
      then maybeCall(maybeAccess(Expression::CallExpression({
        func: expression
        typeArguments: Some({
          openBracket: expect(SyntaxKind::ColonColonLessThanToken)
          typeArguments: delimited(SyntaxKind::ColonColonLessThanToken, SyntaxKind::GreaterThanToken, SyntaxKind::CommaToken, parseTypeBound, false)
          closeBracket: consumeToken(SyntaxKind::GreaterThanToken)
        })
        openParen: expect(SyntaxKind::OpenParenToken)
        argumentList: delimited(SyntaxKind::OpenParenToken, SyntaxKind::CloseParenToken, SyntaxKind::CommaToken, parseExpression, false)
        closeParen: consumeToken(SyntaxKind::CloseParenToken)
      })))
    else if isToken(SyntaxKind::OpenParenToken, true)
      then maybeCall(maybeAccess(Expression::CallExpression({
        func: expression
        typeArguments: None
        openParen: expect(SyntaxKind::OpenParenToken)
        argumentList: delimited(SyntaxKind::OpenParenToken, SyntaxKind::CloseParenToken, SyntaxKind::CommaToken, parseExpression, false)
        closeParen: consumeToken(SyntaxKind::CloseParenToken)
      })))
    else expression
  }

  fn maybeAccess(expression: Expression) -> Expression {
    maybeUnknownAccess(maybeIndexAccess(maybeMemberAccess(expression)))
  }

  fn maybeMemberAccess(expression: Expression) -> Expression {
    if isToken(SyntaxKind::DotToken) {
      let dotToken = consumeToken(SyntaxKind::DotToken)
      let token = input.peek()
      maybeAccess(
        match token {
          Token::NumberLiteral(index) => {
            input.next()
            Expression::TupleIndexAccess({
              object: expression
              dotToken
              index
            })
          }
          Token::Identifier(identifier) => {
            input.next()
            Expression::MemberAccess({
              object: expression
              dotToken
              member: identifier
            })
          }
          _ => {
            if recover {
              Expression::MemberAccess({
                object: expression
                dotToken
                member: {name: '', span: token.span()}
              })
            } else {
              input.next()
              input.croak('Expected number or identifier, ' ++ butGot())
            }
          }
        }
      )
    }
    else expression
  }

  fn maybeIndexAccess(expression: Expression) -> Expression {
    if isToken(SyntaxKind::OpenBracketToken, true) {
      let openBracket = consumeToken(SyntaxKind::OpenBracketToken)
      let index = parseExpression()
      let closeBracket = consumeToken(SyntaxKind::CloseBracketToken)

      maybeAccess(Expression::IndexAccess({
        object: expression
        openBracket
        index
        closeBracket
      }))
    }
    else expression
  }

  fn maybeUnknownAccess(expression: Expression) -> Expression {
    if isToken(SyntaxKind::MinusGreaterThanToken) {
      input.next()
      if isToken(SyntaxKind::OpenBracketToken) {
        let openBracket = consumeToken(SyntaxKind::OpenBracketToken)
        let index = parseExpression()
        let closeBracket = consumeToken(SyntaxKind::CloseBracketToken)

        maybeAccess(Expression::UnknownIndexAccess({
          object: expression
          openBracket
          index
          closeBracket
        }))
      }
      else {
      maybeAccess(Expression::UnknownAccess({
        object: expression
        member: consumeIdentifier()
      }))
      }
    }
    else expression
  }

  fn maybeRangeLiteral(expression: Expression) -> Expression {
    if isToken(SyntaxKind::DotDotToken) {
      let dotDotToken = consumeToken(SyntaxKind::DotDotToken)
      let end = parseExpression()

      Expression::RangeLiteral({
        start: expression
        dotDotToken
        end
      })
    }
    else expression
  }

  fn delimited<T>(start: SyntaxKind, stop: SyntaxKind, separator: SyntaxKind, parser: () -> T, consumeStop: Bool) -> List<T> {
    let mut parts = []
    let mut first = true
    consumeToken(start)

    while not input.eof() {
      if isToken(stop) then break

      if first then first = false
      else consumeSeparator(separator)

      let mut part
      while not part {
        if isToken(stop) then break
        part = parser()
      }

      if part then parts.push(part)
    }

    if consumeStop then consumeToken(stop)
    parts
  }

  fn parseModule() -> Module {
    let mut exports = {}
    let mut statements = []
    while not input.eof() {
      let statement = parseTopLevelStatement()
      statements.push(statement)
      if let TopLevelStatement::ExportDirective(e) = statement
        then exports[e.identifier.name] = e

      consumeSeparator(SyntaxKind::SemicolonToken)
    }

    {
      fileName: file.fileName
      path: file.absolutePath
      exports
      statements
      file
      scope: undefined
    }
  }

  fn parseTopLevelStatement() {
    match input.peek() {
      Token::SimpleToken(token) => match token.kind {
        SyntaxKind::HashToken => parseDeclarationWithAttribute()
        SyntaxKind::EnumKeyword => TopLevelStatement::EnumDeclaration(parseEnumDeclaration())
        SyntaxKind::ExportKeyword => TopLevelStatement::ExportDirective(parseExport())
        SyntaxKind::ImplKeyword => parseImplDeclaration()
        SyntaxKind::ImportKeyword => TopLevelStatement::ImportDirective(parseImport())
        SyntaxKind::TraitKeyword => TopLevelStatement::TraitDeclaration(parseTraitDeclaration())
        SyntaxKind::TypeKeyword => TopLevelStatement::TypeDeclaration(parseTypeDeclaration())
        _ => TopLevelStatement::BlockLevelStatement(parseBlockLevelStatement())
      }
      _ => TopLevelStatement::BlockLevelStatement(parseBlockLevelStatement())
    }
  }

  fn parseBlockLevelStatement() {
    match input.peek() {
      Token::SimpleToken({kind: SyntaxKind::BreakKeyword}) => {
        BlockLevelStatement::BreakStatement({keyword: consumeToken(SyntaxKind::BreakKeyword)})
      }
      Token::SimpleToken({kind: SyntaxKind::ReturnKeyword}) => {
        BlockLevelStatement::ReturnStatement({
          keyword: consumeToken(SyntaxKind::ReturnKeyword)
          expression: parseExpression()
        })
      }
      Token::SimpleToken({kind: SyntaxKind::ForKeyword}) => {
        BlockLevelStatement::ForLoop(parseFor())
      }
      Token::SimpleToken({kind: SyntaxKind::WhileKeyword}) => {
        BlockLevelStatement::WhileLoop(parseWhile())
      }
      _ => BlockLevelStatement::Expression(parseExpression())
    }
  }

  fn parseExpression(precedence = 0, forceTuple = false) -> Expression {
    maybeRangeLiteral(maybeCall(maybeAccess(maybeBinary(parseAtom(forceTuple), precedence))))
  }

  fn parseAtom(forceTuple = false) -> Expression {
    maybeCall(
      match input.peek() {
        Token::SimpleToken(token) => match token.kind {
          SyntaxKind::OpenParenToken => parseTupleOrExpression(forceTuple)
          SyntaxKind::OpenBracketToken => Expression::ListLiteral(parseListLiteral())
          SyntaxKind::OpenBraceToken => Expression::RecordLiteral(parseRecordLiteral())
          SyntaxKind::BarToken => Expression::FunctionDeclaration(parseLambda())
          SyntaxKind::IfKeyword => parseIf()
          SyntaxKind::MatchKeyword => Expression::MatchExpression(parseMatch())
          SyntaxKind::FnKeyword => Expression::FunctionDeclaration(parseFunctionDeclaration())
          SyntaxKind::LetKeyword => {
            input.next()
            Expression::VariableDeclaration(parseVariableDeclaration())
          }
          SyntaxKind::NotKeyword => Expression::UnaryExpression(parseUnaryExpression())
          SyntaxKind::MinusToken => Expression::UnaryExpression(parseUnaryExpression())
          SyntaxKind::PlusToken => Expression::UnaryExpression(parseUnaryExpression())
          SyntaxKind::ThrowKeyword => {
            input.next()
            Expression::ThrowStatement({
              expression: parseExpression()
            })
          }
          SyntaxKind::TrueKeyword => {
            maybeAccess(Expression::BooleanLiteral({
              keyword: consumeToken(SyntaxKind::TrueKeyword)
              value: true
            }))
          }
          SyntaxKind::FalseKeyword => {
            maybeAccess(Expression::BooleanLiteral({
              keyword: consumeToken(SyntaxKind::FalseKeyword)
              value: false
            }))
          }
          _ => {
            if recover
              then Expression::Identifier(consumeIdentifier())
              else unexpected()
          }
        }
        Token::NumberLiteral(numberLiteral) => {
          input.next()
          maybeAccess(Expression::NumberLiteral(numberLiteral))
        }
        Token::StringLiteral(stringLiteral) => {
          input.next()
          maybeAccess(Expression::StringLiteral(stringLiteral))
        }
        Token::Identifier(identifier) => parseIdentifierOrTypePath()
        Token::Comment => unexpected()
      }
    )
  }

  fn parseSimpleLiteral() {
    match input.next() {
      Token::SimpleToken(token) => match token.kind {
        SyntaxKind::TrueKeyword => {
          SimpleLiteral::BooleanLiteral({
            keyword: token
            value: true
          })
        }
        SyntaxKind::FalseKeyword => {
          SimpleLiteral::BooleanLiteral({
            keyword: token
            value: false
          })
        }
        _ => unexpected()
      }
      Token::NumberLiteral(numberLiteral) => SimpleLiteral::NumberLiteral(numberLiteral)
      Token::StringLiteral(stringLiteral) => {
        if stringLiteral.parts.size() > 1 {
          input.croak('Attributes can only contain simple string literals. Interpolation is not supported.')
        }
        match stringLiteral.parts[0] {
          StringLiteralPart::Literal(literal) => SimpleLiteral::StringLiteral(literal)
          _ => panic('String literal does not start with a literal')
        }
      }
      _ => unexpected()
    }
  }

  fn parseAttributeArgument() {
    let name = consumeIdentifier()
    let value = maybeConsumeToken(SyntaxKind::EqualsToken).map(|_| parseSimpleLiteral())

    {name, value}
  }

  fn parseAttribute() {
    let hashToken = consumeToken(SyntaxKind::HashToken)
    let openBracket = consumeToken(SyntaxKind::OpenBracketToken)
    let name = consumeIdentifier()
    let data =
      if maybeConsumeToken(SyntaxKind::EqualsToken).isSome()
        then AttributeData::Value(parseSimpleLiteral())
      else if isToken(SyntaxKind::OpenParenToken)
        then AttributeData::Arguments(delimited(SyntaxKind::OpenParenToken, SyntaxKind::CloseParenToken, SyntaxKind::CommaToken, parseAttributeArgument, true))
      else AttributeData::None
    let closeBracket = consumeToken(SyntaxKind::CloseBracketToken)

    {hashToken, openBracket, name, data, closeBracket}
  }

  fn parseDeclarationWithAttribute() {
    let mut attributes = []
    while isToken(SyntaxKind::HashToken) {
      attributes.push(parseAttribute())
    }

    if isToken(SyntaxKind::EnumKeyword) then TopLevelStatement::EnumDeclaration(parseEnumDeclaration(attributes))
    else if isToken(SyntaxKind::ExportKeyword) then TopLevelStatement::ExportDirective(parseExport(attributes))
    else if isToken(SyntaxKind::TraitKeyword) then TopLevelStatement::TraitDeclaration(parseTraitDeclaration(attributes))
    else if isToken(SyntaxKind::TypeKeyword) then TopLevelStatement::TypeDeclaration(parseTypeDeclaration(attributes))
    else attributeNotSupported()
  }

  fn parseEnumDeclaration(attributes: List<Attribute> = []) -> EnumDeclaration {
    let keyword = consumeToken(SyntaxKind::EnumKeyword)
    let name = consumeIdentifier()
    let typeParameters =
      if isToken(SyntaxKind::LessThanToken)
        then delimited(SyntaxKind::LessThanToken, SyntaxKind::GreaterThanToken, SyntaxKind::CommaToken, parseTypeParameter, true)
        else []

    let openBrace = expect(SyntaxKind::OpenBraceToken)
    let members = delimited(SyntaxKind::OpenBraceToken, SyntaxKind::CloseBraceToken, SyntaxKind::CommaToken, parseEnumMember, false)
    let closeBrace = consumeToken(SyntaxKind::CloseBraceToken)

    {
      attributes
      keyword
      name
      typeParameters
      openBrace
      members
      closeBrace
    }
  }

  fn parseEnumMember() -> EnumMember {
    let name = consumeIdentifier()

    let bound =
      if isToken(SyntaxKind::OpenBraceToken)
        then Some(parseRecordTypeBound())
      else if isToken(SyntaxKind::OpenParenToken)
        then Some(parseTupleTypeBound())
      else None

    {
      name
      bound
    }
  }

  fn parseImplDeclaration() -> TopLevelStatement {
    let implKeyword = consumeToken(SyntaxKind::ImplKeyword)
    let typeParameters =
      if isToken(SyntaxKind::LessThanToken)
        then delimited(SyntaxKind::LessThanToken, SyntaxKind::GreaterThanToken, SyntaxKind::CommaToken, parseTypeParameter, true)
      else []

    let trait_ = parseNamedTypeBound()
    let {forKeyword, type_}: {forKeyword: Option<SimpleToken>, type_: Option<NamedTypeBound>} =
      if isToken(SyntaxKind::ForKeyword)
        then {
          forKeyword: Some(consumeToken(SyntaxKind::ForKeyword))
          type_: Some(parseNamedTypeBound())
        }
        else {{
          forKeyword: None
          type_: None
        }}

    let openBrace = expect(SyntaxKind::OpenBraceToken)
    let members = delimited(SyntaxKind::OpenBraceToken, SyntaxKind::CloseBraceToken, SyntaxKind::SemicolonToken, parseFunctionDeclaration, false)
      .toList()
    let closeBrace = consumeToken(SyntaxKind::CloseBraceToken)

    if let Option::Some(type_) = type_
      then TopLevelStatement::ImplDeclaration({
        implKeyword
        typeParameters
        trait_
        forKeyword: forKeyword.unwrap()
        type_
        openBrace
        members
        closeBrace
      })
      else TopLevelStatement::ImplShorthandDeclaration({
        implKeyword
        typeParameters
        type_: trait_
        openBrace
        members
        closeBrace
      })
  }

  fn parseTraitDeclaration(attributes: List<Attribute> = []) -> TraitDeclaration {
    let keyword = consumeToken(SyntaxKind::TraitKeyword)
    let name = consumeIdentifier()
    let typeParameters =
      if isToken(SyntaxKind::LessThanToken)
        then delimited(SyntaxKind::LessThanToken, SyntaxKind::GreaterThanToken, SyntaxKind::CommaToken, parseTypeParameter, true)
      else []

    let openBrace = expect(SyntaxKind::OpenBraceToken)
    let members = delimited(SyntaxKind::OpenBraceToken, SyntaxKind::CloseBraceToken, SyntaxKind::SemicolonToken, || parseFunctionDeclaration(true), false)
      .toList()
    let closeBrace = consumeToken(SyntaxKind::CloseBraceToken)

    {
      attributes
      keyword
      name
      typeParameters
      openBrace
      members
      closeBrace
    }
  }

  fn parseTypeDeclaration(attributes: List<Attribute> = []) -> TypeDeclaration {
    let keyword = consumeToken(SyntaxKind::TypeKeyword)
    let name = consumeIdentifier()
    let typeParameters =
      if isToken(SyntaxKind::LessThanToken)
        then delimited(SyntaxKind::LessThanToken, SyntaxKind::GreaterThanToken, SyntaxKind::CommaToken, parseTypeParameter, true)
        else []

    let bound =
      if isToken(SyntaxKind::OpenBraceToken)
        then Some(parseRecordTypeBound())
      else if isToken(SyntaxKind::OpenParenToken)
        then Some(parseTupleTypeBound())
      else None

    {
      attributes
      keyword
      name
      typeParameters
      bound
      type_: undefined
    }
  }

  fn parseExport(attributes: List<Attribute> = []) -> ExportDirective {
    let keyword = consumeToken(SyntaxKind::ExportKeyword)
    let mut statement: ExportedStatement
    let mut identifier: Identifier

    if isToken(SyntaxKind::EnumKeyword) {
      let enumDeclaration = parseEnumDeclaration(attributes)
      statement = ExportedStatement::EnumDeclaration(enumDeclaration)
      identifier = enumDeclaration.name
    }
    else if isToken(SyntaxKind::TraitKeyword) {
      let traitDeclaration = parseTraitDeclaration(attributes)
      statement = ExportedStatement::TraitDeclaration(traitDeclaration)
      identifier = traitDeclaration.name
    }
    else if isToken(SyntaxKind::TypeKeyword) {
      let typeDeclaration = parseTypeDeclaration(attributes)
      statement = ExportedStatement::TypeDeclaration(typeDeclaration)
      identifier = typeDeclaration.name
    }
    else if attributes.isEmpty() {
      if isToken(SyntaxKind::FnKeyword) {
        let functionDeclaration = parseFunctionDeclaration()
        statement = ExportedStatement::FunctionDeclaration(functionDeclaration)
        if let Option::Some(name) = functionDeclaration.name {
          identifier = name
        }
        else input.croak('Can not export function without a name')
      }
      else if isToken(SyntaxKind::LetKeyword) {
        input.next()
        let variableDeclaration = parseVariableDeclaration()
        statement = ExportedStatement::VariableDeclaration(variableDeclaration)
        if let Pattern::Identifier {identifier: name} = variableDeclaration.pattern {
          identifier = name
        }
        else input.croak('Can not export a let declaration without a identifier pattern')
      }
      else if let Token::Identifier(_) = input.peek() {
        identifier = consumeIdentifier()
        statement = ExportedStatement::Identifier(identifier)
      }
      else input.croak('Expected trait, type, function or variable declaration after export')
    }
    else attributeNotSupported()

    {
      keyword
      identifier
      statement
    }
  }

  fn parseImport() -> ImportDirective {
    let importKeyword = consumeToken(SyntaxKind::ImportKeyword)

    let locator =
      match input.next() {
        Token::StringLiteral(stringLiteral) => stringLiteral
        _ => input.croak('Expected string, ' ++ butGot())
      }
    if locator.parts.size() != 1 then panic('More than one part in import string')
    let parts = match locator.parts.first() {
      Some(StringLiteralPart::Literal({value})) => value.split(':')
      _ => panic('String literal does not start with a literal')
    }
    if parts.size() > 2 then input.croak('Illegal token ":" used in import path')
    let domain = if parts.size() == 2 then Some(parts[0]) else None
    let path = if parts.size() == 2 then parts[1] else parts[0]

    if recover and not isToken(SyntaxKind::AsKeyword) {
      return {
        importKeyword
        locator
        domain
        path
        asKeyword: {kind: SyntaxKind::AsKeyword, span: Span.empty()}
        specifier: ImportSpecifier::Identifier(consumeIdentifier())

        module: None
      }
    }

    let asKeyword = consumeToken(SyntaxKind::AsKeyword)
    let specifier =
      if isToken(SyntaxKind::OpenBraceToken)
        then ImportSpecifier::ObjectDestructure(parseObjectDestructure())
      else if isToken(SyntaxKind::AsteriskToken)
        then ImportSpecifier::Asterisk(consumeToken(SyntaxKind::AsteriskToken))
      else ImportSpecifier::Identifier(consumeIdentifier())

    {
      importKeyword
      locator
      domain
      path
      asKeyword
      specifier

      module: None
    }
  }

  fn parseObjectDestructure() -> ObjectDestructure {
    let openBrace = expect(SyntaxKind::OpenBraceToken)
    let members = delimited(SyntaxKind::OpenBraceToken, SyntaxKind::CloseBraceToken, SyntaxKind::CommaToken, parseObjectDestructureMember, false)
    let closeBrace = consumeToken(SyntaxKind::CloseBraceToken)

    {
      openBrace
      members
      closeBrace
    }
  }

  fn parseObjectDestructureMember() -> ObjectDestructureMember {
    let property = consumeIdentifier()
    let local =
      if isToken(SyntaxKind::ColonToken) {
        input.next()
        consumeIdentifier()
      }
      else property

    {
      property
      local
      file: None
    }
  }

  fn parseBlock() -> Block {
    let openBrace = Some(expect(SyntaxKind::OpenBraceToken))
    let statements = delimited(SyntaxKind::OpenBraceToken, SyntaxKind::CloseBraceToken, SyntaxKind::SemicolonToken, parseBlockLevelStatement, false)
    let closeBrace = Some(consumeToken(SyntaxKind::CloseBraceToken))

    {
      openBrace
      statements
      closeBrace
      type_: undefined
    }
  }

  fn parseFor() -> ForLoop {
    let forKeyword = consumeToken(SyntaxKind::ForKeyword)
    let pattern = parsePattern()
    let ofKeyword = consumeToken(SyntaxKind::OfKeyword)
    let expression = parseExpression()
    let body = parseBlock()

    {
      forKeyword
      pattern
      ofKeyword
      expression
      body
    }
  }

  fn parseWhile() -> WhileLoop {
    let keyword = consumeToken(SyntaxKind::WhileKeyword)
    let condition = parseExpression()
    let body = parseBlock()

    {
      keyword
      condition
      body
    }
  }

  fn parseIdentifierOrTypePath() -> Expression {
    let identifier = consumeIdentifier()
    if isToken(SyntaxKind::ColonColonToken)
      then Expression::TypePathExpression({
        typePath: parseTypePath(Some(identifier))
      })
      else maybeAccess(Expression::Identifier(identifier))
  }

  fn parseFunctionDeclaration(optionalBody = false) -> FunctionDeclaration {
    if not recover or isToken(SyntaxKind::FnKeyword)
      then consumeToken(SyntaxKind::FnKeyword)
    let name =
      match input.peek() {
        Token::Identifier(identifier) => {
          input.next()
          Some(identifier)
        }
        _ => None
      }
    let typeParameters =
      if isToken(SyntaxKind::LessThanToken)
        then delimited(SyntaxKind::LessThanToken, SyntaxKind::GreaterThanToken, SyntaxKind::CommaToken, parseTypeParameter, true)
        else []
    if recover and not isToken(SyntaxKind::OpenParenToken) {
      return {
        name
        typeParameters
        openParenOrBar: {kind: SyntaxKind::OpenParenToken, span: Span.empty()}
        parameterList: []
        closeParenOrBar: {kind: SyntaxKind::OpenParenToken, span: Span.empty()}
        returnType: None
        body: Some(mockBlock())
        type_: undefined
      }
    }
    let openParenOrBar = expect(SyntaxKind::OpenParenToken)
    let parameterList = delimited(SyntaxKind::OpenParenToken, SyntaxKind::CloseParenToken, SyntaxKind::CommaToken, parseVariableDeclaration, false)
    let closeParenOrBar = consumeToken(SyntaxKind::CloseParenToken)

    let returnType =
      if maybeConsumeToken(SyntaxKind::MinusGreaterThanToken).isSome()
        then Some(parseTypeBound())
        else None

    let body =
      if recover and not isToken(SyntaxKind::OpenBraceToken) and (not optionalBody or returnType.isNone())
        then Some(mockBlock())
      else if isToken(SyntaxKind::OpenBraceToken) or not optionalBody
        then Some(parseBlock())
      else None

    {
      name
      typeParameters
      openParenOrBar
      parameterList
      closeParenOrBar
      returnType
      body
      type_: undefined
    }
  }

  fn parseLambda() -> FunctionDeclaration {
    let openParenOrBar = expect(SyntaxKind::BarToken)
    let parameterList = delimited(SyntaxKind::BarToken, SyntaxKind::BarToken, SyntaxKind::CommaToken, parseVariableDeclaration, false)
    let closeParenOrBar = consumeToken(SyntaxKind::BarToken)

    let body =
      if isToken(SyntaxKind::OpenBraceToken)
        then Some(parseBlock())
        else Some({
          openBrace: None
          statements: [parseBlockLevelStatement()]
          closeBrace: None
          type_: undefined
        })

    {
      name: None
      typeParameters: []
      openParenOrBar
      parameterList
      closeParenOrBar
      returnType: None
      body
      type_: undefined
    }
  }

  fn parseVariableDeclaration() -> VariableDeclaration {
    let pattern = parsePattern()

    {
      pattern
      typeBound: maybeConsumeToken(SyntaxKind::ColonToken).map(|_| parseTypeBound())
      initializer: maybeConsumeToken(SyntaxKind::EqualsToken).map(|_| parseExpression())
    }
  }

  fn parseIf() -> Expression {
    let ifKeyword = consumeToken(SyntaxKind::IfKeyword)

    if isToken(SyntaxKind::LetKeyword)
      then Expression::IfLetExpression(parseIfLetExpression(ifKeyword))
      else Expression::IfExpression(parseIfExpression(ifKeyword))
  }

  fn parseIfExpression(ifKeyword: SimpleToken) -> IfExpression {
    let condition = parseExpression()

    let then_: Block =
      if isToken(SyntaxKind::OpenBraceToken)
        then parseBlock()
      else if recover and not isToken(SyntaxKind::ThenKeyword)
        then mockBlock()
      else {
        consumeToken(SyntaxKind::ThenKeyword)
        {
          openBrace: None
          statements: [parseBlockLevelStatement()]
          closeBrace: None
          type_: undefined
        }
      }

    {
      ifKeyword
      condition
      then_
      else_:
        if isToken(SyntaxKind::ElseKeyword) {
          input.next()
          Some(
            if isToken(SyntaxKind::OpenBraceToken)
              then parseBlock()
              else ({
                openBrace: None
                statements: [parseBlockLevelStatement()]
                closeBrace: None
                type_: undefined
              })
          )
        }
        else None
    }
  }

  fn parseIfLetExpression(ifKeyword: SimpleToken) -> IfLetExpression {
    let letKeyword = consumeToken(SyntaxKind::LetKeyword)
    let pattern = parsePattern()
    let equalsToken = consumeToken(SyntaxKind::EqualsToken)
    let expression = parseExpression()

    let then_: Block =
      if isToken(SyntaxKind::OpenBraceToken)
        then parseBlock()
      else if recover and not isToken(SyntaxKind::ThenKeyword)
        then mockBlock()
      else {
        consumeToken(SyntaxKind::ThenKeyword)
        {
          openBrace: None
          statements: [parseBlockLevelStatement()]
          closeBrace: None
          type_: undefined
        }
      }

    {
      ifKeyword
      letKeyword
      pattern
      expression
      then_
      else_:
        if isToken(SyntaxKind::ElseKeyword) {
          input.next()
          Some(
            if isToken(SyntaxKind::OpenBraceToken)
              then parseBlock()
              else ({
                openBrace: None
                statements: [parseBlockLevelStatement()]
                closeBrace: None
                type_: undefined
              })
          )
        }
        else None
    }
  }

  fn parseMatch() -> MatchExpression {
    let matchKeyword = consumeToken(SyntaxKind::MatchKeyword)
    let expression = parseExpression()

    if recover and not isToken(SyntaxKind::OpenBraceToken) {
      return {
        matchKeyword
        expression
        openBrace: {kind: SyntaxKind::OpenBraceToken, span: Span.empty()}
        patterns: []
        closeBrace: {kind: SyntaxKind::OpenBraceToken, span: Span.empty()}
      }
    }

    {
      matchKeyword
      expression
      openBrace: expect(SyntaxKind::OpenBraceToken)
      patterns: delimited(SyntaxKind::OpenBraceToken, SyntaxKind::CloseBraceToken, SyntaxKind::CommaToken, parseMatchArm, false)
      closeBrace: consumeToken(SyntaxKind::CloseBraceToken)
    }
  }

  fn parseMatchArm() -> MatchArm {
    let pattern = parsePattern()
    if recover and not isToken(SyntaxKind::EqualsGreaterThanToken) {
      return {
        pattern
        arrow: {kind: SyntaxKind::EqualsGreaterThanToken, span: Span.empty()}
        block: mockBlock()
      }
    }
    let arrow = consumeToken(SyntaxKind::EqualsGreaterThanToken)
    let block =
      if isToken(SyntaxKind::OpenBraceToken)
        then parseBlock()
        else {{
          openBrace: None
          statements: [parseBlockLevelStatement()]
          closeBrace: None
          type_: undefined
        }}
    {
      pattern
      arrow
      block
    }
  }

  fn parseUnaryExpression() -> UnaryExpression {
    match input.next() {
      Token::SimpleToken(operator) => match operator.kind {
        SyntaxKind::NotKeyword => {
          {operator, rhs: parseExpression(operator.kind.precedence())}
        }
        SyntaxKind::MinusToken => {
          {operator, rhs: parseExpression(operator.kind.precedence())}
        }
        SyntaxKind::PlusToken => {
          {operator, rhs: parseExpression(operator.kind.precedence())}
        }
        _ => unexpected()
      }
      _ => unexpected()
    }
  }

  fn parseListLiteral() -> ListLiteral {
    let openBracket = expect(SyntaxKind::OpenBracketToken)
    let members = delimited(SyntaxKind::OpenBracketToken, SyntaxKind::CloseBracketToken, SyntaxKind::CommaToken, parseExpression, false)
    let closeBracket = consumeToken(SyntaxKind::CloseBracketToken)

    {
      openBracket
      members
      closeBracket
    }
  }

  fn parseRecordLiteral() -> RecordLiteral {
    let openBrace = expect(SyntaxKind::OpenBraceToken)
    let members = delimited(SyntaxKind::OpenBraceToken, SyntaxKind::CloseBraceToken, SyntaxKind::CommaToken, parseRecordLiteralMember, false)
    let closeBrace = consumeToken(SyntaxKind::CloseBraceToken)
    {
      openBrace
      members
      closeBrace
    }
  }

  fn parseRecordLiteralMember() -> RecordLiteralMember {
    if maybeConsumeToken(SyntaxKind::DotDotDotToken).isSome()
      then RecordLiteralMember::Spread(parseExpression())
      else {
        let name = consumeIdentifier()
        let value =
          if isToken(SyntaxKind::ColonToken) {
            input.next()
            parseExpression()
          }
          else Expression::Identifier(name)

        RecordLiteralMember::Property({
          name
          value
        })
      }
  }

  fn parseTupleOrExpression(forceTuple) {
    let openParen = expect(SyntaxKind::OpenParenToken)
    let expressions = delimited(SyntaxKind::OpenParenToken, SyntaxKind::CloseParenToken, SyntaxKind::CommaToken, || parseExpression(0, true), false)
    let closeParen = consumeToken(SyntaxKind::CloseParenToken)

    if not forceTuple and expressions.size() == 1
      then expressions[0]
      else Expression::TupleLiteral({
        openParen
        expressions
        closeParen
      })
  }

  fn parsePattern() -> Pattern {
    if let Option::Some(token) = maybeConsumeToken(SyntaxKind::UnderscoreToken)
      then Pattern::CatchAll(token)
    else if isToken(SyntaxKind::OpenParenToken)
      then Pattern::Tuple(parseTuplePattern())
    else if isToken(SyntaxKind::OpenBraceToken)
      then Pattern::Record(parseRecordPattern())
    else if isToken(SyntaxKind::MutKeyword) {
      consumeToken(SyntaxKind::MutKeyword)
      let identifier = consumeIdentifier()
      Pattern::Identifier({identifier, mutable: true})
    }
    else {
      let identifier = consumeIdentifier()

      if isToken(SyntaxKind::ColonColonToken)
      or isToken(SyntaxKind::OpenParenToken)
      or isToken(SyntaxKind::OpenBraceToken) {
        let typePath = parseTypePath(Some(identifier))

        if isToken(SyntaxKind::OpenParenToken)
          then Pattern::TupleType(typePath, parseTuplePattern())
        else if isToken(SyntaxKind::OpenBraceToken)
          then Pattern::RecordType(typePath, parseRecordPattern())
        else Pattern::UnitType(typePath)
      }
      else Pattern::Identifier({identifier, mutable: false})
    }
  }

  fn parseRecordPattern() -> RecordPattern {
    let openBrace = expect(SyntaxKind::OpenBraceToken)
    let properties = delimited(SyntaxKind::OpenBraceToken, SyntaxKind::CloseBraceToken, SyntaxKind::CommaToken, parseRecordPatternMember, false)
    let closeBrace = consumeToken(SyntaxKind::CloseBraceToken)

    {openBrace, properties, closeBrace}
  }

  fn parseRecordPatternMember() -> RecordPatternMember {
    let property = consumeIdentifier()
    let pattern =
      if maybeConsumeToken(SyntaxKind::ColonToken).isSome()
        then parsePattern()
        else Pattern::Identifier({identifier: property, mutable: false})

    {property, pattern}
  }

  fn parseTuplePattern() -> TuplePattern {
    let openParen = expect(SyntaxKind::OpenParenToken)
    let properties = delimited(SyntaxKind::OpenParenToken, SyntaxKind::CloseParenToken, SyntaxKind::CommaToken, parsePattern, false)
    let closeParen = consumeToken(SyntaxKind::CloseParenToken)

    {openParen, properties, closeParen}
  }

  fn parseTypeBound() -> TypeBound {
    maybeParseIntersectionTypeBound(
      if isToken(SyntaxKind::LessThanToken)
        then parseFunctionTypeBound(None)
      else if isToken(SyntaxKind::OpenParenToken) {
        let tuple = parseTupleTypeBound()
        if isToken(SyntaxKind::MinusGreaterThanToken)
          then parseFunctionTypeBound(Some(tuple))
          else tuple
      }
      else if isToken(SyntaxKind::OpenBraceToken)
        then parseRecordTypeBound()
      else TypeBound::NamedTypeBound(parseNamedTypeBound())
    )
  }

  fn parseFunctionTypeBound(tuple: Option<TypeBound>) -> TypeBound {
    let typeParameters =
      if tuple.isNone() and isToken(SyntaxKind::LessThanToken)
        then delimited(SyntaxKind::LessThanToken, SyntaxKind::GreaterThanToken, SyntaxKind::CommaToken, parseTypeParameter, true)
        else []

    let parameters = tuple.unwrapOrElse(parseTupleTypeBound).getTupleTypeBound()
    consumeToken(SyntaxKind::MinusGreaterThanToken)
    let returnType = parseTypeBound()

    TypeBound::FunctionTypeBound({
      typeParameters
      parameters
      returnType
    })
  }

  fn maybeParseIntersectionTypeBound(mut baseType: TypeBound) -> TypeBound {
    while true {
      if let Some(plusToken) = maybeConsumeToken(SyntaxKind::PlusToken) {
        baseType = TypeBound::IntersectionTypeBound({
          baseType
          plusToken
          traitBound: parseNamedTypeBound()
        })
      }
      else return baseType
    }
    baseType
  }

  fn parseNamedTypeBound() -> NamedTypeBound {
    let path = parseTypePath(None)
    let typeParameters =
      if isToken(SyntaxKind::LessThanToken)
        then delimited(SyntaxKind::LessThanToken, SyntaxKind::GreaterThanToken, SyntaxKind::CommaToken, parseTypeBound, true)
        else []

    {
      path
      typeParameters
    }
  }

  fn parseRecordTypeBound() -> TypeBound {
    expect(SyntaxKind::OpenBraceToken)
    let openBrace = expect(SyntaxKind::OpenBraceToken)
    let properties = delimited(SyntaxKind::OpenBraceToken, SyntaxKind::CloseBraceToken, SyntaxKind::CommaToken, parseRecordTypeBoundMember, false)
    let closeBrace = consumeToken(SyntaxKind::CloseBraceToken)

    TypeBound::RecordTypeBound({
      openBrace
      properties
      closeBrace
    })
  }

  fn parseRecordTypeBoundMember() -> RecordTypeBoundMember {
    if maybeConsumeToken(SyntaxKind::DotDotDotToken).isSome()
      then RecordTypeBoundMember::Spread(parseTypeBound())
      else {
        let name = consumeIdentifier()
        let optional = maybeConsumeToken(SyntaxKind::QuestionMarkToken).isSome()
        consumeToken(SyntaxKind::ColonToken)
        let typeBound = parseTypeBound()

        RecordTypeBoundMember::Property({
          name
          optional
          typeBound
        })
      }
  }

  fn parseTupleTypeBound() -> TypeBound {
    let openParen = expect(SyntaxKind::OpenParenToken)
    let properties = delimited(SyntaxKind::OpenParenToken, SyntaxKind::CloseParenToken, SyntaxKind::CommaToken, parseTypeBound, false)
    let closeParen = consumeToken(SyntaxKind::CloseParenToken)

    TypeBound::TupleTypeBound({
      openParen
      properties
      closeParen
    })
  }

  fn parseTypeParameter() -> TypeParameter {
    let name = consumeIdentifier()
    let defaultValue =
      if isToken(SyntaxKind::EqualsToken) {
        input.next()
        Some(parseTypeBound())
      }
      else None
    {
      name
      defaultValue
    }
  }

  fn parseTypePath(identifier: Option<Identifier>) -> TypePath {
    let i = identifier.unwrapOrElse(consumeIdentifier)

    if maybeConsumeToken(SyntaxKind::ColonColonToken).isSome()
      then TypePath::Object(i, parseTypePath(None))
      else TypePath::Member(i)
  }

  parseModule()
}
