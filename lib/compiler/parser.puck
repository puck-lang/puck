import 'puck:js' as {Object, console, global, null, typeof, undefined}
import '../ast/ast.puck' as {
  Token
  Expression

  Block
  EnumDeclaration
  EnumMember
  FunctionDeclaration
  ImplDeclaration
  ObjectDestructure
  ObjectDestructureMember
  TraitDeclaration
  TypeBound
  FunctionTypeBound
  NamedTypeBound
  ObjectTypeBound
  TupleTypeBound
  TypeDeclaration
  TypeParameter
  TypeProperty
  VariableDeclaration

  AssignmentExpression
  BinaryExpression
  CallExpression
  IfExpression
  UnaryExpression
  WhileExpression

  ListLiteral
  ObjectLiteral
  ObjectLiteralMember
}
import 'ast.ts' as {
  SyntaxKind
  isIdentifier
  isIndex
  isMember
  precedence
  textToToken
  tokenToText
}

export fn parse(input) { // : TokenStream

  fn isToken(kind, peekDistance = 0) { // kind: SyntaxKind
    let token = input.peek(false, peekDistance)
    token and token.kind == kind
  }

  fn tokenName(token: Token) {
    if typeof(tokenToText[token.kind]) == 'function' then tokenToText[token.kind](token)
    else if tokenToText[token.kind] then tokenToText[token.kind]
    else SyntaxKind[token.kind]
  }

  fn expect(expect, name = 'token') { // kind: SyntaxKind
    if not isToken(expect) {
      let token = input.peek()
      let expectedText = ': "' + tokenName({kind: expect}) + '"'

      let but =
        if token {
          let got = tokenName(token)
          'got "$got"'
        }
        else 'reached end of file'

      console.error(token)
      input.croak('Expected $name$expectedText, but $but')
    }
  }

  // fn consumeToken(token: SyntaxKind = undefined, name = undefined) {
  fn consumeToken(token, name = false) {
    if token then expect(token, name)
    return input.next()
  }

  fn maybeConsumeToken<T>(token, name = false): Maybe<T> {
    if isToken(token)
      then Just(consumeToken(token, name))
      else Nothing
  }

  fn skipKeyword(kw) { // kind: SyntaxKind
    expect(kw, 'keyword')
    input.next()
  }

  fn unexpected() {
    let token = input.peek()
    console.error('token', token, typeof(token))
    let name = tokenToText[token.kind]
    input.croak('Unexpected token: $name')
  }

  fn consumeSeparator(kind) { // kind: SyntaxKind
    if not input.eof() {
      let mut token = input.peek(true)

      if token.kind == SyntaxKind.NewlineToken
      or token.kind == SyntaxKind.Comment
        then input.next(true)
        else consumeToken(kind)
    }
  }

  fn isAssignment(token: Token) {
    if not token then return undefined

    token.kind == SyntaxKind.EqualsToken
      or token.kind == SyntaxKind.PlusEqualsToken
      or token.kind == SyntaxKind.MinusEqualsToken
      or token.kind == SyntaxKind.AsteriskEqualsToken
      or token.kind == SyntaxKind.AsteriskAsteriskEqualsToken
      or token.kind == SyntaxKind.SlashEqualsToken
      or token.kind == SyntaxKind.PercentEqualsToken
  }

  fn maybeParseOperator(): Token {
    if isAssignment(input.peek())
      or isToken(SyntaxKind.EqualsEqualsToken)
      or isToken(SyntaxKind.ExclamationEqualsToken)
      or isToken(SyntaxKind.GreaterThanToken)
      or isToken(SyntaxKind.GreaterThanEqualsToken)
      or isToken(SyntaxKind.LessThanToken)
      or isToken(SyntaxKind.LessThanEqualsToken)
      or isToken(SyntaxKind.PlusToken)
      or isToken(SyntaxKind.MinusToken)
      or isToken(SyntaxKind.AsteriskToken)
      or isToken(SyntaxKind.AsteriskAsteriskToken)
      or isToken(SyntaxKind.SlashToken)
      or isToken(SyntaxKind.PercentToken)
      or isToken(SyntaxKind.AndKeyword)
      or isToken(SyntaxKind.OrKeyword)
      or isToken(SyntaxKind.NotKeyword)
    then input.peek()
    else null
  }

  fn maybeBinary(left: Expression, myPrecedence): Expression {
    let mut operator = maybeParseOperator()
    if (operator) {
      let mut hisPrecedence = precedence[operator.kind]

      if hisPrecedence == undefined {
        let name = tokenToText[operator.kind]
        let json = global.JSON.stringify(operator)
        throw 'No precedence for $name: $json'
      }

      if (hisPrecedence > myPrecedence) {
        input.next()
        let mut e
        let mut innerExpression = maybeBinary(parseAtom(), hisPrecedence)
        if isAssignment(operator) {
          if isIdentifier(left) or isMember(left) or isIndex(left) {
            let a: AssignmentExpression = {
              kind: SyntaxKind.AssignmentExpression,
              lhs: left,
              token: operator,
              rhs: innerExpression,
            }
            e = a
          }
          else {
            input.croak('Can only assign to an identifier')
          }
        }
        else {
          let b: BinaryExpression = {
            kind: SyntaxKind.BinaryExpression,
            lhs: left,
            operator,
            rhs: innerExpression,
          }
          e = b
        }
        return maybeBinary(e, myPrecedence)
      }
    }
    left
  }

  fn maybeCall(expr: Expression): CallExpression {
    if isToken(SyntaxKind.OpenParenToken)
      then maybeCall(maybeMemberAccess({
        kind: SyntaxKind.CallExpression,
        func: expr,
        openParen: input.peek(),
        argumentList: delimited('(', ')', ',', parseExpression, false),
        closeParen: consumeToken(SyntaxKind.CloseParenToken),
      }))
      else expr
  }

  fn maybeMemberAccess(token: Expression): Expression {
    if isToken(SyntaxKind.DotToken) {
      input.next()
      maybeAccess({
        kind: SyntaxKind.MemberAccess
        object: token
        member: consumeToken(SyntaxKind.Identifier, 'identifier')
      })
    }
    else token
  }

  fn maybeIndexAccess(token: Expression): Expression {
    if isToken(SyntaxKind.OpenBracketToken) {
      input.next()
      let index = parseExpression()
      consumeToken(SyntaxKind.CloseBracketToken)

      maybeAccess({
        kind: SyntaxKind.IndexAccess
        object: token
        index
      })
    }
    else token
  }

  fn maybeAccess(token: Expression): Expression {
    maybeIndexAccess(maybeMemberAccess(token))
  }

  fn maybeTypePath(expression: Expression): Expression {
    if isToken(SyntaxKind.ColonColonToken) {
      input.next()
      maybeTypePath({
        kind: SyntaxKind.TypePath
        object: expression
        member: consumeToken(SyntaxKind.Identifier, 'identifier')
      })
    }
    else expression
  }

  // fn delimited<T>(start: SyntaxKind|string, stop: SyntaxKind|string, separator: SyntaxKind|string|(fn () then void), parser: fn () then T): Array<T> {
  fn delimited<T>(mut start, mut stop, mut separator, parser: () => T, consumeStop = true): List<T> {
    if typeof(start) == 'string' then start = textToToken[start]
    if typeof(stop) == 'string' then stop = textToToken[stop]
    if typeof(separator) == 'string' then separator = textToToken[separator]

    let mut parts = []
    let mut first = true
    consumeToken(start)

    while not input.eof() {
      if isToken(stop) then break

      if first then first = false
      else if typeof(separator) == 'function' then separator()
      else consumeSeparator(separator)

      let mut part
      while not part {
        if isToken(stop) then break
        part = parser()
      }

      if part then parts.push(part)
    }

    if consumeStop then consumeToken(stop)
    parts
  }

  fn parseEnumDeclaration(): EnumDeclaration {
    let keyword = consumeToken(SyntaxKind.EnumKeyword)
    let name = consumeToken(SyntaxKind.Identifier, 'identifier')
    let typeParameters =
      if isToken(SyntaxKind.LessThanToken)
        then delimited('<', '>', ',', parseTypeParameter)
      else []

    consumeToken(SyntaxKind.EqualsToken)

    let mut members = [parseEnumMember()]
    while isToken(SyntaxKind.BarToken) {
      input.next()
      members.push(parseEnumMember())
    }

    {
      kind: SyntaxKind.EnumDeclaration
      name
      typeParameters
      members
    }
  }

  fn parseEnumMember(): EnumMember {
    let name = consumeToken(SyntaxKind.Identifier, 'identifier')

    let bound =
      if isToken(SyntaxKind.OpenBraceToken)
        then Just(parseObjectTypeBound())
      else if isToken(SyntaxKind.OpenParenToken)
        then Just(parseTupleTypeBound())
      else Nothing

    {
      kind: SyntaxKind.EnumMember
      name
      bound
    }
  }

  fn parseObjectDestructureMember(): ObjectDestructureMember {
    let property = consumeToken(SyntaxKind.Identifier, 'identifier')
    let local =
      if isToken(SyntaxKind.ColonToken) {
        input.next()
        consumeToken(SyntaxKind.Identifier, 'identifier')
      }
      else property

    {
      kind: SyntaxKind.ObjectDestructureMember,
      property,
      local,
    }
  }

  fn parseObjectDestructure(): ObjectDestructure {
    let openBrace = input.peek()
    let members = delimited('{', '}', ',', parseObjectDestructureMember, false)
    let closeBrace = consumeToken(SyntaxKind.CloseBraceToken)

    {
      kind: SyntaxKind.ObjectDestructure
      openBrace
      members
      closeBrace
    }
  }

  fn parseTraitDeclaration(): TraitDeclaration {
    let keyword = consumeToken(SyntaxKind.TraitKeyword)
    let name = consumeToken(SyntaxKind.Identifier, 'identifier')
    let typeParameters =
      if isToken(SyntaxKind.LessThanToken)
        then delimited('<', '>', ',', parseTypeParameter)
      else []

    let openBrace = expect(SyntaxKind.OpenBraceToken)
    let members = delimited('{', '}', ';', || parseFunctionDeclaration(true), false)
      .map(|f: FunctionDeclaration| {
        if f.name.isNothing()
          then input.croak('Trait functions must have a name')
        if f.returnType.isNothing()
          then input.croak('Trait functions must have a return type')

        f
      })
    let closeBrace = consumeToken(SyntaxKind.CloseBraceToken)

    {
      kind: SyntaxKind.TraitDeclaration
      keyword
      name
      typeParameters
      openBrace
      members
      closeBrace
    }
  }

  fn parseImplDeclaration(): ImplDeclaration {
    let implKeyword = consumeToken(SyntaxKind.ImplKeyword)
    let typeParameters =
      if isToken(SyntaxKind.LessThanToken)
        then delimited('<', '>', ',', parseTypeParameter)
      else []

    let tra = parseTypeBound()
    let forKeyword = consumeToken(SyntaxKind.ForKeyword)
    let ty = parseTypeBound()

    let openBrace = expect(SyntaxKind.OpenBraceToken)
    let members = delimited('{', '}', ';', parseFunctionDeclaration, false)
      .map(|f: FunctionDeclaration| {
        if f.name.isNothing()
          then input.croak('Trait functions must have a name')
        if f.returnType.isNothing()
          then input.croak('Trait functions must have a return type')

        f
      })
    let closeBrace = consumeToken(SyntaxKind.CloseBraceToken)

    {
      kind: SyntaxKind.ImplDeclaration
      implKeyword
      typeParameters
      tra
      forKeyword
      ty
      openBrace
      members
      closeBrace
    }
  }

  fn parseFunctionTypeBound(tuple): FunctionTypeBound {
    let typeParameters =
      if not tuple and isToken(SyntaxKind.LessThanToken)
        then delimited('<', '>', ',', parseTypeParameter)
      else []

    let arguments = tuple or parseTupleTypeBound()
    consumeToken(SyntaxKind.EqualsGreaterThanToken)
    let returnType = parseTypeBound()

    {
      kind: SyntaxKind.FunctionTypeBound
      typeParameters
      arguments
      returnType
    }
  }

  fn parseNamedTypeBound(): NamedTypeBound {
    let name = consumeToken(SyntaxKind.Identifier, 'identifier')
    let typeParameters =
      if isToken(SyntaxKind.LessThanToken)
        then delimited('<', '>', ',', parseTypeBound)
      else []

    {
      kind: SyntaxKind.NamedTypeBound
      name
      typeParameters
    }
  }

  fn parseObjectTypeBound(): ObjectTypeBound {
    expect(SyntaxKind.OpenBraceToken)
    let openBrace = input.peek()
    let properties = delimited('{', '}', ',', parseTypeProperty, false)
    let closeBrace = consumeToken(SyntaxKind.CloseBraceToken)

    {
      kind: SyntaxKind.ObjectTypeBound
      openBrace
      properties
      closeBrace
    }
  }

  fn parseTupleTypeBound(): TupleTypeBound {
    expect(SyntaxKind.OpenParenToken)
    let openParen = input.peek()
    let properties = delimited('(', ')', ',', parseTypeBound, false)
    let closeParen = consumeToken(SyntaxKind.CloseParenToken)
    {
      kind: SyntaxKind.TupleTypeBound
      openParen
      properties
      closeParen
    }
  }

  fn parseTypeBound(): TypeBound {
    if isToken(SyntaxKind.LessThanToken)
      then parseFunctionTypeBound(undefined)
    else if isToken(SyntaxKind.OpenParenToken) {
      let tuple = parseTupleTypeBound()
      if isToken(SyntaxKind.EqualsGreaterThanToken)
        then parseFunctionTypeBound(tuple)
        else tuple
    }
    else if isToken(SyntaxKind.OpenBraceToken)
      then parseObjectTypeBound()
    else parseNamedTypeBound()
  }

  fn parseTypeParameter(): TypeParameter {
    let name = consumeToken(SyntaxKind.Identifier, 'identifier')
    let defaultValue =
      if isToken(SyntaxKind.EqualsToken) {
        input.next()
        Just(parseTypeBound())
      }
      else Nothing
    {
      kind: SyntaxKind.TypeParameter
      name
      defaultValue
    }
  }

  fn parseTypeProperty(): TypeProperty {
    let name = consumeToken(SyntaxKind.Identifier, 'identifier')
    consumeToken(SyntaxKind.ColonToken)
    let typeBound = parseTypeBound()
    {
      kind: SyntaxKind.TypeProperty
      name
      typeBound
    }
  }

  fn parseTypeDeclaration(): TypeDeclaration {
    let keyword = consumeToken(SyntaxKind.TypeKeyword)
    let name = consumeToken(SyntaxKind.Identifier, 'identifier')
    let typeParameters =
      if isToken(SyntaxKind.LessThanToken)
        then delimited('<', '>', ',', parseTypeParameter)
      else []

    let bound =
      if isToken(SyntaxKind.OpenBraceToken)
        then Just(parseObjectTypeBound())
      else if isToken(SyntaxKind.OpenParenToken)
        then Just(parseTupleTypeBound())
      else Nothing

    {
      kind: SyntaxKind.TypeDeclaration
      name
      typeParameters
      bound
    }
  }

  fn parseVariableDeclaration(): VariableDeclaration {
    let mutable = maybeConsumeToken(SyntaxKind.MutKeyword).isJust()
    let identifier = consumeToken(SyntaxKind.Identifier, 'identifier')

    {
      kind: SyntaxKind.VariableDeclaration
      identifier
      mutable
      typeBound:
        if isToken(SyntaxKind.ColonToken) {
          input.next()
          Just(parseTypeBound())
        }
        else Nothing
      initializer:
        if isToken(SyntaxKind.EqualsToken) {
          input.next()
          Just(parseExpression())
        }
        else Nothing
    }
  }

  fn parseFunctionDeclaration(optionalBody = false): FunctionDeclaration {
    consumeToken(SyntaxKind.FnKeyword)
    let name = maybeConsumeToken(SyntaxKind.Identifier, 'identifier')
      if isToken(SyntaxKind.Identifier)
        then Just(consumeToken(SyntaxKind.Identifier, 'identifier'))
        else Nothing
    let typeParameters =
      if isToken(SyntaxKind.LessThanToken)
        then delimited('<', '>', ',', parseTypeParameter)
      else []
    let parameterList = delimited('(', ')', ',', parseVariableDeclaration)

    let returnType =
      if isToken(SyntaxKind.ColonToken) {
        input.next()
        Just(parseTypeBound())
      }
      else Nothing

    let body: Block =
      if isToken(SyntaxKind.OpenBraceToken)
        then parseBlock()
      else if isToken(SyntaxKind.ThenKeyword) {
        skipKeyword(SyntaxKind.ThenKeyword)
        {
          kind: SyntaxKind.Block,
          expressions: [parseExpression()],
        }
      }
      else if not optionalBody
        then input.croak('A function declaration must be followed by a `{` or `then`')

    {
      kind: SyntaxKind.Function
      name
      typeParameters
      parameterList
      returnType
      body
    }
  }

  fn parseLambda(): FunctionDeclaration {
    let mut parameterList = delimited('|', '|', ',', parseVariableDeclaration)

    let mut body: Block =
      if isToken(SyntaxKind.OpenBraceToken)
        then parseBlock()
        else {{
          kind: SyntaxKind.Block,
          expressions: [parseExpression()],
        }}

    {
      kind: SyntaxKind.Function
      name: Nothing
      parameterList
      returnType: Nothing
      body
    }
  }

  fn parseIf(): IfExpression {
    skipKeyword(SyntaxKind.IfKeyword)

    let condition = parseExpression()

    let mut _then: Block =
      if isToken(SyntaxKind.OpenBraceToken)
        then parseBlock()
        else {
          skipKeyword(SyntaxKind.ThenKeyword)
          {
            kind: SyntaxKind.Block,
            expressions: [parseExpression()],
          }
        }

    {
      kind: SyntaxKind.IfExpression
      condition
      _then
      _else:
        if isToken(SyntaxKind.ElseKeyword) {
          input.next()
          Just(
            if isToken(SyntaxKind.OpenBraceToken)
              then parseBlock()
              else ({
                kind: SyntaxKind.Block,
                expressions: [parseExpression()],
              })
          )
        }
        else Nothing
    }
  }

  fn parseUnaryExpression(): UnaryExpression {
    let operator = input.next()

    {
      kind: SyntaxKind.UnaryExpression
      operator
      rhs: parseExpression(precedence[operator.kind])
    }
  }

  fn parseWhile(): WhileExpression {
    skipKeyword(SyntaxKind.WhileKeyword)

    let condition = parseExpression()
    let body: Block =
      if isToken(SyntaxKind.OpenBraceToken)
        then parseBlock()
        else {
          skipKeyword(SyntaxKind.ThenKeyword)
          {
            kind: SyntaxKind.Block,
            expressions: [parseExpression()],
          }
        }

    {
      kind: SyntaxKind.WhileExpression
      condition
      body
    }
  }

  fn parseListLiteral(): ListLiteral {
    let members = delimited('[', ']', ',', parseExpression)
    { kind: SyntaxKind.ListLiteral, members }
  }

  fn parseObjectLiteralMember(): ObjectLiteralMember {
    let name = consumeToken(SyntaxKind.Identifier, 'identifier')
    let value =
      if isToken(SyntaxKind.ColonToken) {
        input.next()
        parseExpression()
      }
      else name

    {
      kind: SyntaxKind.ObjectLiteralMember
      name
      value
    }
  }

  fn parseObjectLiteral(): ObjectLiteral {
    let openBrace = input.peek()
    let members = delimited('{', '}', ',', parseObjectLiteralMember, false)
    let closeBrace = consumeToken(SyntaxKind.CloseBraceToken)
    {
      kind: SyntaxKind.ObjectLiteral,
      openBrace
      members
      closeBrace
    }
  }

  fn parseTupleOrExpression(forceTuple) {
    let openParen = input.peek()
    let expressions = delimited('(', ')', ',', || parseExpression(0, true), false)
    let closeParen = consumeToken(SyntaxKind.CloseParenToken)

    if not forceTuple and expressions.length == 1
      then expressions[0]
      else {{
        kind: SyntaxKind.TupleLiteral,
        openParen
        expressions
        closeParen
      }}
  }

  fn parseAtom(forceTuple = false) {
    maybeCall((fn innerParseAtom() {
      if isToken(SyntaxKind.OpenParenToken) then parseTupleOrExpression(forceTuple)
      else if isToken(SyntaxKind.OpenBracketToken) then parseListLiteral()
      else if isToken(SyntaxKind.OpenBraceToken) then parseObjectLiteral()
      else if isToken(SyntaxKind.BarToken) then parseLambda()
      else if isToken(SyntaxKind.IfKeyword) then parseIf()
      else if isToken(SyntaxKind.WhileKeyword) then parseWhile()
      else if isToken(SyntaxKind.FnKeyword) then parseFunctionDeclaration()
      else if isToken(SyntaxKind.LetKeyword) {
        input.next()
        parseVariableDeclaration()
      }
      else if isToken(SyntaxKind.NotKeyword)
           or isToken(SyntaxKind.MinusToken)
           or isToken(SyntaxKind.PlusToken)
        then parseUnaryExpression()
      else if isToken(SyntaxKind.BreakKeyword) then input.next()
      else if isToken(SyntaxKind.ReturnKeyword) then {
        kind: SyntaxKind.ReturnStatement
        keyword: input.next()
        expression: parseExpression()
      }
      else if isToken(SyntaxKind.ThrowKeyword) then {
        kind: input.next().kind
        expression: parseExpression()
      }
      else if isToken(SyntaxKind.TrueKeyword)
           or isToken(SyntaxKind.FalseKeyword)
        then
          maybeAccess({
            kind: SyntaxKind.BooleanLiteral
            value: input.next().kind == SyntaxKind.TrueKeyword
          })
      else if isToken(SyntaxKind.NumberLiteral)
           or isToken(SyntaxKind.StringLiteral)
        then maybeAccess(input.next())
      else if isToken(SyntaxKind.Identifier)
        then maybeTypePath(maybeAccess(input.next()))
      else unexpected()
    })())
  }

  fn parseExport() {
    let keyword = consumeToken(SyntaxKind.ExportKeyword)
    let mut expression
    let mut identifier
    if isToken(SyntaxKind.EnumKeyword) {
      expression = parseEnumDeclaration()
      identifier = expression.name
    }
    else if isToken(SyntaxKind.FnKeyword) {
      expression = parseFunctionDeclaration()
      let func: FunctionDeclaration = expression
      if func.name.isNothing() {
        input.croak('Can not export function without a name')
      }
      identifier = expression.name.value[0]
    }
    else if isToken(SyntaxKind.LetKeyword) {
      input.next()
      expression = parseVariableDeclaration()
      identifier = expression.identifier
    }
    else if isToken(SyntaxKind.TraitKeyword) {
      expression = parseTraitDeclaration()
      identifier = expression.name
    }
    else if isToken(SyntaxKind.TypeKeyword) {
      expression = parseTypeDeclaration()
      identifier = expression.name
    }
    else input.croak('Expected trait, type, function or variable declaration after export')
    {
      kind: SyntaxKind.ExportDirective
      keyword
      identifier
      expression
    }
  }

  fn parseImport() {
    let importKeyword = consumeToken(SyntaxKind.ImportKeyword)

    let locator = consumeToken(SyntaxKind.StringLiteral)
    if locator.parts.length != 1 then throw Error('More than one part in import string')
    let parts = locator.parts[0].value.split(':')
    if parts > 2 then input.croak('Illegal token ":" used in import path')
    let domain = if parts.length == 2 then Just(parts[0]) else Nothing
    let path = if parts.length == 2 then parts[1] else parts[0]

    let asKeyword = consumeToken(SyntaxKind.AsKeyword)
    let specifier =
      if isToken(SyntaxKind.OpenBraceToken)
        then parseObjectDestructure()
      else if isToken(SyntaxKind.AsteriskToken)
        then consumeToken(false)
      else consumeToken(SyntaxKind.Identifier, 'identifier')

    {
      kind: SyntaxKind.ImportDirective
      importKeyword
      domain
      path
      asKeyword
      specifier
    }
  }

  fn parseTopLevelExpression() {
    if isToken(SyntaxKind.EnumKeyword) then parseEnumDeclaration()
    else if isToken(SyntaxKind.ExportKeyword) then parseExport()
    else if isToken(SyntaxKind.ImplKeyword) then parseImplDeclaration()
    else if isToken(SyntaxKind.ImportKeyword) then parseImport()
    else if isToken(SyntaxKind.TraitKeyword) then parseTraitDeclaration()
    else if isToken(SyntaxKind.TypeKeyword) then parseTypeDeclaration()
    else parseExpression()
  }

  fn parseModule() {
    let mut exports = {}
    let mut expressions = []
    while not input.eof() {
      let expression = parseTopLevelExpression()
      if expression {
        expressions.push(expression)
        if expression.kind == SyntaxKind.ExportDirective
          then exports[expression.identifier.name] = expression
      }
      if not input.eof() then consumeSeparator(SyntaxKind.SemicolonToken)
    }
    {
      kind: SyntaxKind.Module
      fileName: input.file.fileName
      path: input.file.absolutePath
      exports
      expressions
    }
  }

  fn parseBlock(): Block {
    let expressions = delimited('{', '}', ';', parseExpression)
    { kind: SyntaxKind.Block, expressions }
  }

  fn parseExpression(precedence = 0, forceTuple = false): Expression {
    maybeCall(maybeAccess(maybeBinary(parseAtom(forceTuple), precedence)))
  }

  parseModule()
}
