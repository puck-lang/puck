import 'puck:js' as {Error, Object, global, null, typeof, undefined}
import '../ast/ast.puck' as {
  Module
  TopLevelStatement
  BlockLevelStatement
  Expression
  SimpleLiteral
  Attribute
  AttributeData

  EnumDeclaration
  EnumMember
  ImplDeclaration
  ImplShorthandDeclaration
  TraitDeclaration
  TypeDeclaration

  ExportDirective
  ExportedStatement
  ImportDirective
  ImportSpecifier
  ObjectDestructure
  ObjectDestructureMember

  Block
  ReturnStatement
  WhileLoop

  Identifier
  FunctionDeclaration
  VariableDeclaration

  AssignmentExpression
  BinaryExpression
  CallExpression
  IfExpression
  IfLetExpression
  MatchExpression
  MatchArm
  TypePathExpression
  TypePath
  UnaryExpression

  IndexAccess
  MemberAccess

  BooleanLiteral
  ListLiteral
  NumberLiteral
  RecordLiteral
  RecordLiteralMember
  StringLiteral
  StringLiteralPart
  TupleLiteral

  Pattern
  RecordPattern
  RecordPatternMember
  TuplePattern

  TypeBound
  FunctionTypeBound
  NamedTypeBound
  RecordTypeBound
  RecordTypeBoundMember
  TupleTypeBound
  TypeParameter
}
import '../ast/token.puck' as {SyntaxKind, SimpleToken, Token}
import '../entities.puck' as {UnparsedFile}
import 'token_stream.puck' as {TokenStream}

export fn parse(mut input: TokenStream, file: UnparsedFile) {

  fn isToken(kind: SyntaxKind, withDummy = false) -> Bool {
    match input.peek(withDummy) {
      Token::SimpleToken(token) => token.kind == kind
      _ => false
    }
  }

  fn butGot() {
    let token =
    match input.peek() {
      Token::SimpleToken({kind: SyntaxKind::EndOfFileToken}) => 'but reached end of file'
      token => 'but got "' + token.name() + '"'
    }
  }

  fn expect(kind: SyntaxKind) -> SimpleToken {
    let token = input.peek()
    match token {
      Token::SimpleToken(token) => {
        if token.kind != kind {
          input.croak('Expected token: "'  + kind.name() + '", ' + butGot())
        }
        token
      }
      _ => input.croak('Expected token: "'  + kind.name() + '", ' + butGot())
    }
  }

  fn consumeToken(kind: SyntaxKind) -> SimpleToken {
    let token = expect(kind)
    input.next()
    token
  }

  fn consumeIdentifier() -> Identifier {
    match input.next() {
      Token::Identifier(identifier) => identifier
      _ => input.croak('Expected identifier, ' + butGot())
    }
  }

  fn maybeConsumeToken(kind: SyntaxKind) -> Option<SimpleToken> {
    if isToken(kind)
      then Some(consumeToken(kind))
      else None
  }

  fn unexpected() {
    let name = input.peek().name()
    input.croak('Unexpected token: $name')
  }

  fn attributeNotSupported() {
    input.croak('Attributes are only supported on enum, trait and type declarations')
  }

  fn consumeSeparator(kind: SyntaxKind) -> () {
    let mut token = input.peek(true)

    match token {
      Token::SimpleToken({kind: SyntaxKind::NewlineToken}) => input.next(true)
      Token::Comment => input.next(true)
      _ => consumeToken(kind)
    }
  }

  fn isAssignment(token: SimpleToken) -> Bool {
    match token.kind {
      SyntaxKind::EqualsToken => true
      SyntaxKind::PlusEqualsToken => true
      SyntaxKind::MinusEqualsToken => true
      SyntaxKind::AsteriskEqualsToken => true
      SyntaxKind::AsteriskAsteriskEqualsToken => true
      SyntaxKind::SlashEqualsToken => true
      SyntaxKind::PercentEqualsToken => true
      _ => false
    }
  }

  fn maybeParseOperator() -> Option<SimpleToken> {
    match input.peek() {
      Token::SimpleToken(token) => match token.kind {
        SyntaxKind::EqualsEqualsToken => Some(token)
        SyntaxKind::ExclamationEqualsToken => Some(token)
        SyntaxKind::GreaterThanToken => Some(token)
        SyntaxKind::GreaterThanEqualsToken => Some(token)
        SyntaxKind::LessThanToken => Some(token)
        SyntaxKind::LessThanEqualsToken => Some(token)
        SyntaxKind::PlusToken => Some(token)
        SyntaxKind::MinusToken => Some(token)
        SyntaxKind::AsteriskToken => Some(token)
        SyntaxKind::AsteriskAsteriskToken => Some(token)
        SyntaxKind::SlashToken => Some(token)
        SyntaxKind::PercentToken => Some(token)
        SyntaxKind::AndKeyword => Some(token)
        SyntaxKind::OrKeyword => Some(token)
        SyntaxKind::NotKeyword => Some(token)
        _ => if isAssignment(token)
          then Some(token)
          else None
      }
      _ => None
    }
  }

  fn isAssignable(expression: Expression) {
    match expression {
      Expression::Identifier(_) => true
      Expression::MemberAccess(_) => true
      Expression::IndexAccess(_) => true
      Expression::UnknownAccess(_) => true
      Expression::UnknownIndexAccess(_) => true
      _ => false
    }
  }

  fn maybeBinary(left: Expression, myPrecedence: Num) -> Expression {
    if let Some(operator) = maybeParseOperator() {
      let mut hisPrecedence = operator.kind.precedence()

      if (hisPrecedence > myPrecedence) {
        input.next()
        let mut innerExpression = maybeBinary(parseAtom(), hisPrecedence)
        let e =
          if isAssignment(operator) {
            if not isAssignable(left) then input.croak('Can only assign to an identifier')

            Expression::AssignmentExpression({
              lhs: left,
              token: operator,
              rhs: innerExpression,
            })
          }
          else {
            Expression::BinaryExpression({
              lhs: left
              operator
              rhs: innerExpression
            })
          }
        return maybeBinary(e, myPrecedence)
      }
    }
    left
  }

  fn maybeCall(expression: Expression) -> Expression {
    if isToken(SyntaxKind::OpenParenToken, true)
      then maybeCall(maybeAccess(Expression::CallExpression({
        func: expression
        openParen: expect(SyntaxKind::OpenParenToken)
        argumentList: delimited(SyntaxKind::OpenParenToken, SyntaxKind::CloseParenToken, SyntaxKind::CommaToken, parseExpression, false)
        closeParen: consumeToken(SyntaxKind::CloseParenToken)
      })))
      else expression
  }

  fn maybeAccess(expression: Expression) -> Expression {
    maybeUnknownAccess(maybeIndexAccess(maybeMemberAccess(expression)))
  }

  fn maybeMemberAccess(expression: Expression) -> Expression {
    if isToken(SyntaxKind::DotToken) {
      input.next()
      maybeAccess(Expression::MemberAccess({
        object: expression
        member: consumeIdentifier()
      }))
    }
    else expression
  }

  fn maybeIndexAccess(expression: Expression) -> Expression {
    if isToken(SyntaxKind::OpenBracketToken, true) {
      let openBracket = consumeToken(SyntaxKind::OpenBracketToken)
      let index = parseExpression()
      let closeBracket = consumeToken(SyntaxKind::CloseBracketToken)

      maybeAccess(Expression::IndexAccess({
        object: expression
        openBracket
        index
        closeBracket
      }))
    }
    else expression
  }

  fn maybeUnknownAccess(expression: Expression) -> Expression {
    if isToken(SyntaxKind::MinusGreaterThanToken) {
      input.next()
      if isToken(SyntaxKind::OpenBracketToken) {
        let openBracket = consumeToken(SyntaxKind::OpenBracketToken)
        let index = parseExpression()
        let closeBracket = consumeToken(SyntaxKind::CloseBracketToken)

        maybeAccess(Expression::UnknownIndexAccess({
          object: expression
          openBracket
          index
          closeBracket
        }))
      }
      else {
      maybeAccess(Expression::UnknownAccess({
        object: expression
        member: consumeIdentifier()
      }))
      }
    }
    else expression
  }

  fn delimited<T>(start: SyntaxKind, stop: SyntaxKind, separator: SyntaxKind, parser: () -> T, consumeStop: Bool) -> List<T> {
    let mut parts = []
    let mut first = true
    consumeToken(start)

    while not input.eof() {
      if isToken(stop) then break

      if first then first = false
      else consumeSeparator(separator)

      let mut part
      while not part {
        if isToken(stop) then break
        part = parser()
      }

      if part then parts.push(part)
    }

    if consumeStop then consumeToken(stop)
    parts
  }

  fn parseModule() -> Module {
    let mut exports = {}
    let mut statements = []
    while not input.eof() {
      let statement = parseTopLevelStatement()
      statements.add(statement)
      if let TopLevelStatement::ExportDirective(e) = statement
        then exports[e.identifier.name] = e

      consumeSeparator(SyntaxKind::SemicolonToken)
    }

    {
      fileName: file.fileName
      path: file.absolutePath
      exports
      statements
      file: undefined
      scope: undefined
    }
  }

  fn parseTopLevelStatement() {
    match input.peek() {
      Token::SimpleToken(token) => match token.kind {
        SyntaxKind::HashToken => parseDeclarationWithAttribute()
        SyntaxKind::EnumKeyword => TopLevelStatement::EnumDeclaration(parseEnumDeclaration())
        SyntaxKind::ExportKeyword => TopLevelStatement::ExportDirective(parseExport())
        SyntaxKind::ImplKeyword => parseImplDeclaration()
        SyntaxKind::ImportKeyword => TopLevelStatement::ImportDirective(parseImport())
        SyntaxKind::TraitKeyword => TopLevelStatement::TraitDeclaration(parseTraitDeclaration())
        SyntaxKind::TypeKeyword => TopLevelStatement::TypeDeclaration(parseTypeDeclaration())
        _ => TopLevelStatement::BlockLevelStatement(parseBlockLevelStatement())
      }
      _ => TopLevelStatement::BlockLevelStatement(parseBlockLevelStatement())
    }
  }

  fn parseBlockLevelStatement() {
    match input.peek() {
      Token::SimpleToken({kind: SyntaxKind::BreakKeyword}) => {
        BlockLevelStatement::BreakStatement({keyword: consumeToken(SyntaxKind::BreakKeyword)})
      }
      Token::SimpleToken({kind: SyntaxKind::ReturnKeyword}) => {
        BlockLevelStatement::ReturnStatement({
          keyword: consumeToken(SyntaxKind::ReturnKeyword)
          expression: parseExpression()
        })
      }
      Token::SimpleToken({kind: SyntaxKind::WhileKeyword}) => {
        BlockLevelStatement::WhileLoop(parseWhile())
      }
      _ => BlockLevelStatement::Expression(parseExpression())
    }
  }

  fn parseExpression(precedence = 0, forceTuple = false) -> Expression {
    maybeCall(maybeAccess(maybeBinary(parseAtom(forceTuple), precedence)))
  }

  fn parseAtom(forceTuple = false) -> Expression {
    maybeCall(
      match input.peek() {
        Token::SimpleToken(token) => match token.kind {
          SyntaxKind::OpenParenToken => parseTupleOrExpression(forceTuple)
          SyntaxKind::OpenBracketToken => Expression::ListLiteral(parseListLiteral())
          SyntaxKind::OpenBraceToken => Expression::RecordLiteral(parseRecordLiteral())
          SyntaxKind::BarToken => Expression::FunctionDeclaration(parseLambda())
          SyntaxKind::IfKeyword => parseIf()
          SyntaxKind::MatchKeyword => Expression::MatchExpression(parseMatch())
          SyntaxKind::FnKeyword => Expression::FunctionDeclaration(parseFunctionDeclaration())
          SyntaxKind::LetKeyword => {
            input.next()
            Expression::VariableDeclaration(parseVariableDeclaration())
          }
          SyntaxKind::NotKeyword => Expression::UnaryExpression(parseUnaryExpression())
          SyntaxKind::MinusToken => Expression::UnaryExpression(parseUnaryExpression())
          SyntaxKind::PlusToken => Expression::UnaryExpression(parseUnaryExpression())
          SyntaxKind::ThrowKeyword => {
            input.next()
            Expression::ThrowStatement({
              expression: parseExpression()
            })
          }
          SyntaxKind::TrueKeyword => {
            maybeAccess(Expression::BooleanLiteral({
              keyword: consumeToken(SyntaxKind::TrueKeyword)
              value: true
            }))
          }
          SyntaxKind::FalseKeyword => {
            maybeAccess(Expression::BooleanLiteral({
              keyword: consumeToken(SyntaxKind::FalseKeyword)
              value: false
            }))
          }
          _ => unexpected()
        }
        Token::NumberLiteral(numberLiteral) => {
          input.next()
          maybeAccess(Expression::NumberLiteral(numberLiteral))
        }
        Token::StringLiteral(stringLiteral) => {
          input.next()
          maybeAccess(Expression::StringLiteral(stringLiteral))
        }
        Token::Identifier(identifier) => parseIdentifierOrTypePath()
        Token::Comment => unexpected()
      }
    )
  }

  fn parseSimpleLiteral() {
    match input.next() {
      Token::SimpleToken(token) => match token.kind {
        SyntaxKind::TrueKeyword => {
          SimpleLiteral::BooleanLiteral({
            keyword: token
            value: true
          })
        }
        SyntaxKind::FalseKeyword => {
          SimpleLiteral::BooleanLiteral({
            keyword: token
            value: false
          })
        }
        _ => unexpected()
      }
      Token::NumberLiteral(numberLiteral) => SimpleLiteral::NumberLiteral(numberLiteral)
      Token::StringLiteral(stringLiteral) => {
        if stringLiteral.parts.size() > 1 {
          input.croak('Attributes can only contain simple string literals. Interpolation is not supported.')
        }
        let part: StringLiteralPart = stringLiteral.parts[0]
        match part {
          StringLiteralPart::Literal(literal) => SimpleLiteral::StringLiteral(literal)
          _ => panic('String literal does not start with a literal')
        }
      }
      _ => unexpected()
    }
  }

  fn parseAttributeArgument() {
    let name = consumeIdentifier()
    let value = maybeConsumeToken(SyntaxKind::EqualsToken).map(|_| parseSimpleLiteral())

    {name, value}
  }

  fn parseAttribute() {
    let hashToken = consumeToken(SyntaxKind::HashToken)
    let openBracket = consumeToken(SyntaxKind::OpenBracketToken)
    let name = consumeIdentifier()
    let data =
      if maybeConsumeToken(SyntaxKind::EqualsToken).isSome()
        then AttributeData::Value(parseSimpleLiteral())
      else if isToken(SyntaxKind::OpenParenToken)
        then AttributeData::Arguments(delimited(SyntaxKind::OpenParenToken, SyntaxKind::CloseParenToken, SyntaxKind::CommaToken, parseAttributeArgument, true))
      else AttributeData::None
    let closeBracket = consumeToken(SyntaxKind::CloseBracketToken)

    {hashToken, openBracket, name, data, closeBracket}
  }

  fn parseDeclarationWithAttribute() {
    let mut attributes = []
    while isToken(SyntaxKind::HashToken) {
      attributes.add(parseAttribute())
    }

    if isToken(SyntaxKind::EnumKeyword) then TopLevelStatement::EnumDeclaration(parseEnumDeclaration(attributes))
    else if isToken(SyntaxKind::ExportKeyword) then TopLevelStatement::ExportDirective(parseExport(attributes))
    else if isToken(SyntaxKind::TraitKeyword) then TopLevelStatement::TraitDeclaration(parseTraitDeclaration(attributes))
    else if isToken(SyntaxKind::TypeKeyword) then TopLevelStatement::TypeDeclaration(parseTypeDeclaration(attributes))
    else attributeNotSupported()
  }

  fn parseEnumDeclaration(attributes: List<Attribute> = []) -> EnumDeclaration {
    let keyword = consumeToken(SyntaxKind::EnumKeyword)
    let name = consumeIdentifier()
    let typeParameters =
      if isToken(SyntaxKind::LessThanToken)
        then delimited(SyntaxKind::LessThanToken, SyntaxKind::GreaterThanToken, SyntaxKind::CommaToken, parseTypeParameter, true)
        else []

    let openBrace = expect(SyntaxKind::OpenBraceToken)
    let members = delimited(SyntaxKind::OpenBraceToken, SyntaxKind::CloseBraceToken, SyntaxKind::CommaToken, parseEnumMember, false)
    let closeBrace = consumeToken(SyntaxKind::CloseBraceToken)

    {
      attributes
      keyword
      name
      typeParameters
      openBrace
      members
      closeBrace
    }
  }

  fn parseEnumMember() -> EnumMember {
    let name = consumeIdentifier()

    let bound =
      if isToken(SyntaxKind::OpenBraceToken)
        then Some(parseRecordTypeBound())
      else if isToken(SyntaxKind::OpenParenToken)
        then Some(parseTupleTypeBound())
      else None

    {
      name
      bound
    }
  }

  fn parseImplDeclaration() -> TopLevelStatement {
    let implKeyword = consumeToken(SyntaxKind::ImplKeyword)
    let typeParameters =
      if isToken(SyntaxKind::LessThanToken)
        then delimited(SyntaxKind::LessThanToken, SyntaxKind::GreaterThanToken, SyntaxKind::CommaToken, parseTypeParameter, true)
      else []

    let trait_ = parseTypeBound()
    let {forKeyword, type_}: {forKeyword: Option<SimpleToken>, type_: Option<TypeBound>} =
      if isToken(SyntaxKind::ForKeyword)
        then {
          forKeyword: Some(consumeToken(SyntaxKind::ForKeyword))
          type_: Some(parseTypeBound())
        }
        else {{
          forKeyword: None
          type_: None
        }}

    let openBrace = expect(SyntaxKind::OpenBraceToken)
    let members = delimited(SyntaxKind::OpenBraceToken, SyntaxKind::CloseBraceToken, SyntaxKind::SemicolonToken, parseFunctionDeclaration, false)
      .toList()
    let closeBrace = consumeToken(SyntaxKind::CloseBraceToken)

    if let Option::Some(type_) = type_
      then TopLevelStatement::ImplDeclaration({
        implKeyword
        typeParameters
        trait_
        forKeyword: forKeyword.unwrap()
        type_
        openBrace
        members
        closeBrace
      })
      else TopLevelStatement::ImplShorthandDeclaration({
        implKeyword
        typeParameters
        type_: trait_
        openBrace
        members
        closeBrace
      })
  }

  fn parseTraitDeclaration(attributes: List<Attribute> = []) -> TraitDeclaration {
    let keyword = consumeToken(SyntaxKind::TraitKeyword)
    let name = consumeIdentifier()
    let typeParameters =
      if isToken(SyntaxKind::LessThanToken)
        then delimited(SyntaxKind::LessThanToken, SyntaxKind::GreaterThanToken, SyntaxKind::CommaToken, parseTypeParameter, true)
      else []

    let openBrace = expect(SyntaxKind::OpenBraceToken)
    let members = delimited(SyntaxKind::OpenBraceToken, SyntaxKind::CloseBraceToken, SyntaxKind::SemicolonToken, || parseFunctionDeclaration(true), false)
      .toList()
    let closeBrace = consumeToken(SyntaxKind::CloseBraceToken)

    {
      attributes
      keyword
      name
      typeParameters
      openBrace
      members
      closeBrace
    }
  }

  fn parseTypeDeclaration(attributes: List<Attribute> = []) -> TypeDeclaration {
    let keyword = consumeToken(SyntaxKind::TypeKeyword)
    let name = consumeIdentifier()
    let typeParameters =
      if isToken(SyntaxKind::LessThanToken)
        then delimited(SyntaxKind::LessThanToken, SyntaxKind::GreaterThanToken, SyntaxKind::CommaToken, parseTypeParameter, true)
        else []

    let bound =
      if isToken(SyntaxKind::OpenBraceToken)
        then Some(parseRecordTypeBound())
      else if isToken(SyntaxKind::OpenParenToken)
        then Some(parseTupleTypeBound())
      else None

    {
      attributes
      keyword
      name
      typeParameters
      bound
      type_: undefined
    }
  }

  fn parseExport(attributes: List<Attribute> = []) -> ExportDirective {
    let keyword = consumeToken(SyntaxKind::ExportKeyword)
    let mut statement: ExportedStatement
    let mut identifier: Identifier

    if isToken(SyntaxKind::EnumKeyword) {
      let enumDeclaration = parseEnumDeclaration(attributes)
      statement = ExportedStatement::EnumDeclaration(enumDeclaration)
      identifier = enumDeclaration.name
    }
    else if isToken(SyntaxKind::TraitKeyword) {
      let traitDeclaration = parseTraitDeclaration(attributes)
      statement = ExportedStatement::TraitDeclaration(traitDeclaration)
      identifier = traitDeclaration.name
    }
    else if isToken(SyntaxKind::TypeKeyword) {
      let typeDeclaration = parseTypeDeclaration(attributes)
      statement = ExportedStatement::TypeDeclaration(typeDeclaration)
      identifier = typeDeclaration.name
    }
    else if attributes.isEmpty() {
      if isToken(SyntaxKind::FnKeyword) {
        let functionDeclaration = parseFunctionDeclaration()
        statement = ExportedStatement::FunctionDeclaration(functionDeclaration)
        if let Option::Some(name) = functionDeclaration.name {
          identifier = name
        }
        else input.croak('Can not export function without a name')
      }
      else if isToken(SyntaxKind::LetKeyword) {
        input.next()
        let variableDeclaration = parseVariableDeclaration()
        statement = ExportedStatement::VariableDeclaration(variableDeclaration)
        if let Pattern::Identifier(name) = variableDeclaration.pattern {
          identifier = name
        }
        else input.croak('Can not export a let declaration without a identifier pattern')
      }
      else input.croak('Expected trait, type, function or variable declaration after export')
    }
    else attributeNotSupported()

    {
      keyword
      identifier
      statement
    }
  }

  fn parseImport() -> ImportDirective {
    let importKeyword = consumeToken(SyntaxKind::ImportKeyword)

    let locator =
      match input.next() {
        Token::StringLiteral(stringLiteral) => stringLiteral
        _ => input.croak('Expected string, ' + butGot())
      }
    if locator.parts.size() != 1 then panic('More than one part in import string')
    let parts = locator.parts.first().unwrap().value[0].value.split(':')
    if parts > 2 then input.croak('Illegal token ":" used in import path')
    let domain = if parts.length == 2 then Some(parts[0]) else None
    let path = if parts.length == 2 then parts[1] else parts[0]

    let asKeyword = consumeToken(SyntaxKind::AsKeyword)
    let specifier =
      if isToken(SyntaxKind::OpenBraceToken)
        then ImportSpecifier::ObjectDestructure(parseObjectDestructure())
      else if isToken(SyntaxKind::AsteriskToken)
        then ImportSpecifier::Asterisk(consumeToken(SyntaxKind::AsteriskToken))
      else ImportSpecifier::Identifier(consumeIdentifier())

    {
      importKeyword
      domain
      path
      asKeyword
      specifier

      module: None
    }
  }

  fn parseObjectDestructure() -> ObjectDestructure {
    let openBrace = expect(SyntaxKind::OpenBraceToken)
    let members = delimited(SyntaxKind::OpenBraceToken, SyntaxKind::CloseBraceToken, SyntaxKind::CommaToken, parseObjectDestructureMember, false)
    let closeBrace = consumeToken(SyntaxKind::CloseBraceToken)

    {
      openBrace
      members
      closeBrace
    }
  }

  fn parseObjectDestructureMember() -> ObjectDestructureMember {
    let property = consumeIdentifier()
    let local =
      if isToken(SyntaxKind::ColonToken) {
        input.next()
        consumeIdentifier()
      }
      else property

    {
      property
      local
    }
  }

  fn parseBlock() -> Block {
    let openBrace = Some(expect(SyntaxKind::OpenBraceToken))
    let statements = delimited(SyntaxKind::OpenBraceToken, SyntaxKind::CloseBraceToken, SyntaxKind::SemicolonToken, parseBlockLevelStatement, false)
    let closeBrace = Some(consumeToken(SyntaxKind::CloseBraceToken))

    {
      openBrace
      statements
      closeBrace
      type_: undefined
    }
  }

  fn parseWhile() -> WhileLoop {
    let keyword = consumeToken(SyntaxKind::WhileKeyword)
    let condition = parseExpression()
    let body = parseBlock()

    {
      keyword
      condition
      body
    }
  }

  fn parseIdentifierOrTypePath() -> Expression {
    let identifier = consumeIdentifier()
    if isToken(SyntaxKind::ColonColonToken)
      then Expression::TypePathExpression({
        typePath: parseTypePath(Some(identifier))
      })
      else maybeAccess(Expression::Identifier(identifier))
  }

  fn parseFunctionDeclaration(optionalBody = false) -> FunctionDeclaration {
    consumeToken(SyntaxKind::FnKeyword)
    let name =
      match input.peek() {
        Token::Identifier(identifier) => {
          input.next()
          Some(identifier)
        }
        _ => None
      }
    let typeParameters =
      if isToken(SyntaxKind::LessThanToken)
        then delimited(SyntaxKind::LessThanToken, SyntaxKind::GreaterThanToken, SyntaxKind::CommaToken, parseTypeParameter, true)
        else []
    let openParenOrBar = expect(SyntaxKind::OpenParenToken)
    let parameterList = delimited(SyntaxKind::OpenParenToken, SyntaxKind::CloseParenToken, SyntaxKind::CommaToken, parseVariableDeclaration, false)
    let closeParenOrBar = consumeToken(SyntaxKind::CloseParenToken)

    let returnType =
      if maybeConsumeToken(SyntaxKind::MinusGreaterThanToken).isSome()
        then Some(parseTypeBound())
        else None

    let body =
      if isToken(SyntaxKind::OpenBraceToken) or not optionalBody
        then Some(parseBlock())
        else None

    {
      name
      typeParameters
      openParenOrBar
      parameterList
      closeParenOrBar
      returnType
      body
      type_: undefined
    }
  }

  fn parseLambda() -> FunctionDeclaration {
    let openParenOrBar = expect(SyntaxKind::BarToken)
    let parameterList = delimited(SyntaxKind::BarToken, SyntaxKind::BarToken, SyntaxKind::CommaToken, parseVariableDeclaration, false)
    let closeParenOrBar = consumeToken(SyntaxKind::BarToken)

    let body =
      if isToken(SyntaxKind::OpenBraceToken)
        then Some(parseBlock())
        else Some({
          openBrace: None
          statements: [parseBlockLevelStatement()]
          closeBrace: None
          type_: undefined
        })

    {
      name: None
      typeParameters: []
      openParenOrBar
      parameterList
      closeParenOrBar
      returnType: None
      body
      type_: undefined
    }
  }

  fn parseVariableDeclaration() -> VariableDeclaration {
    let mutable = maybeConsumeToken(SyntaxKind::MutKeyword).isSome()
    let pattern = parsePattern()

    {
      pattern
      mutable
      typeBound: maybeConsumeToken(SyntaxKind::ColonToken).map(|_| parseTypeBound())
      initializer: maybeConsumeToken(SyntaxKind::EqualsToken).map(|_| parseExpression())
    }
  }

  fn parseIf() -> Expression {
    let ifKeyword = consumeToken(SyntaxKind::IfKeyword)

    if isToken(SyntaxKind::LetKeyword)
      then Expression::IfLetExpression(parseIfLetExpression(ifKeyword))
      else Expression::IfExpression(parseIfExpression(ifKeyword))
  }

  fn parseIfExpression(ifKeyword: SimpleToken) -> IfExpression {
    let condition = parseExpression()

    let then_: Block =
      if isToken(SyntaxKind::OpenBraceToken)
        then parseBlock()
        else {
          consumeToken(SyntaxKind::ThenKeyword)
          {
            openBrace: None
            statements: [parseBlockLevelStatement()]
            closeBrace: None
            type_: undefined
          }
        }

    {
      ifKeyword
      condition
      then_
      else_:
        if isToken(SyntaxKind::ElseKeyword) {
          input.next()
          Some(
            if isToken(SyntaxKind::OpenBraceToken)
              then parseBlock()
              else ({
                openBrace: None
                statements: [parseBlockLevelStatement()]
                closeBrace: None
                type_: undefined
              })
          )
        }
        else None
    }
  }

  fn parseIfLetExpression(ifKeyword: SimpleToken) -> IfLetExpression {
    let letKeyword = consumeToken(SyntaxKind::LetKeyword)
    let pattern = parsePattern()
    let equalsToken = consumeToken(SyntaxKind::EqualsToken)
    let expression = parseExpression()

    let then_: Block =
      if isToken(SyntaxKind::OpenBraceToken)
        then parseBlock()
        else {
          consumeToken(SyntaxKind::ThenKeyword)
          {
            openBrace: None
            statements: [parseBlockLevelStatement()]
            closeBrace: None
            type_: undefined
          }
        }

    {
      ifKeyword
      letKeyword
      pattern
      expression
      then_
      else_:
        if isToken(SyntaxKind::ElseKeyword) {
          input.next()
          Some(
            if isToken(SyntaxKind::OpenBraceToken)
              then parseBlock()
              else ({
                openBrace: None
                statements: [parseBlockLevelStatement()]
                closeBrace: None
                type_: undefined
              })
          )
        }
        else None
    }
  }

  fn parseMatch() -> MatchExpression {
    {
      matchKeyword: consumeToken(SyntaxKind::MatchKeyword)
      expression: parseExpression()
      openBrace: expect(SyntaxKind::OpenBraceToken)
      patterns: delimited(SyntaxKind::OpenBraceToken, SyntaxKind::CloseBraceToken, SyntaxKind::CommaToken, parseMatchArm, false)
      closeBrace: consumeToken(SyntaxKind::CloseBraceToken)
    }
  }

  fn parseMatchArm() -> MatchArm {
    let pattern = parsePattern()
    let arrow = consumeToken(SyntaxKind::EqualsGreaterThanToken)
    let block =
      if isToken(SyntaxKind::OpenBraceToken)
        then parseBlock()
        else {{
          openBrace: None
          statements: [parseBlockLevelStatement()]
          closeBrace: None
          type_: undefined
        }}
    {
      pattern
      arrow
      block
    }
  }

  fn parseUnaryExpression() -> UnaryExpression {
    match input.next() {
      Token::SimpleToken(operator) => match operator.kind {
        SyntaxKind::NotKeyword => {
          {operator, rhs: parseExpression(operator.kind.precedence())}
        }
        SyntaxKind::MinusToken => {
          {operator, rhs: parseExpression(operator.kind.precedence())}
        }
        SyntaxKind::PlusToken => {
          {operator, rhs: parseExpression(operator.kind.precedence())}
        }
        _ => unexpected()
      }
      _ => unexpected()
    }
  }

  fn parseListLiteral() -> ListLiteral {
    let openBracket = expect(SyntaxKind::OpenBracketToken)
    let members = delimited(SyntaxKind::OpenBracketToken, SyntaxKind::CloseBracketToken, SyntaxKind::CommaToken, parseExpression, false)
    let closeBracket = consumeToken(SyntaxKind::CloseBracketToken)

    {
      openBracket
      members
      closeBracket
    }
  }

  fn parseRecordLiteral() -> RecordLiteral {
    let openBrace = expect(SyntaxKind::OpenBraceToken)
    let members = delimited(SyntaxKind::OpenBraceToken, SyntaxKind::CloseBraceToken, SyntaxKind::CommaToken, parseRecordLiteralMember, false)
    let closeBrace = consumeToken(SyntaxKind::CloseBraceToken)
    {
      openBrace
      members
      closeBrace
    }
  }

  fn parseRecordLiteralMember() -> RecordLiteralMember {
    let name = consumeIdentifier()
    let value =
      if isToken(SyntaxKind::ColonToken) {
        input.next()
        parseExpression()
      }
      else Expression::Identifier(name)

    {
      name
      value
    }
  }

  fn parseTupleOrExpression(forceTuple) {
    let openParen = expect(SyntaxKind::OpenParenToken)
    let expressions = delimited(SyntaxKind::OpenParenToken, SyntaxKind::CloseParenToken, SyntaxKind::CommaToken, || parseExpression(0, true), false)
    let closeParen = consumeToken(SyntaxKind::CloseParenToken)

    if not forceTuple and expressions.length == 1
      then expressions[0]
      else Expression::TupleLiteral({
        openParen
        expressions
        closeParen
      })
  }

  fn parsePattern() -> Pattern {
    if let Option::Some(token) = maybeConsumeToken(SyntaxKind::UnderscoreToken)
      then Pattern::CatchAll(token)
    else if isToken(SyntaxKind::OpenParenToken)
      then Pattern::Tuple(parseTuplePattern())
    else if isToken(SyntaxKind::OpenBraceToken)
      then Pattern::Record(parseRecordPattern())
    else {
      let identifier = consumeIdentifier()

      if isToken(SyntaxKind::ColonColonToken)
      or isToken(SyntaxKind::OpenParenToken)
      or isToken(SyntaxKind::OpenBraceToken) {
        let typePath = parseTypePath(Some(identifier))

        if isToken(SyntaxKind::OpenParenToken)
          then Pattern::TupleType(typePath, parseTuplePattern())
        else if isToken(SyntaxKind::OpenBraceToken)
          then Pattern::RecordType(typePath, parseRecordPattern())
        else Pattern::UnitType(typePath)
      }
      else Pattern::Identifier(identifier)
    }
  }

  fn parseRecordPattern() -> RecordPattern {
    let openBrace = expect(SyntaxKind::OpenBraceToken)
    let properties = delimited(SyntaxKind::OpenBraceToken, SyntaxKind::CloseBraceToken, SyntaxKind::CommaToken, parseRecordPatternMember, false)
    let closeBrace = consumeToken(SyntaxKind::CloseBraceToken)

    {openBrace, properties, closeBrace}
  }

  fn parseRecordPatternMember() -> RecordPatternMember {
    let property = consumeIdentifier()
    let pattern =
      if maybeConsumeToken(SyntaxKind::ColonToken).isSome()
        then parsePattern()
        else Pattern::Identifier(property)

    {property, pattern}
  }

  fn parseTuplePattern() -> TuplePattern {
    let openParen = expect(SyntaxKind::OpenParenToken)
    let properties = delimited(SyntaxKind::OpenParenToken, SyntaxKind::CloseParenToken, SyntaxKind::CommaToken, parsePattern, false)
    let closeParen = consumeToken(SyntaxKind::CloseParenToken)

    {openParen, properties, closeParen}
  }

  fn parseTypeBound() -> TypeBound {
    if isToken(SyntaxKind::LessThanToken)
      then parseFunctionTypeBound(None)
    else if isToken(SyntaxKind::OpenParenToken) {
      let tuple = parseTupleTypeBound()
      if isToken(SyntaxKind::MinusGreaterThanToken)
        then parseFunctionTypeBound(Some(tuple))
        else tuple
    }
    else if isToken(SyntaxKind::OpenBraceToken)
      then parseRecordTypeBound()
    else parseNamedTypeBound()
  }

  fn parseFunctionTypeBound(tuple: Option<TypeBound>) -> TypeBound {
    let typeParameters =
      if tuple.isNone() and isToken(SyntaxKind::LessThanToken)
        then delimited(SyntaxKind::LessThanToken, SyntaxKind::GreaterThanToken, SyntaxKind::CommaToken, parseTypeParameter, true)
        else []

    let parameters = tuple.unwrapOrElse(parseTupleTypeBound).getTupleTypeBound()
    consumeToken(SyntaxKind::MinusGreaterThanToken)
    let returnType = parseTypeBound()

    TypeBound::FunctionTypeBound({
      typeParameters
      parameters
      returnType
    })
  }

  fn parseNamedTypeBound() -> TypeBound {
    let path = parseTypePath(None)
    let typeParameters =
      if isToken(SyntaxKind::LessThanToken)
        then delimited(SyntaxKind::LessThanToken, SyntaxKind::GreaterThanToken, SyntaxKind::CommaToken, parseTypeBound, true)
        else []

    TypeBound::NamedTypeBound({
      path
      typeParameters
    })
  }

  fn parseRecordTypeBound() -> TypeBound {
    expect(SyntaxKind::OpenBraceToken)
    let openBrace = expect(SyntaxKind::OpenBraceToken)
    let properties = delimited(SyntaxKind::OpenBraceToken, SyntaxKind::CloseBraceToken, SyntaxKind::CommaToken, parseRecordTypeBoundMember, false)
    let closeBrace = consumeToken(SyntaxKind::CloseBraceToken)

    TypeBound::RecordTypeBound({
      openBrace
      properties
      closeBrace
    })
  }

  fn parseRecordTypeBoundMember() -> RecordTypeBoundMember {
    let name = consumeIdentifier()
    consumeToken(SyntaxKind::ColonToken)
    let typeBound = parseTypeBound()
    {
      name
      typeBound
    }
  }

  fn parseTupleTypeBound() -> TypeBound {
    let openParen = expect(SyntaxKind::OpenParenToken)
    let properties = delimited(SyntaxKind::OpenParenToken, SyntaxKind::CloseParenToken, SyntaxKind::CommaToken, parseTypeBound, false)
    let closeParen = consumeToken(SyntaxKind::CloseParenToken)

    TypeBound::TupleTypeBound({
      openParen
      properties
      closeParen
    })
  }

  fn parseTypeParameter() -> TypeParameter {
    let name = consumeIdentifier()
    let defaultValue =
      if isToken(SyntaxKind::EqualsToken) {
        input.next()
        Some(parseTypeBound())
      }
      else None
    {
      name
      defaultValue
    }
  }

  fn parseTypePath(identifier: Option<Identifier>) -> TypePath {
    let i = identifier.unwrapOrElse(consumeIdentifier)

    if maybeConsumeToken(SyntaxKind::ColonColonToken).isSome()
      then TypePath::Object(i, parseTypePath(None))
      else TypePath::Member(i)
  }

  parseModule()
}
