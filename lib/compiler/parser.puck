import 'puck:js' as {Object, console, global, null, typeof, undefined}
import '../ast/ast.puck' as {
  Token
  Expression
  Identifier

  Block
  EnumDeclaration
  EnumMember
  FunctionDeclaration
  ImplDeclaration
  ImplShorthandDeclaration
  ObjectDestructure
  ObjectDestructureMember
  TraitDeclaration
  TypeBound
  FunctionTypeBound
  NamedTypeBound
  ObjectTypeBound
  TupleTypeBound
  TypeDeclaration
  TypeParameter
  TypePath
  TypeProperty
  VariableDeclaration

  Pattern
  RecordPattern
  RecordPatternMember
  TuplePattern

  AssignmentExpression
  BinaryExpression
  CallExpression
  IfExpression
  IfLetExpression
  MatchExpression
  MatchArm
  UnaryExpression
  WhileLoop

  ListLiteral
  ObjectLiteral
  ObjectLiteralMember
}
import 'ast.ts' as {
  SyntaxKind
  isIdentifier
  isIndex
  isMember
  precedence
  textToToken
  tokenToText
}

export fn parse(input) { // : TokenStream

  fn isToken(kind, withDummy = false) { // kind: SyntaxKind
    let token = input.peek(withDummy)
    token and token.kind == kind
  }

  fn tokenName(token: Token) {
    if typeof(tokenToText[token.kind]) == 'function' then tokenToText[token.kind](token)
    else if tokenToText[token.kind] then tokenToText[token.kind]
    else SyntaxKind[token.kind]
  }

  fn expect(expect, name = 'token') { // kind: SyntaxKind
    if not isToken(expect) {
      let token = input.peek()
      let expectedText = ': "' + tokenName({kind: expect}) + '"'

      let but =
        if token {
          let got = tokenName(token)
          'got "$got"'
        }
        else 'reached end of file'

      console.error(token)
      input.croak('Expected $name$expectedText, but $but')
    }
  }

  // fn consumeToken(token: SyntaxKind = undefined, name = undefined) {
  fn consumeToken(token, name = 'token') {
    if token then expect(token, name)
    return input.next()
  }

  fn maybeConsumeToken<T>(token, name = 'token') -> Option<T> {
    if isToken(token)
      then Some(consumeToken(token, name))
      else None
  }

  fn skipKeyword(kw) { // kind: SyntaxKind
    expect(kw, 'keyword')
    input.next()
  }

  fn unexpected() {
    let token = input.peek()
    console.error('token', token, typeof(token))
    let name = tokenToText[token.kind]
    input.croak('Unexpected token: $name')
  }

  fn consumeSeparator(kind) { // kind: SyntaxKind
    if not input.eof() {
      let mut token = input.peek(true)

      if token.kind == SyntaxKind.NewlineToken
      or token.kind == SyntaxKind.Comment
        then input.next(true)
        else consumeToken(kind)
    }
  }

  fn isAssignment(token: Token) {
    if not token then return undefined

    token.kind == SyntaxKind.EqualsToken
      or token.kind == SyntaxKind.PlusEqualsToken
      or token.kind == SyntaxKind.MinusEqualsToken
      or token.kind == SyntaxKind.AsteriskEqualsToken
      or token.kind == SyntaxKind.AsteriskAsteriskEqualsToken
      or token.kind == SyntaxKind.SlashEqualsToken
      or token.kind == SyntaxKind.PercentEqualsToken
  }

  fn maybeParseOperator() -> Token {
    if isAssignment(input.peek())
      or isToken(SyntaxKind.EqualsEqualsToken)
      or isToken(SyntaxKind.ExclamationEqualsToken)
      or isToken(SyntaxKind.GreaterThanToken)
      or isToken(SyntaxKind.GreaterThanEqualsToken)
      or isToken(SyntaxKind.LessThanToken)
      or isToken(SyntaxKind.LessThanEqualsToken)
      or isToken(SyntaxKind.PlusToken)
      or isToken(SyntaxKind.MinusToken)
      or isToken(SyntaxKind.AsteriskToken)
      or isToken(SyntaxKind.AsteriskAsteriskToken)
      or isToken(SyntaxKind.SlashToken)
      or isToken(SyntaxKind.PercentToken)
      or isToken(SyntaxKind.AndKeyword)
      or isToken(SyntaxKind.OrKeyword)
      or isToken(SyntaxKind.NotKeyword)
    then input.peek()
    else null
  }

  fn maybeBinary(left: Expression, myPrecedence) -> Expression {
    let mut operator = maybeParseOperator()
    if (operator) {
      let mut hisPrecedence = precedence[operator.kind]

      if hisPrecedence == undefined {
        let name = tokenToText[operator.kind]
        let json = global.JSON.stringify(operator)
        throw 'No precedence for $name: $json'
      }

      if (hisPrecedence > myPrecedence) {
        input.next()
        let mut e
        let mut innerExpression = maybeBinary(parseAtom(), hisPrecedence)
        if isAssignment(operator) {
          if isIdentifier(left) or isMember(left) or isIndex(left) {
            let a: AssignmentExpression = {
              kind: SyntaxKind.AssignmentExpression,
              lhs: left,
              token: operator,
              rhs: innerExpression,
            }
            e = a
          }
          else {
            input.croak('Can only assign to an identifier')
          }
        }
        else {
          let b: BinaryExpression = {
            kind: SyntaxKind.BinaryExpression,
            lhs: left,
            operator,
            rhs: innerExpression,
          }
          e = b
        }
        return maybeBinary(e, myPrecedence)
      }
    }
    left
  }

  fn maybeCall(expr: Expression) -> Expression {
    if isToken(SyntaxKind.OpenParenToken, true)
      then maybeCall(maybeMemberAccess({
        kind: SyntaxKind.CallExpression,
        func: expr,
        openParen: input.peek(),
        argumentList: delimited('(', ')', ',', parseExpression, false),
        closeParen: consumeToken(SyntaxKind.CloseParenToken),
      }))
      else expr
  }

  fn maybeMemberAccess(token: Expression) -> Expression {
    if isToken(SyntaxKind.DotToken) {
      input.next()
      maybeAccess({
        kind: SyntaxKind.MemberAccess
        object: token
        member: consumeToken(SyntaxKind.Identifier, 'identifier')
      })
    }
    else token
  }

  fn maybeIndexAccess(token: Expression) -> Expression {
    if isToken(SyntaxKind.OpenBracketToken, true) {
      input.next()
      let index = parseExpression()
      consumeToken(SyntaxKind.CloseBracketToken)

      maybeAccess({
        kind: SyntaxKind.IndexAccess
        object: token
        index
      })
    }
    else token
  }

  fn maybeAccess(token: Expression) -> Expression {
    maybeIndexAccess(maybeMemberAccess(token))
  }

  // fn delimited<T>(start: SyntaxKind|string, stop: SyntaxKind|string, separator: SyntaxKind|string|(fn () then void), parser: fn () then T) -> Array<T> {
  fn delimited<T>(mut start, mut stop, mut separator, parser: () -> T, consumeStop = true) -> List<T> {
    if typeof(start) == 'string' then start = textToToken[start]
    if typeof(stop) == 'string' then stop = textToToken[stop]
    if typeof(separator) == 'string' then separator = textToToken[separator]

    let mut parts = []
    let mut first = true
    consumeToken(start)

    while not input.eof() {
      if isToken(stop) then break

      if first then first = false
      else if typeof(separator) == 'function' then separator()
      else consumeSeparator(separator)

      let mut part
      while not part {
        if isToken(stop) then break
        part = parser()
      }

      if part then parts.push(part)
    }

    if consumeStop then consumeToken(stop)
    parts
  }

  fn parseEnumDeclaration() -> EnumDeclaration {
    let keyword = consumeToken(SyntaxKind.EnumKeyword)
    let name = consumeToken(SyntaxKind.Identifier, 'identifier')
    let typeParameters =
      if isToken(SyntaxKind.LessThanToken)
        then delimited('<', '>', ',', parseTypeParameter)
        else []

    let openBrace = input.peek()
    let members = delimited('{', '}', ',', parseEnumMember, false)
    let closeBrace = consumeToken(SyntaxKind.CloseBraceToken)

    {
      kind: SyntaxKind.EnumDeclaration
      keyword
      name
      typeParameters
      openBrace
      members
      closeBrace
    }
  }

  fn parseEnumMember() -> EnumMember {
    let name = consumeToken(SyntaxKind.Identifier, 'identifier')

    let bound =
      if isToken(SyntaxKind.OpenBraceToken)
        then Some(parseObjectTypeBound())
      else if isToken(SyntaxKind.OpenParenToken)
        then Some(parseTupleTypeBound())
      else None

    {
      kind: SyntaxKind.EnumMember
      name
      bound
    }
  }

  fn parseObjectDestructureMember() -> ObjectDestructureMember {
    let property = consumeToken(SyntaxKind.Identifier, 'identifier')
    let local =
      if isToken(SyntaxKind.ColonToken) {
        input.next()
        consumeToken(SyntaxKind.Identifier, 'identifier')
      }
      else property

    {
      kind: SyntaxKind.ObjectDestructureMember,
      property,
      local,
    }
  }

  fn parseObjectDestructure() -> ObjectDestructure {
    let openBrace = input.peek()
    let members = delimited('{', '}', ',', parseObjectDestructureMember, false)
    let closeBrace = consumeToken(SyntaxKind.CloseBraceToken)

    {
      kind: SyntaxKind.ObjectDestructure
      openBrace
      members
      closeBrace
    }
  }

  fn parseRecordPatternMember() -> RecordPatternMember {
    let property = consumeToken(SyntaxKind.Identifier, 'identifier')
    let pattern =
      if maybeConsumeToken(SyntaxKind.ColonToken).isJust()
        then parsePattern()
        else Pattern.Identifier(property)

    {property, pattern}
  }

  fn parseRecordPattern() -> RecordPattern {
    let openBrace = expect(SyntaxKind.OpenBraceToken)
    let properties = delimited('{', '}', ',', parseRecordPatternMember, false)
    let closeBrace = consumeToken(SyntaxKind.CloseBraceToken)

    {openBrace, properties, closeBrace}
  }

  fn parseTuplePattern() -> TuplePattern {
    let openParen = expect(SyntaxKind.OpenParenToken)
    let properties = delimited('(', ')', ',', parsePattern, false)
    let closeParen = consumeToken(SyntaxKind.CloseParenToken)

    {openParen, properties, closeParen}
  }

  fn parsePattern() -> Pattern {
    if maybeConsumeToken(SyntaxKind.UnderscoreToken).isJust()
      then Pattern.CatchAll
    else if isToken(SyntaxKind.OpenParenToken)
      then Pattern.Tuple(parseTuplePattern())
    else if isToken(SyntaxKind.OpenBraceToken)
      then Pattern.Record(parseRecordPattern())
    else {
      let identifier = consumeToken(SyntaxKind.Identifier, 'identifier')

      if isToken(SyntaxKind.ColonColonToken)
      or isToken(SyntaxKind.OpenParenToken)
      or isToken(SyntaxKind.OpenBraceToken) {
        let typePath = parseTypePath(Some(identifier))

        if isToken(SyntaxKind.OpenParenToken)
          then Pattern.TupleType(typePath, parseTuplePattern())
        else if isToken(SyntaxKind.OpenBraceToken)
          then Pattern.RecordType(typePath, parseRecordPattern())
        else Pattern.UnitType(typePath)
      }
      else Pattern.Identifier(identifier)
    }
  }

  fn parseTraitDeclaration() -> TraitDeclaration {
    let keyword = consumeToken(SyntaxKind.TraitKeyword)
    let name = consumeToken(SyntaxKind.Identifier, 'identifier')
    let typeParameters =
      if isToken(SyntaxKind.LessThanToken)
        then delimited('<', '>', ',', parseTypeParameter)
      else []

    let openBrace = expect(SyntaxKind.OpenBraceToken)
    let members = delimited('{', '}', ';', || parseFunctionDeclaration(true), false)
      .map(|f: FunctionDeclaration| {
        if f.name.isNothing()
          then input.croak('Trait functions must have a name')
        if f.returnType.isNothing()
          then input.croak('Trait functions must have a return type')

        f
      })
    let closeBrace = consumeToken(SyntaxKind.CloseBraceToken)

    {
      kind: SyntaxKind.TraitDeclaration
      keyword
      name
      typeParameters
      openBrace
      members
      closeBrace
    }
  }

  fn parseImplDeclaration() {
    let implKeyword = consumeToken(SyntaxKind.ImplKeyword)
    let typeParameters =
      if isToken(SyntaxKind.LessThanToken)
        then delimited('<', '>', ',', parseTypeParameter)
      else []

    let trait_ = parseTypeBound()
    let {forKeyword, type_}: {forKeyword: Option<Token>, type_: Option<TypeBound>} =
      if isToken(SyntaxKind.ForKeyword)
        then {
          forKeyword: Some(consumeToken(SyntaxKind.ForKeyword))
          type_: Some(parseTypeBound())
        }
        else {{
          forKeyword: None
          type_: None
        }}

    let openBrace = expect(SyntaxKind.OpenBraceToken)
    let members = delimited('{', '}', ';', parseFunctionDeclaration, false)
      .map(|f: FunctionDeclaration| {
        if f.name.isNothing()
          then input.croak('Trait functions must have a name')
        if f.returnType.isNothing()
          then input.croak('Trait functions must have a return type')

        f
      })
    let closeBrace = consumeToken(SyntaxKind.CloseBraceToken)

    if let Option::Some(type_) = type_
      then {
        kind: SyntaxKind.ImplDeclaration
        implKeyword
        typeParameters
        trait_
        forKeyword: forKeyword.unwrap()
        type_
        openBrace
        members
        closeBrace
      }
      else {{
        kind: SyntaxKind.ImplShorthandDeclaration
        implKeyword
        typeParameters
        type_: trait_
        openBrace
        members
        closeBrace
      }}
  }

  fn parseFunctionTypeBound(tuple) -> FunctionTypeBound {
    let typeParameters =
      if not tuple and isToken(SyntaxKind.LessThanToken)
        then delimited('<', '>', ',', parseTypeParameter)
      else []

    let arguments = tuple or parseTupleTypeBound()
    consumeToken(SyntaxKind.MinusGreaterThanToken)
    let returnType = parseTypeBound()

    {
      kind: SyntaxKind.FunctionTypeBound
      typeParameters
      arguments
      returnType
    }
  }

  fn parseNamedTypeBound() -> NamedTypeBound {
    let path = parseTypePath(None)
    let typeParameters =
      if isToken(SyntaxKind.LessThanToken)
        then delimited('<', '>', ',', parseTypeBound)
      else []

    {
      kind: SyntaxKind.NamedTypeBound
      path
      typeParameters
    }
  }

  fn parseObjectTypeBound() -> ObjectTypeBound {
    expect(SyntaxKind.OpenBraceToken)
    let openBrace = input.peek()
    let properties = delimited('{', '}', ',', parseTypeProperty, false)
    let closeBrace = consumeToken(SyntaxKind.CloseBraceToken)

    {
      kind: SyntaxKind.ObjectTypeBound
      openBrace
      properties
      closeBrace
    }
  }

  fn parseTupleTypeBound() -> TupleTypeBound {
    expect(SyntaxKind.OpenParenToken)
    let openParen = input.peek()
    let properties = delimited('(', ')', ',', parseTypeBound, false)
    let closeParen = consumeToken(SyntaxKind.CloseParenToken)
    {
      kind: SyntaxKind.TupleTypeBound
      openParen
      properties
      closeParen
    }
  }

  fn parseTypeBound() -> TypeBound {
    if isToken(SyntaxKind.LessThanToken)
      then parseFunctionTypeBound(undefined)
    else if isToken(SyntaxKind.OpenParenToken) {
      let tuple = parseTupleTypeBound()
      if isToken(SyntaxKind.MinusGreaterThanToken)
        then parseFunctionTypeBound(tuple)
        else tuple
    }
    else if isToken(SyntaxKind.OpenBraceToken)
      then parseObjectTypeBound()
    else parseNamedTypeBound()
  }

  fn parseTypeParameter() -> TypeParameter {
    let name = consumeToken(SyntaxKind.Identifier, 'identifier')
    let defaultValue =
      if isToken(SyntaxKind.EqualsToken) {
        input.next()
        Some(parseTypeBound())
      }
      else None
    {
      kind: SyntaxKind.TypeParameter
      name
      defaultValue
    }
  }

  fn parseTypePath(identifier: Option<Identifier>) -> TypePath {
    let i = identifier.unwrapOrElse(|| consumeToken(SyntaxKind.Identifier, 'identifier'))

    if maybeConsumeToken(SyntaxKind.ColonColonToken).isJust()
      then TypePath::Object(i, parseTypePath(None))
      else TypePath::Member(i)
  }

  fn parseTypeProperty() -> TypeProperty {
    let name = consumeToken(SyntaxKind.Identifier, 'identifier')
    consumeToken(SyntaxKind.ColonToken)
    let typeBound = parseTypeBound()
    {
      kind: SyntaxKind.TypeProperty
      name
      typeBound
    }
  }

  fn parseTypeDeclaration() -> TypeDeclaration {
    let keyword = consumeToken(SyntaxKind.TypeKeyword)
    let name = consumeToken(SyntaxKind.Identifier, 'identifier')
    let typeParameters =
      if isToken(SyntaxKind.LessThanToken)
        then delimited('<', '>', ',', parseTypeParameter)
      else []

    let bound =
      if isToken(SyntaxKind.OpenBraceToken)
        then Some(parseObjectTypeBound())
      else if isToken(SyntaxKind.OpenParenToken)
        then Some(parseTupleTypeBound())
      else None

    {
      kind: SyntaxKind.TypeDeclaration
      keyword
      name
      typeParameters
      bound
      type_: undefined
    }
  }

  fn parseVariableDeclaration() -> VariableDeclaration {
    let mutable = maybeConsumeToken(SyntaxKind.MutKeyword).isJust()
    let pattern = parsePattern()

    {
      kind: SyntaxKind.VariableDeclaration
      pattern
      mutable
      typeBound: maybeConsumeToken(SyntaxKind.ColonToken).map(|_| parseTypeBound())
      initializer: maybeConsumeToken(SyntaxKind.EqualsToken).map(|_| parseExpression())
    }
  }

  fn parseFunctionDeclaration(optionalBody = false) -> FunctionDeclaration {
    consumeToken(SyntaxKind.FnKeyword)
    let name = maybeConsumeToken(SyntaxKind.Identifier, 'identifier')
      if isToken(SyntaxKind.Identifier)
        then Some(consumeToken(SyntaxKind.Identifier, 'identifier'))
        else None
    let typeParameters =
      if isToken(SyntaxKind.LessThanToken)
        then delimited('<', '>', ',', parseTypeParameter)
      else []
    let parameterList = delimited('(', ')', ',', parseVariableDeclaration)

    let returnType =
      if maybeConsumeToken(SyntaxKind.MinusGreaterThanToken).isJust() {
        Some(parseTypeBound())
      }
      else None

    let body =
      if isToken(SyntaxKind.OpenBraceToken) or not optionalBody
        then Some(parseBlock())
        else None

    {
      kind: SyntaxKind.Function
      name
      typeParameters
      parameterList
      returnType
      body
      type_: undefined
    }
  }

  fn parseLambda() -> FunctionDeclaration {
    let parameterList = delimited('|', '|', ',', parseVariableDeclaration)

    let body =
      if isToken(SyntaxKind.OpenBraceToken)
        then Some(parseBlock())
        else Some({
          kind: SyntaxKind.Block
          expressions: [parseExpression()]
        })

    {
      kind: SyntaxKind.Function
      name: None
      typeParameters: []
      parameterList
      returnType: None
      body
      type_: undefined
    }
  }

  fn parseIfLet(ifKeyword: Token) -> IfLetExpression {
    let letKeyword = skipKeyword(SyntaxKind.LetKeyword)
    let pattern = parsePattern()
    let equalsToken = consumeToken(SyntaxKind.EqualsToken)
    let expression = parseExpression()

    let then_: Block =
      if isToken(SyntaxKind.OpenBraceToken)
        then parseBlock()
        else {
          skipKeyword(SyntaxKind.ThenKeyword)
          {
            kind: SyntaxKind.Block,
            expressions: [parseExpression()],
          }
        }

    {
      kind: SyntaxKind.IfLetExpression
      ifKeyword
      letKeyword
      variableDeclaration: {
        kind: SyntaxKind.VariableDeclaration
        pattern
        mutable: false
        typeBound: None
        initializer: Some(expression)
      }
      then_
      else_:
        if isToken(SyntaxKind.ElseKeyword) {
          input.next()
          Some(
            if isToken(SyntaxKind.OpenBraceToken)
              then parseBlock()
              else ({
                kind: SyntaxKind.Block,
                expressions: [parseExpression()],
              })
          )
        }
        else None
    }
  }

  fn parseIfCondition(ifKeyword: Token) -> IfExpression {
    let condition = parseExpression()

    let then_: Block =
      if isToken(SyntaxKind.OpenBraceToken)
        then parseBlock()
        else {
          skipKeyword(SyntaxKind.ThenKeyword)
          {
            kind: SyntaxKind.Block,
            expressions: [parseExpression()],
          }
        }

    {
      kind: SyntaxKind.IfExpression
      ifKeyword
      condition
      then_
      else_:
        if isToken(SyntaxKind.ElseKeyword) {
          input.next()
          Some(
            if isToken(SyntaxKind.OpenBraceToken)
              then parseBlock()
              else ({
                kind: SyntaxKind.Block,
                expressions: [parseExpression()],
              })
          )
        }
        else None
    }
  }

  fn parseIf() -> Expression {
    let ifKeyword = skipKeyword(SyntaxKind.IfKeyword)

    if isToken(SyntaxKind.LetKeyword)
      then parseIfLet(ifKeyword)
      else parseIfCondition(ifKeyword)
  }

  fn parseMatch() -> MatchExpression {
    {
      kind: SyntaxKind.MatchExpression
      matchKeyword: skipKeyword(SyntaxKind.MatchKeyword)
      expression: parseExpression()
      openBrace: input.peek()
      patterns: delimited('{', '}', ',', parseMatchArm, false)
      closeBrace: consumeToken(SyntaxKind.CloseBraceToken)
    }
  }

  fn parseMatchArm() -> MatchArm {
    let pattern = parsePattern()
    let arrow = consumeToken(SyntaxKind.EqualsGreaterThanToken)
    let block =
      if isToken(SyntaxKind.OpenBraceToken)
        then parseBlock()
        else {{
          kind: SyntaxKind.Block
          expressions: [parseExpression()]
        }}
    {
      pattern
      arrow
      block
    }
  }

  fn parseUnaryExpression() -> UnaryExpression {
    let operator = input.next()

    {
      kind: SyntaxKind.UnaryExpression
      operator
      rhs: parseExpression(precedence[operator.kind])
    }
  }

  fn parseWhile() -> WhileLoop {
    skipKeyword(SyntaxKind.WhileKeyword)

    let condition = parseExpression()
    let body = parseBlock()

    {
      kind: SyntaxKind.WhileLoop
      condition
      body
    }
  }

  fn parseListLiteral() -> ListLiteral {
    let members = delimited('[', ']', ',', parseExpression)
    { kind: SyntaxKind.ListLiteral, members }
  }

  fn parseObjectLiteralMember() -> ObjectLiteralMember {
    let name = consumeToken(SyntaxKind.Identifier, 'identifier')
    let value =
      if isToken(SyntaxKind.ColonToken) {
        input.next()
        parseExpression()
      }
      else name

    {
      kind: SyntaxKind.ObjectLiteralMember
      name
      value
    }
  }

  fn parseObjectLiteral() -> ObjectLiteral {
    let openBrace = input.peek()
    let members = delimited('{', '}', ',', parseObjectLiteralMember, false)
    let closeBrace = consumeToken(SyntaxKind.CloseBraceToken)
    {
      kind: SyntaxKind.ObjectLiteral,
      openBrace
      members
      closeBrace
    }
  }

  fn parseTupleOrExpression(forceTuple) {
    let openParen = input.peek()
    let expressions = delimited('(', ')', ',', || parseExpression(0, true), false)
    let closeParen = consumeToken(SyntaxKind.CloseParenToken)

    if not forceTuple and expressions.length == 1
      then expressions[0]
      else {{
        kind: SyntaxKind.TupleLiteral,
        openParen
        expressions
        closeParen
      }}
  }

  fn parseAtom(forceTuple = false) {
    maybeCall((fn innerParseAtom() {
      if isToken(SyntaxKind.OpenParenToken) then parseTupleOrExpression(forceTuple)
      else if isToken(SyntaxKind.OpenBracketToken) then parseListLiteral()
      else if isToken(SyntaxKind.OpenBraceToken) then parseObjectLiteral()
      else if isToken(SyntaxKind.BarToken) then parseLambda()
      else if isToken(SyntaxKind.IfKeyword) then parseIf()
      else if isToken(SyntaxKind.MatchKeyword) then parseMatch()
      else if isToken(SyntaxKind.FnKeyword) then parseFunctionDeclaration()
      else if isToken(SyntaxKind.LetKeyword) {
        input.next()
        parseVariableDeclaration()
      }
      else if isToken(SyntaxKind.NotKeyword)
           or isToken(SyntaxKind.MinusToken)
           or isToken(SyntaxKind.PlusToken)
        then parseUnaryExpression()
      else if isToken(SyntaxKind.BreakKeyword) then input.next()
      else if isToken(SyntaxKind.ReturnKeyword) then {
        kind: SyntaxKind.ReturnStatement
        keyword: input.next()
        expression: parseExpression()
      }
      else if isToken(SyntaxKind.ThrowKeyword) then {
        kind: input.next().kind
        expression: parseExpression()
      }
      else if isToken(SyntaxKind.TrueKeyword)
           or isToken(SyntaxKind.FalseKeyword)
        then
          maybeAccess({
            kind: SyntaxKind.BooleanLiteral
            value: input.next().kind == SyntaxKind.TrueKeyword
          })
      else if isToken(SyntaxKind.NumberLiteral)
           or isToken(SyntaxKind.StringLiteral)
        then maybeAccess(input.next())
      else if isToken(SyntaxKind.Identifier) {
        let identifier = input.next()
        if isToken(SyntaxKind.ColonColonToken)
          then {
            kind: SyntaxKind.TypePathExpression
            typePath: parseTypePath(Some(identifier))
          }
          else maybeAccess(identifier)
      }
      else unexpected()
    })())
  }

  fn parseExport() {
    let keyword = consumeToken(SyntaxKind.ExportKeyword)
    let mut expression
    let mut identifier
    if isToken(SyntaxKind.EnumKeyword) {
      expression = parseEnumDeclaration()
      identifier = expression.name
    }
    else if isToken(SyntaxKind.FnKeyword) {
      expression = parseFunctionDeclaration()
      let func: FunctionDeclaration = expression
      if let Option::Some(name) = func.name {
        identifier = name
      }
      else input.croak('Can not export function without a name')
    }
    else if isToken(SyntaxKind.LetKeyword) {
      input.next()
      expression = parseVariableDeclaration()
      if let Pattern::Identifier(name) = expression.pattern {
        identifier = name
      }
      else input.croak('Can not export a let declaration without a identifier pattern')
    }
    else if isToken(SyntaxKind.TraitKeyword) {
      expression = parseTraitDeclaration()
      identifier = expression.name
    }
    else if isToken(SyntaxKind.TypeKeyword) {
      expression = parseTypeDeclaration()
      identifier = expression.name
    }
    else input.croak('Expected trait, type, function or variable declaration after export')
    {
      kind: SyntaxKind.ExportDirective
      keyword
      identifier
      expression
    }
  }

  fn parseImport() {
    let importKeyword = consumeToken(SyntaxKind.ImportKeyword)

    let locator = consumeToken(SyntaxKind.StringLiteral)
    if locator.parts.length != 1 then throw Error('More than one part in import string')
    let parts = locator.parts[0].value.split(':')
    if parts > 2 then input.croak('Illegal token ":" used in import path')
    let domain = if parts.length == 2 then Some(parts[0]) else None
    let path = if parts.length == 2 then parts[1] else parts[0]

    let asKeyword = consumeToken(SyntaxKind.AsKeyword)
    let specifier =
      if isToken(SyntaxKind.OpenBraceToken)
        then parseObjectDestructure()
      else if isToken(SyntaxKind.AsteriskToken)
        then consumeToken(false)
      else consumeToken(SyntaxKind.Identifier, 'identifier')

    {
      kind: SyntaxKind.ImportDirective
      importKeyword
      domain
      path
      asKeyword
      specifier
    }
  }

  fn parseTopLevelExpression() {
    if isToken(SyntaxKind.EnumKeyword) then parseEnumDeclaration()
    else if isToken(SyntaxKind.ExportKeyword) then parseExport()
    else if isToken(SyntaxKind.ImplKeyword) then parseImplDeclaration()
    else if isToken(SyntaxKind.ImportKeyword) then parseImport()
    else if isToken(SyntaxKind.TraitKeyword) then parseTraitDeclaration()
    else if isToken(SyntaxKind.TypeKeyword) then parseTypeDeclaration()
    else parseBlockLevelExpression()
  }

  fn parseBlockLevelExpression() {
    if isToken(SyntaxKind.WhileKeyword) then parseWhile()
    else parseExpression()
  }

  fn parseModule() {
    let mut exports = {}
    let mut expressions = []
    while not input.eof() {
      let expression = parseTopLevelExpression()
      if expression {
        expressions.push(expression)
        if expression.kind == SyntaxKind.ExportDirective
          then exports[expression.identifier.name] = expression
      }
      if not input.eof() then consumeSeparator(SyntaxKind.SemicolonToken)
    }
    {
      kind: SyntaxKind.Module
      fileName: input.file.fileName
      path: input.file.absolutePath
      exports
      expressions
    }
  }

  fn parseBlock() -> Block {
    let expressions = delimited('{', '}', ';', parseBlockLevelExpression)
    { kind: SyntaxKind.Block, expressions }
  }

  fn parseExpression(precedence = 0, forceTuple = false) -> Expression {
    maybeCall(maybeAccess(maybeBinary(parseAtom(forceTuple), precedence)))
  }

  parseModule()
}
