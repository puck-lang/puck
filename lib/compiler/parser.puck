import 'puck:js' as {Error, Object, global, null, typeof, undefined}
import '../ast/ast.puck' as {
  Token
  Module
  TopLevelStatement
  BlockLevelStatement
  Expression
  SimpleLiteral
  Attribute
  AttributeData

  EnumDeclaration
  EnumMember
  ImplDeclaration
  ImplShorthandDeclaration
  TraitDeclaration
  TypeDeclaration

  ExportDirective
  ExportedStatement
  ImportDirective
  ImportSpecifier
  ObjectDestructure
  ObjectDestructureMember

  Block
  ReturnStatement
  WhileLoop

  Identifier
  FunctionDeclaration
  VariableDeclaration

  AssignmentExpression
  BinaryExpression
  CallExpression
  IfExpression
  IfLetExpression
  MatchExpression
  MatchArm
  TypePathExpression
  TypePath
  UnaryExpression

  IndexAccess
  MemberAccess

  BooleanLiteral
  ListLiteral
  NumberLiteral
  RecordLiteral
  RecordLiteralMember
  StringLiteral
  StringLiteralPart
  TupleLiteral

  Pattern
  RecordPattern
  RecordPatternMember
  TuplePattern

  TypeBound
  FunctionTypeBound
  NamedTypeBound
  RecordTypeBound
  RecordTypeBoundMember
  TupleTypeBound
  TypeParameter
}
import 'ast.ts' as {
  SyntaxKind
  precedence
  textToToken
  tokenToText
}

export fn parse(input) { // : TokenStream

  fn isToken(kind, withDummy = false) -> Bool { // kind: SyntaxKind
    let token = input.peek(withDummy)
    token and token.kind == kind
  }

  fn tokenName(token) -> String { // : {kind: SyntaxKind}
    if typeof(tokenToText[token.kind]) == 'function' then tokenToText[token.kind](token)
    else if tokenToText[token.kind] then tokenToText[token.kind]
    else SyntaxKind[token.kind]
  }

  fn expect(expect, name = 'token') -> Token { // kind: SyntaxKind
    let token = input.peek()
    if not isToken(expect) {
      let expectedText = ': "' + tokenName({kind: expect}) + '"'

      let but =
        if token {
          let got = tokenName(token)
          'got "$got"'
        }
        else 'reached end of file'

      input.croak('Expected $name$expectedText, but $but')
    }
    token
  }

  // fn consumeToken(token: SyntaxKind = undefined, name = undefined) {
  fn consumeToken(token, name = 'token') -> Token {
    if token then expect(token, name)
    input.next()
  }

  fn consumeIdentifier() -> Identifier {
    expect(SyntaxKind.Identifier, 'identifier')
    input.next()
  }

  fn maybeConsumeToken(token, name = 'token') -> Option<Token> {
    if isToken(token)
      then Some(consumeToken(token, name))
      else None
  }

  fn skipKeyword(kw) -> Token { // kind: SyntaxKind
    expect(kw, 'keyword')
    input.next()
  }

  fn unexpected() {
    let token = input.peek()
    let name = tokenToText[token.kind]
    input.croak('Unexpected token: $name')
  }

  fn attributeNotSupported() {
    input.croak('Attributes are only supported on enum, trait and type declarations')
  }

  fn consumeSeparator(kind) -> () { // kind: SyntaxKind
    if not input.eof() {
      let mut token = input.peek(true)

      if token.kind == SyntaxKind.NewlineToken
      or token.kind == SyntaxKind.Comment
        then input.next(true)
        else consumeToken(kind)
    }
  }

  fn isAssignment(token: Token) -> Bool {
    if not token then return undefined

    token.kind == SyntaxKind.EqualsToken
      or token.kind == SyntaxKind.PlusEqualsToken
      or token.kind == SyntaxKind.MinusEqualsToken
      or token.kind == SyntaxKind.AsteriskEqualsToken
      or token.kind == SyntaxKind.AsteriskAsteriskEqualsToken
      or token.kind == SyntaxKind.SlashEqualsToken
      or token.kind == SyntaxKind.PercentEqualsToken
  }

  fn maybeParseOperator() -> Token {
    if isAssignment(input.peek())
      or isToken(SyntaxKind.EqualsEqualsToken)
      or isToken(SyntaxKind.ExclamationEqualsToken)
      or isToken(SyntaxKind.GreaterThanToken)
      or isToken(SyntaxKind.GreaterThanEqualsToken)
      or isToken(SyntaxKind.LessThanToken)
      or isToken(SyntaxKind.LessThanEqualsToken)
      or isToken(SyntaxKind.PlusToken)
      or isToken(SyntaxKind.MinusToken)
      or isToken(SyntaxKind.AsteriskToken)
      or isToken(SyntaxKind.AsteriskAsteriskToken)
      or isToken(SyntaxKind.SlashToken)
      or isToken(SyntaxKind.PercentToken)
      or isToken(SyntaxKind.AndKeyword)
      or isToken(SyntaxKind.OrKeyword)
      or isToken(SyntaxKind.NotKeyword)
    then input.peek()
    else null
  }

  fn isAssignable(expression: Expression) {
    match expression {
      Expression::Identifier(_) => true
      Expression::MemberAccess(_) => true
      Expression::IndexAccess(_) => true
      _ => false
    }
  }

  fn maybeBinary(left: Expression, myPrecedence) -> Expression {
    let mut operator = maybeParseOperator()
    if (operator) {
      let mut hisPrecedence = precedence[operator.kind]

      if hisPrecedence == undefined {
        let name = tokenToText[operator.kind]
        let json = global.JSON.stringify(operator)
        throw 'No precedence for $name: $json'
      }

      if (hisPrecedence > myPrecedence) {
        input.next()
        let mut e: Expression
        let mut innerExpression = maybeBinary(parseAtom(), hisPrecedence)
        if isAssignment(operator) {
          if isAssignable(left) {
            e = Expression::AssignmentExpression({
              lhs: left,
              token: operator,
              rhs: innerExpression,
            })
          }
          else {
            input.croak('Can only assign to an identifier')
          }
        }
        else {
          e = Expression::BinaryExpression({
            lhs: left
            operator
            rhs: innerExpression
          })
          ()
        }
        return maybeBinary(e, myPrecedence)
      }
    }
    left
  }

  fn maybeCall(expr: Expression) -> Expression {
    if isToken(SyntaxKind.OpenParenToken, true)
      then maybeCall(maybeMemberAccess(Expression::CallExpression({
        func: expr
        openParen: input.peek()
        argumentList: delimited('(', ')', ',', parseExpression, false)
        closeParen: consumeToken(SyntaxKind.CloseParenToken)
      })))
      else expr
  }

  fn maybeAccess(token: Expression) -> Expression {
    maybeIndexAccess(maybeMemberAccess(token))
  }

  fn maybeMemberAccess(token: Expression) -> Expression {
    if isToken(SyntaxKind.DotToken) {
      input.next()
      maybeAccess(Expression::MemberAccess({
        object: token
        member: consumeIdentifier()
      }))
    }
    else token
  }

  fn maybeIndexAccess(token: Expression) -> Expression {
    if isToken(SyntaxKind.OpenBracketToken, true) {
      let openBracket = input.next()
      let index = parseExpression()
      let closeBracket = consumeToken(SyntaxKind.CloseBracketToken)

      maybeAccess(Expression::IndexAccess({
        object: token
        openBracket
        index
        closeBracket
      }))
    }
    else token
  }

  // fn delimited<T>(start: SyntaxKind|string, stop: SyntaxKind|string, separator: SyntaxKind|string|(fn () then void), parser: fn () then T) -> Array<T> {
  fn delimited<T>(mut start, mut stop, mut separator, parser: () -> T, consumeStop) -> List<T> {
    if typeof(start) == 'string' then start = textToToken[start]
    if typeof(stop) == 'string' then stop = textToToken[stop]
    if typeof(separator) == 'string' then separator = textToToken[separator]

    let mut parts = []
    let mut first = true
    consumeToken(start)

    while not input.eof() {
      if isToken(stop) then break

      if first then first = false
      else if typeof(separator) == 'function' then separator()
      else consumeSeparator(separator)

      let mut part
      while not part {
        if isToken(stop) then break
        part = parser()
      }

      if part then parts.push(part)
    }

    if consumeStop then consumeToken(stop)
    parts
  }

  fn parseModule() -> Module {
    let mut exports = {}
    let mut statements = []
    while not input.eof() {
      let statement = parseTopLevelStatement()
      if statement {
        statements.add(statement)
        if let TopLevelStatement::ExportDirective(e) = statement
          then exports[e.identifier.name] = e
      }
      if not input.eof() then consumeSeparator(SyntaxKind.SemicolonToken)
    }
    {
      fileName: input.file.fileName
      path: input.file.absolutePath
      exports
      statements
      file: undefined
      scope: undefined
    }
  }

  fn parseTopLevelStatement() {
    if isToken(SyntaxKind.HashToken) then parseDeclarationWithAttribute()
    else if isToken(SyntaxKind.EnumKeyword) then TopLevelStatement::EnumDeclaration(parseEnumDeclaration())
    else if isToken(SyntaxKind.ExportKeyword) then TopLevelStatement::ExportDirective(parseExport())
    else if isToken(SyntaxKind.ImplKeyword) then parseImplDeclaration()
    else if isToken(SyntaxKind.ImportKeyword) then TopLevelStatement::ImportDirective(parseImport())
    else if isToken(SyntaxKind.TraitKeyword) then TopLevelStatement::TraitDeclaration(parseTraitDeclaration())
    else if isToken(SyntaxKind.TypeKeyword) then TopLevelStatement::TypeDeclaration(parseTypeDeclaration())
    else TopLevelStatement::BlockLevelStatement(parseBlockLevelStatement())
  }

  fn parseBlockLevelStatement() {
    if isToken(SyntaxKind.BreakKeyword) then BlockLevelStatement::BreakStatement({keyword: input.next()})
    else if isToken(SyntaxKind.ReturnKeyword) then BlockLevelStatement::ReturnStatement({
      keyword: input.next()
      expression: parseExpression()
    })
    else if isToken(SyntaxKind.WhileKeyword) then BlockLevelStatement::WhileLoop(parseWhile())
    else BlockLevelStatement::Expression(parseExpression())
  }

  fn parseExpression(precedence = 0, forceTuple = false) -> Expression {
    maybeCall(maybeAccess(maybeBinary(parseAtom(forceTuple), precedence)))
  }

  fn parseAtom(forceTuple = false) -> Expression {
    maybeCall(
      if isToken(SyntaxKind.OpenParenToken) then parseTupleOrExpression(forceTuple)
      else if isToken(SyntaxKind.OpenBracketToken) then Expression::ListLiteral(parseListLiteral())
      else if isToken(SyntaxKind.OpenBraceToken)
        then Expression::RecordLiteral(parseRecordLiteral())
      else if isToken(SyntaxKind.BarToken) then Expression::FunctionDeclaration(parseLambda())
      else if isToken(SyntaxKind.IfKeyword) then parseIf()
      else if isToken(SyntaxKind.MatchKeyword) then Expression::MatchExpression(parseMatch())
      else if isToken(SyntaxKind.FnKeyword)
        then Expression::FunctionDeclaration(parseFunctionDeclaration())
      else if isToken(SyntaxKind.LetKeyword) {
        input.next()
        Expression::VariableDeclaration(parseVariableDeclaration())
      }
      else if isToken(SyntaxKind.NotKeyword)
           or isToken(SyntaxKind.MinusToken)
           or isToken(SyntaxKind.PlusToken)
        then Expression::UnaryExpression(parseUnaryExpression())
      else if maybeConsumeToken(SyntaxKind.ThrowKeyword).isSome() then Expression::ThrowStatement({
        // kind: input.next().kind
        expression: parseExpression()
      })
      else if isToken(SyntaxKind.TrueKeyword)
           or isToken(SyntaxKind.FalseKeyword)
        then maybeAccess(Expression::BooleanLiteral({
          keyword: input.peek()
          value: input.next().kind == SyntaxKind.TrueKeyword
        }))
      else if isToken(SyntaxKind.NumberLiteral)
        then maybeAccess(Expression::NumberLiteral(input.next()))
      else if isToken(SyntaxKind.StringLiteral)
        then maybeAccess(Expression::StringLiteral(input.next()))
      else if isToken(SyntaxKind.Identifier)
        then parseIdentifierOrTypePath()
      else unexpected()
    )
  }

  fn parseSimpleLiteral() {
    if isToken(SyntaxKind.TrueKeyword)
    or isToken(SyntaxKind.FalseKeyword)
      then SimpleLiteral::BooleanLiteral({
        keyword: input.peek()
        value: input.next().kind == SyntaxKind.TrueKeyword
      })
    else if isToken(SyntaxKind.NumberLiteral)
      then SimpleLiteral::NumberLiteral(input.next())
    else if let Some(stringLiteral) = maybeConsumeToken(SyntaxKind.StringLiteral) {
      if stringLiteral.parts.length > 1 {
        input.croak('Attributes can only contain simple string literals. Interpolation is not supported.')
      }
      let part: StringLiteralPart = stringLiteral.parts[0]
      match part {
        StringLiteralPart::Literal(literal) => SimpleLiteral::StringLiteral(literal)
        _ => unexpected()
      }
    }
    else unexpected()
  }

  fn parseAttributeArgument() {
    let name = consumeIdentifier()
    let value = maybeConsumeToken(SyntaxKind.EqualsToken).map(|_| parseSimpleLiteral())

    {name, value}
  }

  fn parseAttribute() {
    let hashToken = consumeToken(SyntaxKind.HashToken)
    let openBracket = consumeToken(SyntaxKind.OpenBracketToken)
    let name = consumeIdentifier()
    let data =
      if maybeConsumeToken(SyntaxKind.EqualsToken).isSome()
        then AttributeData::Value(parseSimpleLiteral())
      else if isToken(SyntaxKind.OpenParenToken)
        then AttributeData::Arguments(delimited('(', ')', ',', parseAttributeArgument, true))
      else AttributeData::None
    let closeBracket = consumeToken(SyntaxKind.CloseBracketToken)

    {hashToken, openBracket, name, data, closeBracket}
  }

  fn parseDeclarationWithAttribute() {
    let mut attributes = []
    while isToken(SyntaxKind.HashToken) {
      attributes.add(parseAttribute())
    }

    if isToken(SyntaxKind.EnumKeyword) then TopLevelStatement::EnumDeclaration(parseEnumDeclaration(attributes))
    else if isToken(SyntaxKind.ExportKeyword) then TopLevelStatement::ExportDirective(parseExport(attributes))
    else if isToken(SyntaxKind.TraitKeyword) then TopLevelStatement::TraitDeclaration(parseTraitDeclaration(attributes))
    else if isToken(SyntaxKind.TypeKeyword) then TopLevelStatement::TypeDeclaration(parseTypeDeclaration(attributes))
    else attributeNotSupported()
  }

  fn parseEnumDeclaration(attributes: List<Attribute> = []) -> EnumDeclaration {
    let keyword = consumeToken(SyntaxKind.EnumKeyword)
    let name = consumeIdentifier()
    let typeParameters =
      if isToken(SyntaxKind.LessThanToken)
        then delimited('<', '>', ',', parseTypeParameter, true)
        else []

    let openBrace = input.peek()
    let members = delimited('{', '}', ',', parseEnumMember, false)
    let closeBrace = consumeToken(SyntaxKind.CloseBraceToken)

    {
      attributes
      keyword
      name
      typeParameters
      openBrace
      members
      closeBrace
    }
  }

  fn parseEnumMember() -> EnumMember {
    let name = consumeIdentifier()

    let bound =
      if isToken(SyntaxKind.OpenBraceToken)
        then Some(parseRecordTypeBound())
      else if isToken(SyntaxKind.OpenParenToken)
        then Some(parseTupleTypeBound())
      else None

    {
      name
      bound
    }
  }

  fn parseImplDeclaration() -> TopLevelStatement {
    let implKeyword = consumeToken(SyntaxKind.ImplKeyword)
    let typeParameters =
      if isToken(SyntaxKind.LessThanToken)
        then delimited('<', '>', ',', parseTypeParameter, true)
      else []

    let trait_ = parseTypeBound()
    let {forKeyword, type_}: {forKeyword: Option<Token>, type_: Option<TypeBound>} =
      if isToken(SyntaxKind.ForKeyword)
        then {
          forKeyword: Some(consumeToken(SyntaxKind.ForKeyword))
          type_: Some(parseTypeBound())
        }
        else {{
          forKeyword: None
          type_: None
        }}

    let openBrace = expect(SyntaxKind.OpenBraceToken)
    let members = delimited('{', '}', ';', parseFunctionDeclaration, false)
      .map(|f| {
        if f.name.isNone()
          then input.croak('Trait functions must have a name')
        if f.returnType.isNone()
          then input.croak('Trait functions must have a return type')

        f
      })
      .toList()
    let closeBrace = consumeToken(SyntaxKind.CloseBraceToken)

    if let Option::Some(type_) = type_
      then TopLevelStatement::ImplDeclaration({
        implKeyword
        typeParameters
        trait_
        forKeyword: forKeyword.unwrap()
        type_
        openBrace
        members
        closeBrace
      })
      else TopLevelStatement::ImplShorthandDeclaration({
        implKeyword
        typeParameters
        type_: trait_
        openBrace
        members
        closeBrace
      })
  }

  fn parseTraitDeclaration(attributes: List<Attribute> = []) -> TraitDeclaration {
    let keyword = consumeToken(SyntaxKind.TraitKeyword)
    let name = consumeIdentifier()
    let typeParameters =
      if isToken(SyntaxKind.LessThanToken)
        then delimited('<', '>', ',', parseTypeParameter, true)
      else []

    let openBrace = expect(SyntaxKind.OpenBraceToken)
    let members = delimited('{', '}', ';', || parseFunctionDeclaration(true), false)
      .map(|f| {
        if f.name.isNone()
          then input.croak('Trait functions must have a name')
        if f.returnType.isNone()
          then input.croak('Trait functions must have a return type')

        f
      })
      .toList()
    let closeBrace = consumeToken(SyntaxKind.CloseBraceToken)

    {
      attributes
      keyword
      name
      typeParameters
      openBrace
      members
      closeBrace
    }
  }

  fn parseTypeDeclaration(attributes: List<Attribute> = []) -> TypeDeclaration {
    let keyword = consumeToken(SyntaxKind.TypeKeyword)
    let name = consumeIdentifier()
    let typeParameters =
      if isToken(SyntaxKind.LessThanToken)
        then delimited('<', '>', ',', parseTypeParameter, true)
        else []

    let bound =
      if isToken(SyntaxKind.OpenBraceToken)
        then Some(parseRecordTypeBound())
      else if isToken(SyntaxKind.OpenParenToken)
        then Some(parseTupleTypeBound())
      else None

    {
      attributes
      keyword
      name
      typeParameters
      bound
      type_: undefined
    }
  }

  fn parseExport(attributes: List<Attribute> = []) -> ExportDirective {
    let keyword = consumeToken(SyntaxKind.ExportKeyword)
    let mut statement: ExportedStatement
    let mut identifier: Identifier

    if isToken(SyntaxKind.EnumKeyword) {
      let enumDeclaration = parseEnumDeclaration(attributes)
      statement = ExportedStatement::EnumDeclaration(enumDeclaration)
      identifier = enumDeclaration.name
    }
    else if isToken(SyntaxKind.TraitKeyword) {
      let traitDeclaration = parseTraitDeclaration(attributes)
      statement = ExportedStatement::TraitDeclaration(traitDeclaration)
      identifier = traitDeclaration.name
    }
    else if isToken(SyntaxKind.TypeKeyword) {
      let typeDeclaration = parseTypeDeclaration(attributes)
      statement = ExportedStatement::TypeDeclaration(typeDeclaration)
      identifier = typeDeclaration.name
    }
    else if attributes.isEmpty() {
      if isToken(SyntaxKind.FnKeyword) {
        let functionDeclaration = parseFunctionDeclaration()
        statement = ExportedStatement::FunctionDeclaration(functionDeclaration)
        if let Option::Some(name) = functionDeclaration.name {
          identifier = name
        }
        else input.croak('Can not export function without a name')
      }
      else if isToken(SyntaxKind.LetKeyword) {
        input.next()
        let variableDeclaration = parseVariableDeclaration()
        statement = ExportedStatement::VariableDeclaration(variableDeclaration)
        if let Pattern::Identifier(name) = variableDeclaration.pattern {
          identifier = name
        }
        else input.croak('Can not export a let declaration without a identifier pattern')
      }
      else input.croak('Expected trait, type, function or variable declaration after export')
    }
    else attributeNotSupported()

    {
      keyword
      identifier
      statement
    }
  }

  fn parseImport() -> ImportDirective {
    let importKeyword = consumeToken(SyntaxKind.ImportKeyword)

    let locator = consumeToken(SyntaxKind.StringLiteral)
    if locator.parts.length != 1 then throw Error('More than one part in import string')
    let parts = locator.parts[0].value[0].value.split(':')
    if parts > 2 then input.croak('Illegal token ":" used in import path')
    let domain = if parts.length == 2 then Some(parts[0]) else None
    let path = if parts.length == 2 then parts[1] else parts[0]

    let asKeyword = consumeToken(SyntaxKind.AsKeyword)
    let specifier =
      if isToken(SyntaxKind.OpenBraceToken)
        then ImportSpecifier::ObjectDestructure(parseObjectDestructure())
      else if isToken(SyntaxKind.AsteriskToken)
        then ImportSpecifier::Asterisk(consumeToken(false))
      else ImportSpecifier::Identifier(consumeIdentifier())

    {
      importKeyword
      domain
      path
      asKeyword
      specifier

      module: None
    }
  }

  fn parseObjectDestructure() -> ObjectDestructure {
    let openBrace = input.peek()
    let members = delimited('{', '}', ',', parseObjectDestructureMember, false)
    let closeBrace = consumeToken(SyntaxKind.CloseBraceToken)

    {
      openBrace
      members
      closeBrace
    }
  }

  fn parseObjectDestructureMember() -> ObjectDestructureMember {
    let property = consumeIdentifier()
    let local =
      if isToken(SyntaxKind.ColonToken) {
        input.next()
        consumeIdentifier()
      }
      else property

    {
      property
      local
    }
  }

  fn parseBlock() -> Block {
    let openBrace = Some(input.peek())
    let statements = delimited('{', '}', ';', parseBlockLevelStatement, false)
    let closeBrace = Some(consumeToken(SyntaxKind.CloseBraceToken))

    {
      openBrace
      statements
      closeBrace
      type_: undefined
    }
  }

  fn parseWhile() -> WhileLoop {
    skipKeyword(SyntaxKind.WhileKeyword)

    let condition = parseExpression()
    let body = parseBlock()

    {
      condition
      body
    }
  }

  fn parseIdentifierOrTypePath() -> Expression {
    let identifier = input.next()
    if isToken(SyntaxKind.ColonColonToken)
      then Expression::TypePathExpression({
        typePath: parseTypePath(Some(identifier))
      })
      else maybeAccess(Expression::Identifier(identifier))
  }

  fn parseFunctionDeclaration(optionalBody = false) -> FunctionDeclaration {
    consumeToken(SyntaxKind.FnKeyword)
    let name =
      if isToken(SyntaxKind.Identifier)
        then Some(consumeIdentifier())
        else None
    let typeParameters =
      if isToken(SyntaxKind.LessThanToken)
        then delimited('<', '>', ',', parseTypeParameter, true)
        else []
    let openParenOrBar = input.peek()
    let parameterList = delimited('(', ')', ',', parseVariableDeclaration, false)
    let closeParenOrBar = consumeToken(SyntaxKind.CloseParenToken)

    let returnType =
      if maybeConsumeToken(SyntaxKind.MinusGreaterThanToken).isSome()
        then Some(parseTypeBound())
        else None

    let body =
      if isToken(SyntaxKind.OpenBraceToken) or not optionalBody
        then Some(parseBlock())
        else None

    {
      name
      typeParameters
      openParenOrBar
      parameterList
      closeParenOrBar
      returnType
      body
      type_: undefined
    }
  }

  fn parseLambda() -> FunctionDeclaration {
    let openParenOrBar = input.peek()
    let parameterList = delimited('|', '|', ',', parseVariableDeclaration, false)
    let closeParenOrBar = consumeToken(SyntaxKind.BarToken)

    let body =
      if isToken(SyntaxKind.OpenBraceToken)
        then Some(parseBlock())
        else Some({
          openBrace: None
          statements: [parseBlockLevelStatement()]
          closeBrace: None
          type_: undefined
        })

    {
      name: None
      typeParameters: []
      openParenOrBar
      parameterList
      closeParenOrBar
      returnType: None
      body
      type_: undefined
    }
  }

  fn parseVariableDeclaration() -> VariableDeclaration {
    let mutable = maybeConsumeToken(SyntaxKind.MutKeyword).isSome()
    let pattern = parsePattern()

    {
      pattern
      mutable
      typeBound: maybeConsumeToken(SyntaxKind.ColonToken).map(|_| parseTypeBound())
      initializer: maybeConsumeToken(SyntaxKind.EqualsToken).map(|_| parseExpression())
    }
  }

  fn parseIf() -> Expression {
    let ifKeyword = skipKeyword(SyntaxKind.IfKeyword)

    if isToken(SyntaxKind.LetKeyword)
      then Expression::IfLetExpression(parseIfLetExpression(ifKeyword))
      else Expression::IfExpression(parseIfExpression(ifKeyword))
  }

  fn parseIfExpression(ifKeyword: Token) -> IfExpression {
    let condition = parseExpression()

    let then_: Block =
      if isToken(SyntaxKind.OpenBraceToken)
        then parseBlock()
        else {
          skipKeyword(SyntaxKind.ThenKeyword)
          {
            openBrace: None
            statements: [parseBlockLevelStatement()]
            closeBrace: None
            type_: undefined
          }
        }

    {
      ifKeyword
      condition
      then_
      else_:
        if isToken(SyntaxKind.ElseKeyword) {
          input.next()
          Some(
            if isToken(SyntaxKind.OpenBraceToken)
              then parseBlock()
              else ({
                openBrace: None
                statements: [parseBlockLevelStatement()]
                closeBrace: None
                type_: undefined
              })
          )
        }
        else None
    }
  }

  fn parseIfLetExpression(ifKeyword: Token) -> IfLetExpression {
    let letKeyword = skipKeyword(SyntaxKind.LetKeyword)
    let pattern = parsePattern()
    let equalsToken = consumeToken(SyntaxKind.EqualsToken)
    let expression = parseExpression()

    let then_: Block =
      if isToken(SyntaxKind.OpenBraceToken)
        then parseBlock()
        else {
          skipKeyword(SyntaxKind.ThenKeyword)
          {
            openBrace: None
            statements: [parseBlockLevelStatement()]
            closeBrace: None
            type_: undefined
          }
        }

    {
      ifKeyword
      letKeyword
      pattern
      expression
      then_
      else_:
        if isToken(SyntaxKind.ElseKeyword) {
          input.next()
          Some(
            if isToken(SyntaxKind.OpenBraceToken)
              then parseBlock()
              else ({
                openBrace: None
                statements: [parseBlockLevelStatement()]
                closeBrace: None
                type_: undefined
              })
          )
        }
        else None
    }
  }

  fn parseMatch() -> MatchExpression {
    {
      matchKeyword: skipKeyword(SyntaxKind.MatchKeyword)
      expression: parseExpression()
      openBrace: input.peek()
      patterns: delimited('{', '}', ',', parseMatchArm, false)
      closeBrace: consumeToken(SyntaxKind.CloseBraceToken)
    }
  }

  fn parseMatchArm() -> MatchArm {
    let pattern = parsePattern()
    let arrow = consumeToken(SyntaxKind.EqualsGreaterThanToken)
    let block =
      if isToken(SyntaxKind.OpenBraceToken)
        then parseBlock()
        else {{
          openBrace: None
          statements: [parseBlockLevelStatement()]
          closeBrace: None
          type_: undefined
        }}
    {
      pattern
      arrow
      block
    }
  }

  fn parseUnaryExpression() -> UnaryExpression {
    let operator = input.next()

    {
      operator
      rhs: parseExpression(precedence[operator.kind])
    }
  }

  fn parseListLiteral() -> ListLiteral {
    let openBracket = input.peek()
    let members = delimited('[', ']', ',', parseExpression, false)
    let closeBracket = consumeToken(SyntaxKind.CloseBracketToken)

    {
      openBracket
      members
      closeBracket
    }
  }

  fn parseRecordLiteral() -> RecordLiteral {
    let openBrace = input.peek()
    let members = delimited('{', '}', ',', parseRecordLiteralMember, false)
    let closeBrace = consumeToken(SyntaxKind.CloseBraceToken)
    {
      openBrace
      members
      closeBrace
    }
  }

  fn parseRecordLiteralMember() -> RecordLiteralMember {
    let name = consumeIdentifier()
    let value =
      if isToken(SyntaxKind.ColonToken) {
        input.next()
        parseExpression()
      }
      else Expression::Identifier(name)

    {
      name
      value
    }
  }

  fn parseTupleOrExpression(forceTuple) {
    let openParen = input.peek()
    let expressions = delimited('(', ')', ',', || parseExpression(0, true), false)
    let closeParen = consumeToken(SyntaxKind.CloseParenToken)

    if not forceTuple and expressions.length == 1
      then expressions[0]
      else Expression::TupleLiteral({
        openParen
        expressions
        closeParen
      })
  }

  fn parsePattern() -> Pattern {
    if let Option::Some(token) = maybeConsumeToken(SyntaxKind.UnderscoreToken)
      then Pattern::CatchAll(token)
    else if isToken(SyntaxKind.OpenParenToken)
      then Pattern::Tuple(parseTuplePattern())
    else if isToken(SyntaxKind.OpenBraceToken)
      then Pattern::Record(parseRecordPattern())
    else {
      let identifier = consumeIdentifier()

      if isToken(SyntaxKind.ColonColonToken)
      or isToken(SyntaxKind.OpenParenToken)
      or isToken(SyntaxKind.OpenBraceToken) {
        let typePath = parseTypePath(Some(identifier))

        if isToken(SyntaxKind.OpenParenToken)
          then Pattern::TupleType(typePath, parseTuplePattern())
        else if isToken(SyntaxKind.OpenBraceToken)
          then Pattern::RecordType(typePath, parseRecordPattern())
        else Pattern::UnitType(typePath)
      }
      else Pattern::Identifier(identifier)
    }
  }

  fn parseRecordPattern() -> RecordPattern {
    let openBrace = expect(SyntaxKind.OpenBraceToken)
    let properties = delimited('{', '}', ',', parseRecordPatternMember, false)
    let closeBrace = consumeToken(SyntaxKind.CloseBraceToken)

    {openBrace, properties, closeBrace}
  }

  fn parseRecordPatternMember() -> RecordPatternMember {
    let property = consumeIdentifier()
    let pattern =
      if maybeConsumeToken(SyntaxKind.ColonToken).isSome()
        then parsePattern()
        else Pattern::Identifier(property)

    {property, pattern}
  }

  fn parseTuplePattern() -> TuplePattern {
    let openParen = expect(SyntaxKind.OpenParenToken)
    let properties = delimited('(', ')', ',', parsePattern, false)
    let closeParen = consumeToken(SyntaxKind.CloseParenToken)

    {openParen, properties, closeParen}
  }

  fn parseTypeBound() -> TypeBound {
    if isToken(SyntaxKind.LessThanToken)
      then parseFunctionTypeBound(None)
    else if isToken(SyntaxKind.OpenParenToken) {
      let tuple = parseTupleTypeBound()
      if isToken(SyntaxKind.MinusGreaterThanToken)
        then parseFunctionTypeBound(Some(tuple))
        else tuple
    }
    else if isToken(SyntaxKind.OpenBraceToken)
      then parseRecordTypeBound()
    else parseNamedTypeBound()
  }

  fn parseFunctionTypeBound(tuple: Option<TypeBound>) -> TypeBound {
    let typeParameters =
      if tuple.isNone() and isToken(SyntaxKind.LessThanToken)
        then delimited('<', '>', ',', parseTypeParameter, true)
        else []

    let parameters = tuple.unwrapOrElse(parseTupleTypeBound).getTupleTypeBound()
    consumeToken(SyntaxKind.MinusGreaterThanToken)
    let returnType = parseTypeBound()

    TypeBound::FunctionTypeBound({
      typeParameters
      parameters
      returnType
    })
  }

  fn parseNamedTypeBound() -> TypeBound {
    let path = parseTypePath(None)
    let typeParameters =
      if isToken(SyntaxKind.LessThanToken)
        then delimited('<', '>', ',', parseTypeBound, true)
        else []

    TypeBound::NamedTypeBound({
      path
      typeParameters
    })
  }

  fn parseRecordTypeBound() -> TypeBound {
    expect(SyntaxKind.OpenBraceToken)
    let openBrace = input.peek()
    let properties = delimited('{', '}', ',', parseRecordTypeBoundMember, false)
    let closeBrace = consumeToken(SyntaxKind.CloseBraceToken)

    TypeBound::RecordTypeBound({
      openBrace
      properties
      closeBrace
    })
  }

  fn parseRecordTypeBoundMember() -> RecordTypeBoundMember {
    let name = consumeIdentifier()
    consumeToken(SyntaxKind.ColonToken)
    let typeBound = parseTypeBound()
    {
      name
      typeBound
    }
  }

  fn parseTupleTypeBound() -> TypeBound {
    expect(SyntaxKind.OpenParenToken)
    let openParen = input.peek()
    let properties = delimited('(', ')', ',', parseTypeBound, false)
    let closeParen = consumeToken(SyntaxKind.CloseParenToken)

    TypeBound::TupleTypeBound({
      openParen
      properties
      closeParen
    })
  }

  fn parseTypeParameter() -> TypeParameter {
    let name = consumeIdentifier()
    let defaultValue =
      if isToken(SyntaxKind.EqualsToken) {
        input.next()
        Some(parseTypeBound())
      }
      else None
    {
      kind: SyntaxKind.TypeParameter
      name
      defaultValue
    }
  }

  fn parseTypePath(identifier: Option<Identifier>) -> TypePath {
    let i = identifier.unwrapOrElse(consumeIdentifier)

    if maybeConsumeToken(SyntaxKind.ColonColonToken).isSome()
      then TypePath::Object(i, parseTypePath(None))
      else TypePath::Member(i)
  }

  parseModule()
}
