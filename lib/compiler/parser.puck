import 'ast.ts' as {
  SyntaxKind
  isIdentifier
  isIndex
  isMember
  precedence
  textToToken
  tokenToText
}
import '../stdlib/js.puck' as {console, global, null, typeof, undefined}

export fn parse(input: TokenStream) {

  fn isToken(kind: SyntaxKind, peekDistance) {
    let token = input.peek(false, peekDistance)
    token and token.kind == kind
  }

  fn tokenName(token: Token) {
    if typeof(tokenToText[token.kind]) == 'function' then tokenToText[token.kind](token)
    else if tokenToText[token.kind] then tokenToText[token.kind]
    else SyntaxKind[token.kind]
  }

  fn expect(expect: SyntaxKind, name = 'token') {
    if not isToken(expect) {
      let token = input.peek()
      let expectedText = ': "' + tokenName({kind: expect}) + '"'

      let but =
        if token {
          let got = tokenName(token)
          'got "$got"'
        }
        else 'reached end of file'

      console.error(token)
      input.croak('Expected $name$expectedText, but $but')
    }
  }

  fn consumeToken(token: SyntaxKind, name) {
    expect(token, name)
    return input.next()
  }

  fn skipKeyword(kw: SyntaxKind) {
    expect(kw, 'keyword')
    input.next()
  }

  fn unexpected() {
    let token = input.peek()
    console.error('token', token, typeof(token))
    let name = tokenToText[token.kind]
    input.croak('Unexpected token: $name')
  }

  fn consumeSeparator(kind: SyntaxKind) {
    if not input.eof() {
      let mut token = input.peek(true)

      if token.kind == SyntaxKind.NewlineToken
        or token.kind == SyntaxKind.Comment
        then input.next(true)
      else consumeToken(kind)
    }
  }

  fn isAssignment(token: Token) {
    if not token then return undefined

    token.kind == SyntaxKind.EqualsToken
      or token.kind == SyntaxKind.PlusEqualsToken
      or token.kind == SyntaxKind.MinusEqualsToken
      or token.kind == SyntaxKind.AsteriskEqualsToken
      or token.kind == SyntaxKind.AsteriskAsteriskEqualsToken
      or token.kind == SyntaxKind.SlashEqualsToken
      or token.kind == SyntaxKind.PercentEqualsToken
  }

  fn maybeParseOperator(): Token {
    if isAssignment(input.peek())
      or isToken(SyntaxKind.EqualsEqualsToken)
      or isToken(SyntaxKind.ExclamationEqualsToken)
      or isToken(SyntaxKind.GreaterThanToken)
      or isToken(SyntaxKind.GreaterThanEqualsToken)
      or isToken(SyntaxKind.LessThanToken)
      or isToken(SyntaxKind.LessThanEqualsToken)
      or isToken(SyntaxKind.PlusToken)
      or isToken(SyntaxKind.MinusToken)
      or isToken(SyntaxKind.AsteriskToken)
      or isToken(SyntaxKind.AsteriskAsteriskToken)
      or isToken(SyntaxKind.SlashToken)
      or isToken(SyntaxKind.PercentToken)
      or isToken(SyntaxKind.AndKeyword)
      or isToken(SyntaxKind.OrKeyword)
      or isToken(SyntaxKind.NotKeyword)
    then input.peek()
    else null
  }

  fn maybeBinary(left: Expression, myprecedence): Expression {
    let mut operator = maybeParseOperator()
    if (operator) {
      let mut hisprecedence = precedence[operator.kind]

      if hisprecedence == undefined {
        let name = tokenToText[operator.kind]
        let json = global.JSON.stringify(operator)
        throw 'No precedence for $name: $json'
      }

      if (hisprecedence > myprecedence) {
        input.next()
        let mut e
        let mut innerExpression = maybeBinary(parseAtom(), hisprecedence)
        if isAssignment(operator) {
          if isIdentifier(left) or isMember(left) or isIndex(left) {
            let a: AssignmentExpression = {
              kind: SyntaxKind.AssignmentExpression,
              lhs: left,
              token: operator,
              rhs: innerExpression,
            }
            e = a
          }
          else {
            input.croak('Can only assign to an identifier')
          }
        }
        else {
          let b: BinaryExpression = {
            kind: SyntaxKind.BinaryExpression,
            lhs: left,
            operator,
            rhs: innerExpression,
          }
          e = b
        }
        return maybeBinary(e, myprecedence)
      }
    }
    left
  }

  fn maybeCall(expr: Expression) {
    if isToken(SyntaxKind.OpenParenToken)
      then maybeCall(maybeMemberAccess({
        kind: SyntaxKind.CallExpression,
        func: expr,
        openParen: input.peek(),
        argumentList: delimited('(', ')', ',', parseExpression, false),
        closeParen: consumeToken(SyntaxKind.CloseParenToken),
      }))
      else expr
  }

  fn maybeMemberAccess(token: Expression): Expression {
    if isToken(SyntaxKind.DotToken) {
      input.next()
      expect(SyntaxKind.Identifier, 'identifier')
      return {
        kind: SyntaxKind.MemberAccess,
        object: token,
        member: maybeMemberAccess(input.next())
      }
    }
    if isToken(SyntaxKind.OpenBracketToken) {
      input.next()
      let mut index = parseExpression()
      consumeToken(SyntaxKind.CloseBracketToken)

      return maybeMemberAccess({
        kind: SyntaxKind.IndexAccess,
        object: token,
        index,
      })
    }
    token
  }

  // fn delimited<T>(start: SyntaxKind|string, stop: SyntaxKind|string, separator: SyntaxKind|string|(fn () then void), parser: fn () then T): Array<T> {
  fn delimited(mut start, mut stop, mut separator, parser, consumeStop = true): Array {
    if typeof(start) == 'string' then start = textToToken[start]
    if typeof(stop) == 'string' then stop = textToToken[stop]
    if typeof(separator) == 'string' then separator = textToToken[separator]

    let mut parts = []
    let mut first = true
    consumeToken(start)

    while not input.eof() {
      if isToken(stop) then break

      if first then first = false
      else if typeof(separator) == 'function' then separator()
      else consumeSeparator(separator)

      let mut part
      while not part {
        if isToken(stop) then break
        part = parser()
      }

      if part then parts.push(part)
    }

    if consumeStop then consumeToken(stop)
    parts
  }

  fn parseTypeBound(): TypeBound {
    let name = consumeToken(SyntaxKind.Identifier, 'identifier')
    let parameters =
      if isToken(SyntaxKind.LessThanToken)
        then delimited('<', '>', ',', parseTypeBound)

    {
      kind: SyntaxKind.TypeBound,
      name,
      parameters,
    }
  }

  fn parseObjectDestructureMember(): ObjectDestructureMember {
    let property = consumeToken(SyntaxKind.Identifier, 'identifier')
    let local =
      if isToken(SyntaxKind.ColonToken) {
        input.next()
        consumeToken(SyntaxKind.Identifier, 'identifier')
      }
      else property

    {
      kind: SyntaxKind.ObjectDestructureMember,
      property,
      local,
    }
  }

  fn parseObjectDestructure(): ObjectDestructure {
    let openBrace = input.peek()
    let members = delimited('{', '}', ',', parseObjectDestructureMember, false)
    let closeBrace = consumeToken(SyntaxKind.CloseBraceToken)

    {
      kind: SyntaxKind.ObjectDestructure
      openBrace
      members
      closeBrace
    }
  }

  fn parseTypeParameter(): TypeParameter {
    let name = consumeToken(SyntaxKind.Identifier, 'identifier')
    let defaultValue = if isToken(SyntaxKind.EqualsToken) {
      input.next()
      parseTypeBound()
    }
    {
      kind: SyntaxKind.TypeParameter
      name
      defaultValue
    }
  }

  fn parseTypeProperty(): TypeProperty {
    let name = consumeToken(SyntaxKind.Identifier, 'identifier')
    consumeToken(SyntaxKind.ColonToken)
    let typeBound = parseTypeBound()
    {
      kind: SyntaxKind.TypeProperty
      name
      typeBound
    }
  }

  fn parseTypeDeclaration(): TypeDeclaration {
    let keyword = consumeToken(SyntaxKind.TypeKeyword)
    let name = consumeToken(SyntaxKind.Identifier, 'identifier')
    let parameters =
      if isToken(SyntaxKind.LessThanToken)
        then delimited('<', '>', ',', parseTypeParameter)
      else []
    consumeToken(SyntaxKind.EqualsToken)
    expect(SyntaxKind.OpenBraceToken)
    let openBrace = input.peek()
    let properties = delimited('{', '}', ',', parseTypeProperty, false)
    let closeBrace = consumeToken(SyntaxKind.CloseBraceToken)

    {
      kind: SyntaxKind.TypeDeclaration
      name
      parameters
      openBrace
      properties
      closeBrace
    }
  }

  fn parseVariableDeclaration(): VariableDeclaration {
    let mut mutable = false
    if isToken(SyntaxKind.MutKeyword) {
      input.next()
      mutable = true
    }
    expect(SyntaxKind.Identifier, 'identifier')

    let mut declaration: VariableDeclaration = {
      kind: SyntaxKind.VariableDeclaration,
      identifier: input.next(),
      mutable,
    }

    if isToken(SyntaxKind.ColonToken) {
      input.next()
      declaration.typeBound = parseTypeBound()
    }

    if isToken(SyntaxKind.EqualsToken) {
      input.next()
      declaration.initializer = parseExpression()
    }

    declaration
  }

  fn parseFunction(): FunctionNode {
    let mut name = if isToken(SyntaxKind.Identifier) then input.next()
    let mut parameterList = delimited('(', ')', ',', parseVariableDeclaration)

    let returnType =
      if isToken(SyntaxKind.ColonToken) {
        input.next()
        parseTypeBound()
      }

    let mut body: BlockNode =
      if isToken(SyntaxKind.OpenBraceToken)
        then parseBlock()
        else {
          skipKeyword(SyntaxKind.ThenKeyword)
          {
            kind: SyntaxKind.Block,
            block: [parseExpression()],
          }
        }

    {
      kind: SyntaxKind.Function,
      name,
      parameterList,
      returnType,
      body,
    }
  }

  fn parseLambda(): FunctionNode {
    let mut parameterList = delimited('|', '|', ',', parseVariableDeclaration)

    let mut body: BlockNode =
      if isToken(SyntaxKind.OpenBraceToken)
        then parseBlock()
        else {{
          kind: SyntaxKind.Block,
          block: [parseExpression()],
        }}

    {
      kind: SyntaxKind.Function,
      parameterList,
      body,
    }
  }

  fn parseIf(): IfExpression {
    skipKeyword(SyntaxKind.IfKeyword)

    let condition = parseExpression()

    let mut _then: BlockNode =
      if isToken(SyntaxKind.OpenBraceToken)
        then parseBlock()
        else {
          skipKeyword(SyntaxKind.ThenKeyword)
          {
            kind: SyntaxKind.Block,
            block: [parseExpression()],
          }
        }

    let mut ret: IfExpression = {
      kind: SyntaxKind.IfExpression,
      condition,
      _then,
    }

    if isToken(SyntaxKind.ElseKeyword) {
      input.next()
      ret._else =
        if isToken(SyntaxKind.OpenBraceToken)
          then parseBlock()
          else ({
            kind: SyntaxKind.Block,
            block: [parseExpression()],
          })
    }

    ret
  }

  fn parseWhile(): WhileExpression {
    skipKeyword(SyntaxKind.WhileKeyword)

    let condition = parseExpression()
    let mut body: BlockNode =
      if isToken(SyntaxKind.OpenBraceToken)
        then parseBlock()
        else {
          skipKeyword(SyntaxKind.ThenKeyword)
          {
            kind: SyntaxKind.Block,
            block: [parseExpression()],
          }
        }

    return {
      kind: SyntaxKind.WhileExpression,
      condition,
      body,
    }
  }

  fn parseArrayLiteral(): ArrayLiteral {
    let members = delimited('[', ']', ',', parseExpression)
    { kind: SyntaxKind.ArrayLiteral, members }
  }

  fn parseObjectLiteralMember(): ObjectLiteralMember {
    let name = consumeToken(SyntaxKind.Identifier, 'identifier')
    let value =
      if isToken(SyntaxKind.ColonToken) {
        input.next()
        parseExpression()
      }
      else name

    {
      kind: SyntaxKind.ObjectLiteralMember,
      name,
      value,
    }
  }

  fn parseObjectLiteral(): ObjectLiteral {
    let members = delimited('{', '}', ',', parseObjectLiteralMember)
    { kind: SyntaxKind.ObjectLiteral, members }
  }

  fn parseAtom() {
    maybeCall((fn innerParseAtom() {
      if isToken(SyntaxKind.OpenParenToken) {
        input.next()
        let exp = parseExpression()
        consumeToken(SyntaxKind.CloseParenToken)
        exp
      }
      else if isToken(SyntaxKind.OpenBracketToken) then parseArrayLiteral()
      else if isToken(SyntaxKind.OpenBraceToken) then parseObjectLiteral()
      else if isToken(SyntaxKind.BarToken) then parseLambda()
      else if isToken(SyntaxKind.IfKeyword) then parseIf()
      else if isToken(SyntaxKind.WhileKeyword) then parseWhile()
      else if isToken(SyntaxKind.FnKeyword) {
        input.next()
        parseFunction()
      }
      else if isToken(SyntaxKind.LetKeyword) {
        input.next()
        parseVariableDeclaration()
      }
      else if isToken(SyntaxKind.NotKeyword)
           or isToken(SyntaxKind.MinusToken)
           or isToken(SyntaxKind.PlusToken)
        then {
          kind: SyntaxKind.UnaryExpression,
          operator: input.next(),
          rhs: parseExpression(),
        }
      else if isToken(SyntaxKind.BreakKeyword) then input.next()
      else if isToken(SyntaxKind.ReturnKeyword) then {
        kind: SyntaxKind.ReturnStatement,
        keyword: input.next(),
        expression: parseExpression(),
      }
      else if isToken(SyntaxKind.ThrowKeyword) then {
        kind: input.next().kind,
        expression: parseExpression(),
      }
      else if isToken(SyntaxKind.TrueKeyword)
           or isToken(SyntaxKind.FalseKeyword)
        then
          maybeMemberAccess({
            kind: SyntaxKind.BooleanLiteral,
            value: input.next().kind == SyntaxKind.TrueKeyword,
          })
      else if isToken(SyntaxKind.NumberLiteral)
           or isToken(SyntaxKind.StringLiteral)
           or isToken(SyntaxKind.Identifier)
        then maybeMemberAccess(input.next())
      else unexpected()
    })())
  }

  fn parseExport() {
    let keyword = consumeToken(SyntaxKind.ExportKeyword)
    let mut expression
    let mut identifier
    if isToken(SyntaxKind.TypeKeyword) {
      expression = parseTypeDeclaration()
      identifier = expression.name
    }
    else if isToken(SyntaxKind.FnKeyword) {
      input.next()
      expression = parseFunction()
      identifier = expression.name
    }
    else if isToken(SyntaxKind.LetKeyword) {
      input.next()
      expression = parseVariableDeclaration()
      identifier = expression.identifier
    }
    else input.croak('Expected type, function or variable declaration after export')
    {
      kind: SyntaxKind.ExportDirective
      keyword
      identifier
      expression
    }
  }

  fn parseImport() {
    let importKeyword = consumeToken(SyntaxKind.ImportKeyword)

    let locator = consumeToken(SyntaxKind.StringLiteral)
    if locator.parts.length != 1 then throw Error('More than one part in import string')
    let parts = locator.parts[0].value.split(':')
    if parts > 2 then input.croak('Illegal token ":" used in import path')
    let domain = if parts.length == 2 then parts[0]
    let path = if parts.length == 2 then parts[1] else parts[0]

    let asKeyword = consumeToken(SyntaxKind.AsKeyword)
    let specifier = if isToken(SyntaxKind.OpenBraceToken)
      then parseObjectDestructure()
      else consumeToken(SyntaxKind.Identifier, 'identifier')

    {
      kind: SyntaxKind.ImportDirective
      importKeyword
      domain
      path
      asKeyword
      specifier
    }
  }

  fn parseTopLevelExpression() {
    if isToken(SyntaxKind.ExportKeyword) then parseExport()
    else if isToken(SyntaxKind.ImportKeyword) then parseImport()
    else if isToken(SyntaxKind.TypeKeyword) then parseTypeDeclaration()
    else parseExpression()
  }

  fn parseModule() {
    let mut exports = {}
    let mut lines = []
    while not input.eof() {
      let expression = parseTopLevelExpression()
      if expression {
        lines.push(expression)
        if expression.kind == SyntaxKind.ExportDirective
          then exports[expression.identifier.name] = expression
      }
      if not input.eof() then consumeSeparator(SyntaxKind.SemicolonToken)
    }
    {
      kind: SyntaxKind.Module
      fileName: input.file.fileName
      path: input.file.absolutePath
      exports
      lines
    }
  }

  fn parseBlock(): BlockNode {
    let block = delimited('{', '}', ';', parseExpression)
    { kind: SyntaxKind.Block, block }
  }

  fn parseExpression(): Expression {
    maybeCall(maybeMemberAccess(maybeBinary(parseAtom(), 0)))
  }

  parseModule()
}
