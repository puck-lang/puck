import 'puck:js' as {Object, asResult, require, undefined}
import 'node:fs' as {statSync}
import 'node:path' as path
import '../ast/ast.puck' as {
  Module
  TopLevelStatement
  ImportDirective
  ImportSpecifier
}
import '../ast/span.puck' as {ToSpan}
import '../ast/visit.puck' as visit
import '../entities.puck' as {File, UnparsedFile}
import '../compiler/ast.ts' as {SyntaxKind}

let domains = ['node', 'puck']
export let puckFile = RegExp.new('\\.puck$', 'i')
export let puckModules = ['core', 'js', 'test']

export fn ImportVisitor(context, file: UnparsedFile) {
  let reportError: (ToSpan, String) -> () = context.reportError.bind(context, file)
  let mut declarations: ObjectMap<ToSpan>

  fn importModule(mut i: ImportDirective, importedFile: UnparsedFile) -> () {
    let result: Result<File, ()> = asResult(|| context.importFile(importedFile))
    match result {
      Ok(contextFile) => {
        let module: Module = contextFile->ast.transmute()
        if not module then return context.defer(importedFile, || importModule(i, importedFile))

        match i.specifier {
          ImportSpecifier::ObjectDestructure(o) => {
            o.members.forEach(|m| {
              if not module.exports.has(m.property.name)
                then reportError(m, importedFile.fileName + ' has no export named ' + m.property.name)
            })
          }
          ImportSpecifier::Asterisk(token) => {
            i.specifier = ImportSpecifier::ObjectDestructure({
              openBrace: token
              closeBrace: token
              members: module.exports.keys()
                .filter(|e| not declarations.has(e))
                .map(|e| {
                  let property = module.exports[e].identifier
                  {
                    property
                    local: property
                    file: Some(module.file)
                  }
                })
                .toList()
            })
          }
          ImportSpecifier::Identifier(_) => {}
        }
        i->file = contextFile
        i.module = Some(module)
      }
      Err => {}
    }
  }

  Object->assign({}, visit.emptyVisitor, {

    visitModule: |self, mut m: Module| {
      declarations = m->declarations.transmute()
      m.statements.forEach(|s| {
        if let TopLevelStatement::ImportDirective(e) = s {
          self.visitImportDirective(e)
        }
      })
      // No need to keep this around after this step
      m->declarations = undefined
    }

    visitImportDirective: |self, mut i: ImportDirective| {
      match i.domain {
        Some(domain) => {
          if domain == 'puck' {
            if not puckModules.contains(i.path)
              then return reportError(i, 'Invalid puck module ' + i.path)
            let importedFile = context.resolvePath(
              path->join(
                path->dirname(require->resolve('puck-lang/dist/bin/puck'))
                '../../lib/stdlib/' + i.path + '.puck'
              )
              file
            )
            importModule(i, importedFile)
          }
          else if not domains.contains(domain) {
            reportError(i, 'Invalid import domain $domain')
          }
        }
        None => {
          let result: Result<UnparsedFile, {}> = asResult(|| context.resolvePath(i.path, file))
          match result {
            Result::Ok(importedFile) => {
            if puckFile.test(importedFile.absolutePath)
              then importModule(i, importedFile)
            }
            Result::Err(error) => return reportError(i, 'Imported file ' + i.path + ' not found')
          }
        }
      }
      ()
    }
  })
}
