import 'puck:js' as {Object}
import '../ast/ast.puck' as {
  Expression

  Block
  EnumDeclaration
  FunctionDeclaration
  Identifier
  Module
  ObjectDestructure
  TypeBound
  TraitDeclaration
  TypeDeclaration
  VariableDeclaration

  ExportDirective
  ImportDirective

  AssignmentExpression
  BinaryExpression
  CallExpression
  ForExpression
  IfExpression
  UnaryExpression
  WhileLoop

  IndexAccess
  MemberAccess

  Token
  ReturnStatement

  ListLiteral
  BooleanLiteral
  NumberLiteral
  ObjectLiteral
  StringLiteral
}
import '../ast/visit.puck' as visit
import '../compiler/ast.ts' as {SyntaxKind}
import '../entities.puck' as {StructKind, TypeClass, TypeKind}
import 'src/scope.puck' as {createScope}

/// Visits and declares top level bindings
///
/// The result is used by the import visitor for import and exports but is then
/// throwed away becouse too little information is known about the imported bindings
export fn TopLevelVisitor(context, file) {
  let mut scope = createScope(context, file)
  let mut variableDeclaration: Option<VariableDeclaration> = None
  let reportError = context.reportError.bind(context, file)

  Object.assign({}, visit.emptyVisitor, {

    visitBlock: |self, b: Block| {}
    visitEnumDeclaration: |self, t: EnumDeclaration| {
      scope.defineType({
        displayName: None
        name: Some(t.name.name)
        kind: TypeKind::Enum({
          implementations: []
          members: ObjectMap.new()
        })
        class: TypeClass.fromAstNode(t, reportError)
        instance: None
      }, t)
    }
    visitFunctionDeclaration: |self, mut f: FunctionDeclaration| {
      if let Option::Some(name) = f.name then
        scope.define({
          name: name.name
          token: f
          mutable: false
        })
    }
    visitModule: |self, mut m: Module| {
      m.scope = scope
      visit.walkModule(self, m)
    }
    visitObjectDestructure: |self, i: ObjectDestructure| {
      // Allow redeclaration in this pass as we don't yet know if the type or variable scope
      // should be used for the imported identifiers.
      i.members.forEach(|m| scope.define({name: m.local.name, mutable: false, token: m}, true))
    }
    visitTraitDeclaration: |self, t: TraitDeclaration| {
      scope.defineType({
        displayName: None
        name: Some(t.name.name)
        kind: TypeKind::Trait({
          isShorthand: false
          functions: ObjectMap.new()
        })
        class: TypeClass.fromAstNode(t, reportError)
        instance: None
      }, t)
    }
    visitTypeDeclaration: |self, t: TypeDeclaration| {
      let structKind =
        if let Option::Some(typeBound) = t.bound {
          if typeBound.kind == SyntaxKind.ObjectTypeBound
            then StructKind::Record({properties: ObjectMap.new()})
          else if typeBound.kind == SyntaxKind.TupleTypeBound
            then StructKind::Tuple({properties: []})
        }
        else StructKind::Unit

      scope.defineType({
        displayName: None
        name: Some(t.name.name)
        kind: TypeKind::Struct({
          implementations: []
          kind: structKind
        })
        class: TypeClass.fromAstNode(t, reportError)
        instance: None
      }, t)
    }
    visitVariableDeclaration: |self, d: VariableDeclaration| {
      variableDeclaration = Some(d)
      visit.walkVariableDeclaration(self, d)
      variableDeclaration = None
    }

    visitExportDirective: |self, e: ExportDirective| {
      visit.walkExportDirective(self, e)
    }
    visitImportDirective: |self, i: ImportDirective| {
      if i.specifier.kind == SyntaxKind.Identifier
        then scope.define({name: i.specifier.name, mutable: false, token: i})
      else if i.specifier.kind == SyntaxKind.ObjectDestructure
        then visit.walkImportDirective(self, i)
    }

    visitPattern: visit.walkingVisitor.visitPattern
    visitIdentifierPattern: |self, p: Identifier| {
      variableDeclaration.map(|d| {
        scope.define({name: p.name, mutable: d.mutable, token: d}, true)
      })
    }
  })
}
