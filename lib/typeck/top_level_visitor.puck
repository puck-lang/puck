import 'puck:js' as {Object, undefined}
import '../ast/ast.puck' as {
  Module
  Expression

  Block

  EnumDeclaration
  TraitDeclaration
  TypeDeclaration

  ExportDirective
  ImportDirective
  ImportSpecifier
  ObjectDestructure

  Identifier
  FunctionDeclaration
  VariableDeclaration

  TypeBound
}
import '../ast/span.puck' as {ToSpan}
import '../ast/visit.puck' as visit
import '../compiler/ast.ts' as {SyntaxKind}
import '../entities.puck' as {StructKind, TypeClass, TypeKind}

/// Visits and declares top level bindings
///
/// The result is used by the import visitor for import and exports but is then
/// throwed away becouse too little information is known about the imported bindings
export fn TopLevelVisitor(context, file) {
  let mut declarations: ObjectMap<ToSpan> = ObjectMap.new()
  let reportError: (ToSpan, String) -> () = context.reportError.bind(context, file)

  Object.assign({}, visit.emptyVisitor, {

    visitModule: |self, mut m: Module| {
      m.declarations = declarations
      m.file = file
      visit.walkModule(self, m)
    }
    visitEnumDeclaration: |self, t: EnumDeclaration| {
      declarations.set(t.name.name, t)
    }
    visitTraitDeclaration: |self, t: TraitDeclaration| {
      declarations.set(t.name.name, t)
    }
    visitTypeDeclaration: |self, t: TypeDeclaration| {
      declarations.set(t.name.name, t)
    }

    visitExportDirective: |self, e: ExportDirective| {
      visit.walkExportDirective(self, e)
    }
    visitImportDirective: |self, i: ImportDirective| {
      match i.specifier {
        ImportSpecifier::Identifier(identifier) => {
          declarations.set(identifier.name, identifier)
        }
        ImportSpecifier::ObjectDestructure(d) => {
          self.visitObjectDestructure(d)
        }
        ImportSpecifier::Asterisk(_) => {}
      }
    }
    visitObjectDestructure: |self, i: ObjectDestructure| {
      i.members.forEach(|m| {
        declarations.set(m.local.name, m)
      })
    }

    visitFunctionDeclaration: |self, mut f: FunctionDeclaration| {
      if let Option::Some(name) = f.name {
        declarations.set(name.name, f)
      }
    }
    visitVariableDeclaration: |self, d: VariableDeclaration| {
      visit.walkVariableDeclaration(self, d)
    }

    visitPattern: visit.walkingVisitor.visitPattern
    visitIdentifierPattern: |self, p: Identifier| {
      declarations.set(p.name, p)
    }
  })
}
