import 'puck:js' as {Object}
import '../ast/ast.puck' as {
  Module
  Expression

  Block

  EnumDeclaration
  TraitDeclaration
  TypeDeclaration

  ExportDirective
  ImportDirective
  ImportSpecifier
  ObjectDestructure

  Identifier
  FunctionDeclaration
  VariableDeclaration

  TypeBound
}
import '../ast/visit.puck' as visit
import '../compiler/ast.ts' as {SyntaxKind}
import '../entities.puck' as {StructKind, TypeClass, TypeKind}
import 'src/scope.puck' as {createScope}

/// Visits and declares top level bindings
///
/// The result is used by the import visitor for import and exports but is then
/// throwed away becouse too little information is known about the imported bindings
export fn TopLevelVisitor(context, file) {
  let mut scope = createScope(context, file)
  let mut variableDeclaration: Option<VariableDeclaration> = None
  let reportError = context.reportError.bind(context, file)

  Object.assign({}, visit.emptyVisitor, {

    visitModule: |self, mut m: Module| {
      m.scope = scope
      visit.walkModule(self, m)
    }
    visitEnumDeclaration: |self, t: EnumDeclaration| {
      scope.defineType({
        displayName: None
        name: Some(t.name.name)
        kind: TypeKind::Enum({
          implementations: []
          members: ObjectMap.new()
        })
        class: TypeClass.fromAstNode(t, reportError)
        instance: None
      }, t)
    }
    visitTraitDeclaration: |self, t: TraitDeclaration| {
      scope.defineType({
        displayName: None
        name: Some(t.name.name)
        kind: TypeKind::Trait({
          isShorthand: false
          functions: ObjectMap.new()
        })
        class: TypeClass.fromAstNode(t, reportError)
        instance: None
      }, t)
    }
    visitTypeDeclaration: |self, t: TypeDeclaration| {
      let structKind =
        if let Option::Some(typeBound) = t.bound {
          match typeBound {
            TypeBound::RecordTypeBound(record) => StructKind::Record({properties: ObjectMap.new()})
            TypeBound::TupleTypeBound(tuple) => StructKind::Tuple({properties: []})
            _ => throw 'Unreachable'
          }
        }
        else StructKind::Unit

      scope.defineType({
        displayName: None
        name: Some(t.name.name)
        kind: TypeKind::Struct({
          implementations: []
          kind: structKind
        })
        class: TypeClass.fromAstNode(t, reportError)
        instance: None
      }, t)
    }

    visitExportDirective: |self, e: ExportDirective| {
      visit.walkExportDirective(self, e)
    }
    visitImportDirective: |self, i: ImportDirective| {
      match i.specifier {
        ImportSpecifier::Identifier(identifier) => {
          scope.define({name: identifier.name, mutable: false, token: identifier})
        }
        ImportSpecifier::ObjectDestructure(d) => {
          self.visitObjectDestructure(d)
        }
        ImportSpecifier::Asterisk(_) => {}
      }
    }
    visitObjectDestructure: |self, i: ObjectDestructure| {
      // Allow redeclaration in this pass as we don't yet know if the type or variable scope
      // should be used for the imported identifiers.
      i.members.forEach(|m| scope.define({name: m.local.name, mutable: false, token: m}, true))
    }

    visitFunctionDeclaration: |self, mut f: FunctionDeclaration| {
      if let Option::Some(name) = f.name then
        scope.define({
          name: name.name
          token: f
          mutable: false
        })
    }
    visitVariableDeclaration: |self, d: VariableDeclaration| {
      variableDeclaration = Some(d)
      visit.walkVariableDeclaration(self, d)
      variableDeclaration = None
    }

    visitPattern: visit.walkingVisitor.visitPattern
    visitIdentifierPattern: |self, p: Identifier| {
      variableDeclaration.map(|d| {
        scope.define({name: p.name, mutable: d.mutable, token: d}, true)
      })
    }
  })
}
