import 'node:util' as {inspect}
import 'puck:js' as {Object, undefined}
import '../ast/ast.puck' as {
  Expression

  Block
  FunctionDeclaration
  Identifier
  ImplDeclaration
  Module
  ObjectDestructure
  TypeBound
  FunctionTypeBound
  NamedTypeBound
  TraitDeclaration
  TypeDeclaration
  TypeParameter
  VariableDeclaration

  ExportDirective
  ImportDirective

  AssignmentExpression
  BinaryExpression
  CallExpression
  ForExpression
  IfExpression
  LoopExpression
  UnaryExpression
  WhileExpression

  IndexAccess
  MemberAccess

  Token
  ReturnStatement

  ListLiteral
  BooleanLiteral
  NumberLiteral
  ObjectLiteral
  StringLiteral
}
import '../ast/visit.puck' as visit
import '../compiler/ast.ts' as {SyntaxKind}
import 'src/range.puck' as {checkRange}
import 'src/scope.puck' as {createScope}
import 'src/structure_visitor.puck' as {notAssignableError, structureVisitor}
import 'src/types.puck' as {getType, isAssignable, isSameType}
import '../entities.puck' as {
  isStruct
  isTrait
  isTypeInstance
  Binding
  FunctionType
  Scope
  Struct
  TypeInstance
}

export fn ScopeVisitor(context, file) {
  let mut importDirective: ImportDirective
  let reportError = context.reportError.bind(context, file)

  fn getBinding(token: Expression)
    then if token.kind == SyntaxKind.Identifier
      then token.scope.getBinding(token.name)
    else if token.kind == SyntaxKind.MemberAccess
      then getBinding(token.object)
    else if token.kind == SyntaxKind.IndexAccess
      then getBinding(token.object)

  fn checkFunctionCall(function: FunctionType, c: CallExpression) {
    if not function then return undefined
    let name = c.func.name or function.name

    if not function.arguments
      then reportError(c, '$name is not callable')

    if function.selfBinding and function.selfBinding.mutable {
      let binding = getBinding(c.func)
      if binding and not binding.mutable
        then reportError(c, '$name can only be called on a mutable binding')
    }

    if let error = checkRange(c.argumentList, function.argumentRange, 'arguments', name)
      then reportError(c, error)

    c.argumentList.forEach(|argument, i| {
      let parameter = function.arguments[i]

      if not isAssignable(parameter.ty, argument.ty)
        then reportError(argument, notAssignableError(parameter.ty, argument.ty))

      if parameter.mutable and argument.kind == SyntaxKind.Identifier {
        let argumentName = argument.name
        let argumentBinding = argument.scope.getBinding(argumentName)

        if not argumentBinding.mutable {
          let parameterName =
            if parameter.identifier
              then parameter.identifier.name
              else i
          reportError(argument
            'Parameter $parameterName of $name requires a mutable binding ' +
            'but $argumentName is declared as immutable.'
          )
        }
      }
    })
  }

  fn checkFunctionAssignability(to: FunctionType, subject: FunctionType, token) {
    checkRange(subject.arguments, to.argumentRange, reportError, 'arguments', subject.name, token)

    subject.arguments.forEach(|subjectArgument, i| {
      let toArgument = to.arguments[i]

      if not isAssignable(toArgument.ty, subjectArgument.ty)
        then reportError(
          token
          'Types of parameter #$i does not match. ' + subjectArgument.ty.name +
          ' is not assignable to ' + toArgument.ty.name
        )

      if subjectArgument.mutable and not toArgument.mutable
        then reportError(
          token
          'Parameter #$i is required to be immutable'
        )
    })

    if not isAssignable(to.returnType, subject.returnType)
      then reportError(
        token
        'Return type ' + subject.returnType.name + ' is not assignable to ' + to.returnType.name
      )
  }

  fn defineHoisted(expressions, visitor) {
    expressions.forEach(|mut e| {
      if e.kind == SyntaxKind.Function {
        e.hoisting = true
        visitor.visitFunctionDeclaration(e)
        e.hoisted = true
      }
      if e.kind == SyntaxKind.ExportDirective and
          e.expression.kind == SyntaxKind.Function {
        e.expression.hoisting = true
        visitor.visitFunctionDeclaration(e.expression)
        e.expression.hoisted = true
      }
    })
  }

  Object.assign({}, visit.walkingVisitor, structureVisitor, {
    reportError

    visitBlock: |self, mut b: Block| {
      b.scope = self.scope

      defineHoisted(b.expressions, self)

      visit.walkBlock(self, b)
    }
    visitFunctionDeclaration: |mut self, mut f: FunctionDeclaration| {
      structureVisitor.visitFunctionDeclaration.call(self, f)

      if not f.hoisting or f.hoisted {
        self.scope = f.scope

        f.parameterList.forEach(|p| self.visitVariableDeclaration(p))
        if f.body then self.visitBlock(f.body)

        self.scope = self.scope.parent
      }
    }
    visitIdentifier: |self, mut i: Identifier| {
      i.scope = self.scope
      let binding = i.scope.getBinding(i.name)
      if not binding
        then reportError(i, 'Use of undefined variable ' + i.name)
        else i.ty = binding.ty
      visit.walkIdentifier(self, i)
    }
    visitImplDeclaration: |self, mut i: ImplDeclaration| {
      i.members.forEach(self.visitFunctionDeclaration.bind(self))
    }
    visitModule: |mut self, mut m: Module| {
      self.scope = m.scope

      defineHoisted(m.expressions, self)

      visit.walkModule(self, m)
    }
    visitObjectDestructure: |self, mut i: ObjectDestructure| {}
    visitTraitDeclaration: |mut self, mut t: TraitDeclaration| {
      self.scope = t.scope
      visit.walkTraitDeclaration(self, t)
      self.scope = self.scope.parent
    }
    visitTypeDeclaration: |self, mut t: TypeDeclaration| {}
    visitVariableDeclaration: |mut self, mut d: VariableDeclaration, visitInitializer, ty| {
      structureVisitor.visitVariableDeclaration.call(
        self
        d
        if visitInitializer
          then visitInitializer
          else |e| {
            let parentAssignedTo = self.assignedTo
            self.assignedTo = d
            self.visitExpression(e)
            self.assignedTo = parentAssignedTo
          }
        ty
      )
    }

    visitExportDirective: |self, mut e: ExportDirective| {
      visit.walkExportDirective(self, e)
    }
    visitImportDirective: |self, mut i: ImportDirective| {}

    visitAssignmentExpression: |self, mut e: AssignmentExpression| {
      e.scope = self.scope
      visit.walkAssignmentExpression(self, e)
      if let binding = getBinding(e.lhs) {
        if not binding.mutable
          then reportError(e, "Can't assign to immutable variable " + binding.name)

        if not isAssignable(e.lhs.ty, e.rhs.ty)
          then reportError(e, notAssignableError(e.lhs.ty, e.rhs.ty))
      }
    }
    visitBinaryExpression: |self, mut e: BinaryExpression| {
      e.scope = self.scope
      visit.walkBinaryExpression(self, e)
    }
    visitCallExpression: |mut self, mut e: CallExpression| {
      e.scope = self.scope
      self.visitExpression(e.func)

      let mut functionType = e.func.ty

      if e.func.kind == SyntaxKind.MemberAccess and e.func.object.ty {
        let name = e.func.member.name
        let objectType = e.func.object.ty
        let isDirectTraitCall = isTrait(objectType)

        if isDirectTraitCall {
          functionType = objectType.functions[name]

          if not functionType
            then reportError(e, objectType.name + ' has no function named $name')

          if functionType.selfBinding
            then throw 'direct trait calls for functions with self bindings are not implemented'
        }
        else {
          fn getImplementations(ty: Struct) {
            let implementations = ty.implementations
              .filter(|i| i.tra.functions[name])

            let implementations =
              if implementations.length > 1
                then implementations
                  .filter(|i| e.scope.getTypeBinding(
                    if isTypeInstance(i.tra)
                      then i.tra.class.name
                      else i.tra.name
                  ))
              else implementations

            let implementations =
              if implementations.length > 1
                then implementations
                  .map(|i| i.tra.functions[name].argumentRange)
                  .filter(|range: Range| range.contains(e.argumentList.length))
              else implementations

            if implementations.length > 1 then reportError(e, 'Ambiguous trait call')

            if implementations.length == 0 and isTypeInstance(ty)
              then getImplementations(ty.class)
              else implementations
          }

          let implementations = getImplementations(objectType)

          if implementations.length == 1 {
            let implementation = implementations[0]
            let traitName =
              if isTypeInstance(implementation.tra)
                then implementation.tra.class.name
                else implementation.tra.name
            if not e.scope.getTypeBinding(traitName)
              then reportError(e, 'The function $name is defined in trait $traitName but it is not in scope')

            e.traitName = traitName
            e.implementationType = implementation.ty

            functionType = implementation.tra.functions[name]
          }
        }
      }
      let parentAssignedTo = self.assignedTo
      e.argumentList.forEach(|a, i| {
        self.assignedTo = if functionType then functionType.arguments[i]
        self.visitExpression(a)
      })
      self.assignedTo = parentAssignedTo

      if functionType {
        checkFunctionCall(functionType, e)
        e.ty = functionType.returnType
      }
    }
    visitForExpression: |mut self, mut e: ForExpression| {
      self.scope = createScope(context, file, self.scope)
      e.scope = self.scope
      visit.walkForExpression(self, e)
      self.scope = self.scope.parent
    }
    visitIfExpression: |mut self, mut e: IfExpression| {
      self.scope = createScope(context, file, self.scope)
      e.scope = self.scope
      visit.walkIfExpression(self, e)
      self.scope = self.scope.parent
    }
    visitLoopExpression: |mut self, mut e: LoopExpression| {
      self.scope = createScope(context, file, self.scope)
      e.scope = self.scope
      visit.walkLoopExpression(self, e)
      self.scope = self.scope.parent
    }
    visitUnaryExpression: |self, mut e: UnaryExpression| {
      e.scope = self.scope
      visit.walkUnaryExpression(self, e)

      e.ty =
        if e.operator.kind == SyntaxKind.NotKeyword
          then e.scope.getTypeBinding('Bool').ty
        else if e.operator.kind == SyntaxKind.MinusToken
             or e.operator.kind == SyntaxKind.PlusToken
          then e.scope.getTypeBinding('Num').ty
    }
    visitWhileExpression: |mut self, mut e: WhileExpression| {
      self.scope = createScope(context, file, self.scope)
      e.scope = self.scope
      visit.walkWhileExpression(self, e)
      self.scope = self.scope.parent
    }
    visitIndexAccess: |self, mut a: IndexAccess| {
      a.scope = self.scope
      visit.walkIndexAccess(self, a)
    }
    visitMemberAccess: |self, mut a: MemberAccess| {
      a.scope = self.scope
      visit.walkExpression(self, a.object)
      if a.object.ty and isStruct(a.object.ty) {
        a.ty = a.object.ty.properties[a.member.name]
      }
    }

    visitBreak: |self, mut b: Token| {
      b.scope = self.scope
      visit.walkBreak(self, b)
    }
    visitReturn: |self, mut r: ReturnStatement| {
      r.scope = self.scope
      visit.walkReturn(self, r)
    }

    visitListLiteral: |self, mut l: ListLiteral| {
      l.scope = self.scope
      visit.walkListLiteral(self, l)
    }
    visitBooleanLiteral: |self, mut l: BooleanLiteral| {
      l.scope = self.scope
      l.ty = self.scope.getTypeBinding('Bool').ty
      visit.walkBooleanLiteral(self, l)
    }
    visitNumberLiteral: |self, mut l: NumberLiteral| {
      l.scope = self.scope
      l.ty = self.scope.getTypeBinding('Num').ty
      visit.walkNumberLiteral(self, l)
    }
    visitObjectLiteral: |self, mut l: ObjectLiteral| {
      l.scope = self.scope
      l.members.forEach(|m| {
        self.visitExpression(m.value)
      })
    }
    visitStringLiteral: |self, mut l: StringLiteral| {
      l.scope = self.scope
      l.ty = self.scope.getTypeBinding('String').ty
      visit.walkStringLiteral(self, l)
    }
  })
}

