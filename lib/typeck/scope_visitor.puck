import 'puck:core' as core
import 'puck:js' as {Object, global, undefined}
import 'node:util' as {inspect}
import '../ast/ast.puck' as {
  Module
  TopLevelStatement
  BlockLevelStatement
  Expression

  EnumDeclaration
  EnumMember
  ImplDeclaration
  ImplShorthandDeclaration
  TraitDeclaration
  TypeDeclaration

  ExportDirective
  ExportedStatement
  ImportDirective
  ObjectDestructure

  Block
  BreakStatement
  ReturnStatement
  WhileLoop

  Identifier
  FunctionDeclaration
  VariableDeclaration

  AssignmentExpression
  BinaryExpression
  CallExpression
  IfExpression
  IfLetExpression
  MatchExpression
  MatchArm
  TypePathExpression
  TypePath
  UnaryExpression

  IndexAccess
  MemberAccess
  UnknownAccess
  UnknownIndexAccess

  BooleanLiteral
  ListLiteral
  NumberLiteral
  RecordLiteral
  StringLiteral
  TupleLiteral

  Pattern
  RecordPattern
  TuplePattern

  TypeBound
  FunctionTypeBound
  NamedTypeBound
  RecordTypeBound
  RecordTypeBoundMember
  TupleTypeBound
  TypeParameter
}
import '../ast/span.puck' as {Span, ToSpan}
import '../ast/token.puck' as {SyntaxKind}
import '../ast/visit.puck' as visit
import 'src/enums.puck' as {checkExhaustive}
import 'src/functions.puck' as {resolveFunctionTypeParameters}
import 'src/impls.puck' as {getImplementation, getImplementationForTrait, resolveImplTypeParameters}
import 'src/patterns.puck' as {PatternError, declarePatternVariables}
import 'src/range.puck' as {checkRange}
import 'src/scope.puck' as {Binding, Scope}
import 'src/structure_visitor.puck' as {notAssignableError, structureVisitor}
import 'src/type_function.puck' as {enumMemberToFunction}
import 'src/types.puck' as {
  createTypeInstance
  findCommonType
  isAssignable
  isSameType
  resolveTypeParameters
}
import '../entities.puck' as {
  Function
  Implementation
  Struct
  StructKind
  Type
  TypeInstance
  TypeKind
}

fn asType(a: Unknown) -> Type {a.transmute()}

fn getBinding(e: Expression) -> Option<Binding> {
  match e {
    Expression::Identifier(i) => {
      let scope: Scope = i->scope.transmute()
      scope.getBinding(i.name)
    }
    Expression::IndexAccess(i) => getBinding(i.object)
    Expression::MemberAccess(i) => getBinding(i.object)
    _ => None
  }
}

fn getCoreType(scope: Scope, id: String, description: String) -> Result<(Type, Binding), String> {
  if let Some(binding) = scope.getBindingByTypeId(id)
    then Ok((binding.type_.providesType.unwrap(), binding))
    else Err('puck:core::$id is not in scope. Please import $id from puck:core to use $description.')
}

fn asTraitCall(visitor, mut e: BinaryExpression, trait_: String, method: String, desription: String) -> Result<(), String> {
  match getCoreType(visitor.scope, trait_, desription) {
    Ok((_, binding)) => {
      let mut call = CallExpression({
        func: Expression::MemberAccess({
          object: Expression::Identifier({name: binding.name, span: e.operator.span})
          member: {name: method, span: {start: e.operator.span.start, end: e.operator.span.end}}
        })
        openParen: e.operator
        argumentList: [e.lhs, e.rhs]
        closeParen: e.operator
      })
      visitor.visitCallExpression(call)
      e->call = call
      e->type_ = call->type_
      Ok(())
    }
    Err(err) => Err(err)
  }
}

export fn ScopeVisitor(context, file) {
  let mut importDirective: ImportDirective
  let mut matchExpression: Option<MatchExpression> = None
  let reportError: (ToSpan, String) -> () = context.reportError.bind(context, file)
  let mut accessError: Option<(ToSpan, String)> = None

  fn checkFunctionCall(mut functionType: Type, c: CallExpression) {
    if not functionType then return undefined
    let namei: Option<String> =
      match c.func {
        Expression::Identifier(i) => Some(i.name)
        _ => None
      }
    let name = namei.unwrapOrElse(|| functionType.displayName())

    let function = match functionType.kind {
      TypeKind::Function(func) => func
      _ => {
        reportError(c, '$name is not callable')
        return undefined
      }
    }

    if let Option::Some(selfBinding) = function.selfBinding {
      if selfBinding.mutable {
        if not getBinding(c.func).mapOr(true, |binding| binding.mutable)
          then reportError(c, '$name can only be called on a mutable binding')
      }
    }

    if let Result::Err(error) = checkRange(c.argumentList, function.parameterRange, 'arguments', name) {
      reportError(c, error)
      return function
    }

    c.argumentList.enumerate().forEach(|(i, argument)| {
      let parameter = function.parameters.get(i).unwrap()
      let parameterName = parameter.name

      if not isAssignable(parameter.type_, argument.getType())
        then reportError(argument
          notAssignableError(parameter.type_, argument.getType()) +
          ' in parameter $parameterName of function $name'
        )

      if parameter.mutable {
        if let Option::Some(argumentBinding) = getBinding(argument) {
          let argumentName = argumentBinding.name

          if not argumentBinding.mutable {
            reportError(argument
              'Parameter $parameterName of function $name requires a mutable binding ' +
              'but $argumentName is declared as immutable.'
            )
          }
        }
      }
    })

    function
  }

  let structureVisitorInstance = structureVisitor(reportError)
  Object->assign({}, visit.walkingVisitor, structureVisitorInstance, {
    reportError

    visitModule: |mut self, mut m: Module| {
      self.scope = m->scope

      // Hoist function declarations
      m.statements.forEach(|s| match s {
        TopLevelStatement::ExportDirective(
          {statement: ExportedStatement::FunctionDeclaration(f)}
        ) => {
          self.visitFunctionDeclaration(f, true)
        }
        TopLevelStatement::BlockLevelStatement(
          BlockLevelStatement::Expression(Expression::FunctionDeclaration(f))
        ) => {
          self.visitFunctionDeclaration(f, true)
        }
        _ => {}
      })

      m.statements.forEach(|s| {
        self.isUsed = false
        self.visitTopLevelStatement(s)
      })
    }
    visitBlockLevelStatement: |mut self, s: BlockLevelStatement, assignedTo = undefined, isUsed = true| {
      match s {
        BlockLevelStatement::Expression(e) => self.visitExpression(e, assignedTo, isUsed)
        _ => visit.walkBlockLevelStatement(self, s)
      }
    }
    visitExpression: |mut self, e: Expression, assignedTo = undefined, isUsed = true| {
      self.isUsed = isUsed
      let parentAssignedTo = self.assignedTo
      self.assignedTo = assignedTo
      visit.walkExpression(self, e)
      self.assignedTo = parentAssignedTo
    }

    visitImplDeclaration: |self, mut i: ImplDeclaration| {
      i.members.forEach(|f| self.visitFunctionDeclaration(f))
    }
    visitImplShorthandDeclaration: |self, mut i: ImplShorthandDeclaration| {
      i.members.forEach(|f| self.visitFunctionDeclaration(f))
    }
    visitTraitDeclaration: |mut self, mut t: TraitDeclaration| {
      let parentScope = self.scope
      self.scope = t->scope
      visit.walkTraitDeclaration(self, t)
      self.scope = parentScope
    }
    visitTypeDeclaration: |self, mut t: TypeDeclaration| {}

    visitExportDirective: |self, mut e: ExportDirective| {
      visit.walkExportDirective(self, e)
    }
    visitImportDirective: |self, mut i: ImportDirective| {}
    visitObjectDestructure: |self, mut i: ObjectDestructure| {}

    visitBlock: |mut self, mut b: Block, isUsed = true| {
      b->scope = self.scope
      let assignedTo = self.assignedTo

      // Hoist function declarations
      b.statements.forEach(|s| match s {
        BlockLevelStatement::Expression(Expression::FunctionDeclaration(f)) => {
          self.visitFunctionDeclaration(f, true)
        }
        _ => {}
      })

      let lastIndex = b.statements.size() - 1
      b.statements.enumerate().forEach(|(index, s)| {
        if index == lastIndex
          then self.visitBlockLevelStatement(s, assignedTo, isUsed)
          else self.visitBlockLevelStatement(s, undefined, false)
      })

      b->type_ =
        if let Option::Some(last) = b.statements.last()
          then last.getType()
          else Type.empty()
    }
    visitBreak: |self, mut b: BreakStatement| {
      b->scope = self.scope
    }
    visitReturn: |mut self, mut r: ReturnStatement| {
      visit.walkReturn(self, r)
      if let Some(returnType) = self.functionContext.returnType {
        if not isAssignable(returnType, r.expression.getType())
          then reportError(r.expression, notAssignableError(returnType, r.expression.getType()))
      }
      else if r.expression.getType() {
        self.functionContext.returnTypes.push(r.expression.getType())
      }
    }
    visitWhileLoop: |mut self, mut e: WhileLoop| {
      let parentScope: Scope = self.scope
      self.scope = parentScope.createChild()
      e->scope = self.scope
      self.visitExpression(e.condition)
      self.visitBlock(e.body, false)
      e->type_ = Type.empty()
      self.scope = parentScope
    }

    visitIdentifier: |self, mut i: Identifier| {
      let scope: Scope = self.scope
      i->scope = self.scope
      if let Option::Some(binding) = scope.getBinding(i.name) {
        let mut b = binding
        i->binding = binding
        i->type_ =
          if binding.type_ and binding.type_.providesType.isSome()
            then enumMemberToFunction(b.type_)
            else binding.type_
      }
      else reportError(i, 'Use of undefined variable ' + i.name)
      visit.walkIdentifier(self, i)
    }
    visitFunctionDeclaration: |mut self, mut f: FunctionDeclaration, isHoisting = false| {
      structureVisitorInstance.visitFunctionDeclaration->call(self, f)

      if not isHoisting {
        let selfScope = self.scope
        self.scope = f->scope

        f.parameterList.forEach(|p| self.visitVariableDeclaration(p))
        if let Option::Some(body) = f.body {
          let parentAssignedTo = self.assignedTo
          let parentContext = self.functionContext
          let mut isUsed = true
          self.functionContext = {
            returnType: None
            returnTypes: []
          }
          if let TypeKind::Function(func) = f.type_.kind {
            self.assignedTo = func.returnType
            if func.returnType {
              self.functionContext.returnType = Some(func.returnType)

              if func.returnType.isEmpty() {
                isUsed = false
              }
            }
          }
          self.visitBlock(body, isUsed)
          if let Option::None = self.functionContext {
          }

          if let TypeKind::Function(func) = f.type_.kind {
            if func.returnType {
              if not isAssignable(func.returnType, body.type_) and not func.returnType.isEmpty()
                then reportError(f, notAssignableError(func.returnType, body.type_))
            }
            else {
              let mut types: List<Type> = self.functionContext.returnTypes
              if body.type_ {
                types.push(body.type_)
              }

              if types.isNotEmpty() {
                match findCommonType(types) {
                  Result::Ok(type_) => {
                    Object->assign(func, {
                      returnType: body.type_
                    })
                  }
                  Result::Err(_) => reportError(f,
                    'No best common type exists among return expressions. Found ' + types.map(|type_| type_.displayName())->join(', ')
                  )
                }
              }
            }
          }

          self.assignedTo = parentAssignedTo
          self.functionContext = parentContext
        }

        self.scope = selfScope
      }
    }
    visitVariableDeclaration: |mut self, mut d: VariableDeclaration, visitInitializer, type_| {
      structureVisitorInstance.visitVariableDeclaration->call(
        self
        d
        if visitInitializer
          then visitInitializer
          else |e| {
            self.isUsed = true
            self.visitExpression(e, d->type_)
          }
        type_
      )
    }

    visitAssignmentExpression: |self, mut e: AssignmentExpression| {
      e->scope = self.scope
      if let Expression::IndexAccess(a) = e.lhs {
        visit.walkIndexAccess(self, a)
        self.visitExpression(e.rhs)
      }
      else {
        visit.walkAssignmentExpression(self, e)
      }
      if let Option::Some(binding) = getBinding(e.lhs) {
        if not binding.mutable
          then reportError(e, "Can't assign to immutable variable " + binding.name)

        if not isAssignable(e.lhs.getType(), e.rhs.getType())
          then reportError(e, notAssignableError(e.lhs.getType(), e.rhs.getType()))
      }

      e->type_ = e.lhs.getType() or e.rhs.getType()
    }
    visitBinaryExpression: |self, mut e: BinaryExpression| {
      match e.operator.kind {
        SyntaxKind::LessThanToken => {
          asTraitCall(self, e, 'PartialOrd', 'lt', 'comparison operators')
        }
        SyntaxKind::LessThanEqualsToken => {
          asTraitCall(self, e, 'PartialOrd', 'le', 'comparison operators')
        }
        SyntaxKind::GreaterThanToken => {
          asTraitCall(self, e, 'PartialOrd', 'gt', 'comparison operators')
        }
        SyntaxKind::GreaterThanEqualsToken => {
          asTraitCall(self, e, 'PartialOrd', 'ge', 'comparison operators')
        }
        _ => {
          visit.walkBinaryExpression(self, e)
        }
      }
    }
    visitCallExpression: |mut self, mut e: CallExpression| {
      e->scope = self.scope
      let scope: Scope = self.scope

      let mut functionType: Type;
      let mut isUnknownCall = false
      // If it's a direct trait call the first argument is walked when
      // resolving the implementation
      let mut skipFirstArgument = false

      if let Expression::MemberAccess(access) = e.func {
        self.visitMemberAccess(access, true)
        functionType = e.func.getType()

        if access.object.getType() {
          let name = access.member.name
          let objectType: Type = access.object.getType()

          // If the call is directly on the type, for example Num.parse()
          if let Option::Some(providesType) = objectType.providesType {
            match providesType.kind {
              TypeKind::Enum(enum_) => {
                functionType = enum_.implementations
                  .find(|{trait_}| trait_.getTrait().isShorthand)
                  .andThen(|{trait_}| trait_.getTrait().functions.get(name))
                  .unwrapOr(undefined)
              }
              TypeKind::Struct(struct) => {
                functionType = struct.implementations
                  .find(|{trait_}| trait_.getTrait().isShorthand)
                  .andThen(|{trait_}| trait_.getTrait().functions.get(name))
                  .unwrapOr(undefined)
              }
              TypeKind::Trait(trait_) => {
                functionType = trait_.functions.get(name).unwrapOr(undefined)
              }
              _ => {}
            }

            if functionType {
              let function = functionType.getFunction()

              if let Some(selfBinding) = function.selfBinding {
                functionType = {
                  id: functionType.id
                  displayName: functionType.displayName
                  name: functionType.name
                  kind: TypeKind::Function({
                    selfBinding: None
                    parameters: [selfBinding]->concat(function.parameters).transmute()
                    parameterRange: {start: function.parameterRange.start + 1, end: function.parameterRange.end + 1}
                    returnType: function.returnType
                    isAbstract: function.isAbstract
                  })
                  class: functionType.class
                  instance: functionType.instance
                  providesType: functionType.providesType
                  enumMember: functionType.enumMember
                }
                if let Some(selfArgument) = e.argumentList.first() {
                  skipFirstArgument = true
                  self.visitExpression(selfArgument)
                  if not selfArgument.getType() {
                    reportError(selfArgument, 'selfArgument has no type')
                  }
                  match getImplementationForTrait(selfArgument.getType(), objectType.providesType.unwrapOr(objectType)) {
                    Ok(Some(implementation)) => {
                      e->traitName = scope.getBindingByTypeId(providesType.id.unwrap()).unwrap().name
                      e->isDirectTraitCall =  true
                      e->implementation = implementation
                      if providesType.class.isSome() {
                        match resolveImplTypeParameters(e->implementation.transmute(), selfArgument.getType()) {
                          Ok(resolvedTrait) => {
                            let mut parameterMap = resolvedTrait.instance.unwrap().parameterMap
                            functionType = resolveTypeParameters(parameterMap)(functionType)
                          }
                          Err((to, subject)) => return reportError(e, notAssignableError(to, subject))
                        }
                      }
                    }
                    Ok(Option::None) => {
                      reportError(e,
                        objectType.displayName() + ' has not been implemented for type ' + selfArgument.getType().displayName()
                      )
                    }
                    Err => reportError(e, 'Ambiguous trait call')
                  }
                }
              }
              else {
                e->traitName = scope.getBindingByTypeId(providesType.id.unwrap()).unwrap().name
                e->isTraitObject =  true
              }
            }
            else reportError(e, providesType.displayName() + ' has no function named $name')
          }
          // It is a normal trait call, for example 'hello'.toUpperCase()
          else {
            if let TypeKind::Trait(trait_) = objectType.kind {
              if let Some(func) = trait_.functions.get(name) {
                functionType = func
                let function = functionType.getFunction()

                if function.selfBinding.isSome() {
                  if let Some(binding) = scope.getBindingByTypeId(objectType.id.unwrap()) {
                    e->traitName = binding.name
                    e->isTraitObject =  true
                  }
                  else {
                    let typeName = objectType.name.unwrap()
                    reportError(e, 'The function $name is defined in trait $typeName but it is not in scope')
                  }
                }
              }
            }
            else match getImplementation(name, objectType, e) {
              Ok(Some(implementation)) => {
                let trait_: Type =
                  if let Option::Some(instance) = implementation.trait_.instance
                    then instance.class
                    else implementation.trait_

                if let Some(binding) = scope.getBindingByTypeId(trait_.id.unwrap()) {
                  e->traitName = binding.name
                  e->isShorthand =  trait_.getTrait().isShorthand
                  e->implementation = implementation

                  functionType = implementation.trait_.getTrait().functions[name]
                }
                else {
                  let traitName = trait_.name.unwrap()
                  let id = trait_.id.unwrap()
                  reportError(e, 'The function $name is defined in trait $traitName but it is not in scope')
                }
              }
              Ok(None) => {}
              Err => reportError(e, 'Ambiguous trait call')
            }

            if e->traitName {
              if let Option::Some(instance) = objectType.instance {
                functionType = resolveTypeParameters(instance.parameterMap)(functionType)
              }
            }
          }
        }

        if e->traitName {
          accessError = None
        }
        else if let Some((token, message)) = accessError {
          reportError(token, message)
          accessError = None
        }
      }
      else {
        self.visitExpression(e.func)
        functionType = e.func.getType()

        if let Expression::UnknownAccess(_) = e.func {
          isUnknownCall = true
        }
        else if let Expression::UnknownIndexAccess(_) = e.func {
          isUnknownCall = true
        }
      }

      if not isUnknownCall and functionType and functionType.isFunction() {
        let callTypeParameters = functionType.class.map(|class| class.typeParameters).unwrapOr([])
        let mut callParameterMap: ObjectMap<Type> = ObjectMap.new()
        let functionKind = functionType.getFunction()
        e.argumentList.enumerate()
          // If too many arguments are passed e.argumentList will be longer than functionKind.parameters
          .take(functionKind.parameters.size())
          .forEach(|(i, a)| {
            let parameter = functionKind.parameters[i]
            if not skipFirstArgument or i > 0 {
              self.visitExpression(a, parameter->type_)
            }
            if callTypeParameters.isNotEmpty() and parameter->type_ and a.getType() {
              resolveFunctionTypeParameters(
                callParameterMap
                callTypeParameters
                parameter->type_.transmute()
                a.getType()
              )
            }
          })
        if callTypeParameters.isNotEmpty() {
          functionType = resolveTypeParameters(callParameterMap)(functionType)
        }
      }
      else {
        e.argumentList.forEach(|a| self.visitExpression(a))
      }
      if isUnknownCall {
        e->type_ = functionType
      }
      else if functionType {
        e->functionType = functionType
        let function = checkFunctionCall(functionType, e)
        if function {
          e->type_ = function.returnType
        }
      }
      ()
    }
    visitIfExpression: |mut self, mut e: IfExpression| {
      let parentScope: Scope = self.scope
      e->scope = self.scope
      let isUsed = self.isUsed
      self.visitExpression(e.condition)
      self.scope = parentScope.createChild()
      self.visitBlock(e.then_, isUsed and e.else_.isSome())
      if let Option::Some(else_) = e.else_ {
        self.scope = parentScope.createChild()
        self.visitBlock(else_, isUsed)
      }
      if isUsed {
        e->type_ =
          if let Option::Some(else_) = e.else_ {
            match  findCommonType([e.then_.type_, else_.type_]) {
              Result::Ok(type_) => type_
              Result::Err(_) => {
                reportError(e
                  'Type ' + e.then_.type_.displayName() + ' and ' + else_.type_.displayName() + ' is not compatible'
                )
                Type.empty()
              }
            }
          }
          else Type.empty()
      }
      self.scope = parentScope
    }
    visitIfLetExpression: |mut self, mut e: IfLetExpression| {
      let parentScope: Scope = self.scope
      e->scope = self.scope
      self.scope = parentScope.createChild()
      let isUsed = self.isUsed
      self.visitPattern(e.pattern)
      self.visitExpression(e.expression)
      match declarePatternVariables(self.scope, self, e.pattern, false, e.expression.getType(), true) {
        Result::Ok(_) => {}
        Result::Err(PatternError::PatternMismatch(pattern, to, subject)) => {
          reportError(e.expression, notAssignableError(to, subject))
        }
        Result::Err(PatternError::ScopeError(token, err)) => reportError(token, err)
        Result::Err(PatternError::NotExhaustive) => {
          // Allowed in if let expressions
        }
      }
      let expressionScope: Scope = self.scope
      self.scope = expressionScope.createChild()
      self.visitBlock(e.then_, isUsed)
      if let Option::Some(else_) = e.else_ {
        self.scope = expressionScope.createChild()
        self.visitBlock(else_, isUsed)
      }
      if isUsed {
        e->type_ =
          if let Option::Some(else_) = e.else_ {
            match findCommonType([e.then_.type_, else_.type_]) {
              Result::Ok(type_) => type_
              Result::Err(_) => {
                reportError(e
                  'Type ' + e.then_.type_.displayName() + ' and ' + else_.type_.displayName() + ' is not compatible'
                )
                Type.empty()
              }
            }
          }
          else Type.empty()
      }
      self.scope = parentScope
    }
    visitMatchExpression: |mut self, mut e: MatchExpression| {
      e->scope = self.scope
      let oldMatchExpression = matchExpression
      matchExpression = Some(e)

      let isUsed = self.isUsed

      self.visitExpression(e.expression)

      e.patterns.forEach(|a| self.visitMatchArm(a, isUsed))

      if not e.expression.getType() {
        return reportError(e.expression, 'No type in match expression')
      }

      if let Result::Err(error) = checkExhaustive(e) {
        reportError(e, error)
      }
      if isUsed {
        e->type_ =
          if e.patterns.isNotEmpty() {
            match findCommonType(e.patterns.map(|arm| arm->type_.transmute()).toList()) {
              Result::Ok(type_) => type_
              Result::Err(_) => {
                reportError(e
                  'Match arms return mixed types ' + e.patterns.map(|arm| asType(arm->type_.transmute()).displayName())->join(', ')
                )
                Type.empty()
              }
            }
          }
          else Type.empty()
      }

      matchExpression = oldMatchExpression
      ()
    }
    visitMatchArm: |mut self, mut a: MatchArm, isUsed| {
      let parentScope: Scope = self.scope
      self.scope = parentScope.createChild()
      a->scope = self.scope

      let m = matchExpression.unwrap()

      self.visitPattern(a.pattern)
      match declarePatternVariables(self.scope, self, a.pattern, false, m.expression.getType(), true) {
        Result::Ok(_) => {}
        Result::Err(PatternError::PatternMismatch(pattern, to, subject)) => {
          reportError(a, notAssignableError(to, subject))
        }
        Result::Err(PatternError::ScopeError(token, err)) => reportError(token, err)
        Result::Err(PatternError::NotExhaustive) => {
          // Allowed in match expressions
        }
      }

      self.visitBlock(a.block, isUsed)
      a->type_ = a.block->type_

      self.scope = parentScope
    }
    visitTypePathExpression: |self, mut e: TypePathExpression| {
      e->scope = self.scope
      let typePath = e.typePath
      self.visitTypePath(e.typePath)
      let mut type_: Type = e.typePath->type_.transmute()
      if type_ {
        e->type_ = enumMemberToFunction(type_)
      }
    }
    visitUnaryExpression: |self, mut e: UnaryExpression| {
      let scope: Scope = self.scope
      e->scope = self.scope
      visit.walkUnaryExpression(self, e)

      match e.operator.kind {
        SyntaxKind::NotKeyword => {
          if let Some(binding) = scope.getBindingByTypeId('Bool') {
            e->type_ = binding.type_.providesType.unwrap()
          }
          else reportError(e
            'puck:core::Bool is not in scope. Please import Bool from puck:core to use boolean literals.'
          )
        }
        SyntaxKind::MinusToken => {
          if let Some(binding) = scope.getBindingByTypeId('Num') {
            e->type_ = binding.type_.providesType.unwrap()
          }
          else reportError(e
            'puck:core::Num is not in scope. Please import Num from puck:core to use number literals.'
          )
        }
        SyntaxKind::PlusToken => {
          if let Some(binding) = scope.getBindingByTypeId('Num') {
            e->type_ = binding.type_.providesType.unwrap()
          }
          else reportError(e
            'puck:core::Num is not in scope. Please import Num from puck:core to use number literals.'
          )
        }
        _ => {}
      }
      ()
    }

    visitIndexAccess: |self, mut a: IndexAccess| {
      match getCoreType(self.scope, 'Index', 'index access') {
        Ok((_, binding)) => {
          let mut call = CallExpression({
            func: Expression::MemberAccess({
              object: Expression::Identifier({name: binding.name, span: a.object.span()})
              member: {name: 'index', span: {start: a.openBracket.span.start, end: a.closeBracket.span.end}}
            })
            openParen: a.openBracket
            argumentList: [a.object, a.index]
            closeParen: a.closeBracket
          })
          self.visitCallExpression(call)
          a->call = call
          a->type_ = call->type_
          ()
        }
        Err(err) => reportError(a, err)
      }
    }
    visitMemberAccess: |self, mut a: MemberAccess, inCallExpression = false| {
      self.visitExpression(a.object)
      if a.object.getType() {
        if let TypeKind::Struct({kind: StructKind::Record(record)}) = a.object.getType().kind {
          if let Some(type_) = record.properties.get(a.member.name) {
            a->type_ = type_
          }
          else {
            let message = a.object.getType().displayName() + ' has no property ' + a.member.name
            let token: ToSpan = a.member
            if inCallExpression
              then accessError = Some((token, message))
              else reportError(a, message)
          }
        }
        else {
          let message = 'Can only read properties on record types'
          let token: ToSpan = a.member
          if inCallExpression
            then accessError = Some((token, message))
            else reportError(a, message)
        }
      }
    }
    visitUnknownAccess: |self, mut a: UnknownAccess| {
      visit.walkExpression(self, a.object)
      match getCoreType(self.scope, 'Unknown', 'unknown access') {
        Ok((type_, _)) => a->type_ = type_
        Err(err) => reportError(a, err)
      }
      ()
    }
    visitUnknownIndexAccess: |self, mut a: UnknownIndexAccess| {
      visit.walkUnknownIndexAccess(self, a)
      match getCoreType(self.scope, 'Unknown', 'unknown access') {
        Ok((type_, _)) => a->type_ = type_
        Err(err) => reportError(a, err)
      }
      ()
    }

    visitBooleanLiteral: |self, mut l: BooleanLiteral| {
      let scope: Scope = self.scope
      l->scope = self.scope
      if let Some(binding) = scope.getBindingByTypeId('Bool') {
        l->type_ = binding.type_.providesType.unwrap()
      }
      else reportError(l
        'puck:core::Bool is not in scope. Please import Bool from puck:core to use boolean literals.'
      )
      visit.walkBooleanLiteral(self, l)
    }
    visitListLiteral: |self, mut l: ListLiteral| {
      let scope: Scope = self.scope
      let mut listType =
        if let Some(binding) = scope.getBindingByTypeId('List') {
          binding.type_.providesType.unwrap()
        }
        else return reportError(l
          'puck:core::List is not in scope. Please import List from puck:core to use list literals.'
        )
      let mut type_: Option<Type> = None
      if self.assignedTo {
        let a: Type = self.assignedTo
        if let TypeKind::Struct(_) = a.kind {
          if a.id.unwrapOr('') == 'List' {
            type_ = Some(a)
          }
        }
      }
      visit.walkListLiteral(self, l)
      if let Some(type_) = type_ {
        l->type_ = type_
      } else {
        if l.members.size() >= 1 {
          let types = l.members.map(|m| m.getType()).toList()
          let result: Result<Type, ()> = findCommonType(types)
          match result {
            Result::Ok(type_) => {
              if not type_ {
                l->type_ = listType
              } else {
                l->type_ = createTypeInstance(listType, [type_])
              }
            }
            Result::Err(_) => reportError(l, 'List contains mixed types')
          }
        }
        else {
          l->type_ = listType
        }
      }
      ()
    }
    visitNumberLiteral: |self, mut l: NumberLiteral| {
      let scope: Scope = self.scope
      if let Some(binding) = scope.getBindingByTypeId('Num') {
        l->type_ = binding.type_.providesType.unwrap()
        ()
      }
      else reportError(l
        'puck:core::Num is not in scope. Please import Num from puck:core to use number literals.'
      )
    }
    visitRecordLiteral: |self, mut l: RecordLiteral| {
      l->scope = self.scope
      l.members.forEach(|m| {
        self.visitExpression(m.value)
      })
      l->type_ = Type({
        id: None
        displayName: None
        name: None
        kind: TypeKind::Struct({
          implementations: []
          kind: StructKind::Record({
            properties: ObjectMap.fromIter(l.members.map(|m| {
              (m.name.name, m.value.getType())
            }))
          })
        })
        class: None
        instance: None
        providesType: None
        enumMember: None
      })
    }
    visitStringLiteral: |self, mut l: StringLiteral| {
      let scope: Scope = self.scope
      l->scope = self.scope
      if let Some(binding) = scope.getBindingByTypeId('String') {
        l->type_ = binding.type_.providesType.unwrap()
      }
      else reportError(l
        'puck:core::String is not in scope. Please import String from puck:core to use string literals.'
      )
      visit.walkStringLiteral(self, l)
    }
    visitTupleLiteral: |self, mut l: TupleLiteral| {
      l->scope = self.scope
      visit.walkTupleLiteral(self, l)
      l->type_ = Type({
        id: None
        displayName: None
        name: None
        kind: TypeKind::Struct({
          implementations: []
          kind: StructKind::Tuple({
            properties: l.expressions.map(|e| e.getType()).toList()
          })
        })
        class: None
        instance: None
        providesType: None
        enumMember: None
      })
    }

    visitPattern: |self, mut p: Pattern| {
      p->scope = self.scope
      visit.walkPattern(self, p)
      p->type_ =
        match p {
          Pattern::CatchAll => Type.unused()
          Pattern::Identifier(identifier) => undefined
          Pattern::Record(record) => record->type_.transmute()
          Pattern::RecordType(typePath, record) => {
            let type_: Type = typePath->providesType.transmute()
            if not isAssignable(record->type_.transmute(), type_)
              then reportError(p, type_.displayName() + ' is not assignable to pattern ' + record.displayName())
            type_.enumMember.mapOr(type_, |(_, enum_)| enum_)
          }
          Pattern::Tuple(tuple) => tuple->type_.transmute()
          Pattern::TupleType(typePath, tuple) => {
            let type_: Type = typePath->providesType.transmute()
            if not isAssignable(tuple->type_.transmute(), type_)
              then reportError(p, type_.displayName() + ' is not assignable to pattern ' + tuple.displayName())
            type_.enumMember.mapOr(type_, |(_, enum_)| enum_)
          }
          Pattern::UnitType(typePath) => undefined
        }
    }

    visitRecordPattern: |self, mut p: RecordPattern| {
      p->scope = self.scope
      visit.walkRecordPattern(self, p)
      p->type_ = Type({
        id: None
        displayName: None
        name: None
        kind: TypeKind::Struct({
          implementations: []
          kind: StructKind::Record({properties: ObjectMap.fromIter(
            p.properties.map(|p| (p.property.name, p.pattern->type_.transmute()))
          )})
        })
        instance: None
        class: None
        providesType: None
        enumMember: None
      })
    }
    visitTuplePattern: |self, mut p: TuplePattern| {
      p->scope = self.scope
      visit.walkTuplePattern(self, p)
      p->type_ = Type({
        id: None
        displayName: None
        name: None
        kind: TypeKind::Struct({
          implementations: []
          kind: StructKind::Tuple({properties: p.properties.map(|p| p->type_.transmute()).toList()})
        })
        instance: None
        class: None
        providesType: None
        enumMember: None
      })
    }
  })
}
