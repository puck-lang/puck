import 'node:util' as {inspect}
import 'puck:js' as {Object, undefined}
import '../ast/ast.puck' as {
  Expression

  Block
  FunctionDeclaration
  Identifier
  ImplDeclaration
  Module
  ObjectDestructure
  TypeBound
  FunctionTypeBound
  NamedTypeBound
  TraitDeclaration
  TypeDeclaration
  TypeParameter
  TypePath
  VariableDeclaration

  ExportDirective
  ImportDirective

  Pattern

  AssignmentExpression
  BinaryExpression
  CallExpression
  ForExpression
  IfExpression
  IfLetExpression
  LoopExpression
  MatchExpression
  MatchArm
  TypePathExpression
  UnaryExpression
  WhileExpression

  IndexAccess
  MemberAccess

  Token
  ReturnStatement

  ListLiteral
  BooleanLiteral
  NumberLiteral
  ObjectLiteral
  StringLiteral
  TupleLiteral
}
import '../ast/visit.puck' as visit
import '../compiler/ast.ts' as {SyntaxKind}
import 'src/functions.puck' as {getTupleTypeName}
import 'src/range.puck' as {checkRange}
import 'src/scope.puck' as {createScope}
import 'src/structure_visitor.puck' as {declarePatternVariables, notAssignableError, structureVisitor}
import 'src/types.puck' as {createTypeInstance, getType, isAssignable, isSameType, resolveTypeParameters}
import '../entities.puck' as {
  Binding
  EnumType
  FunctionType
  Scope
  Struct
  TypeInstance
  isEnumType
  isObjectType
  isStruct
  isTrait
  isTupleType
  isTypeClass
  isTypeInstance
  isTypeParameter
}

export fn ScopeVisitor(context, file) {
  let mut importDirective: ImportDirective
  let mut matchExpression: Option<MatchExpression> = None
  let reportError = context.reportError.bind(context, file)

  fn getBinding(token: Expression) {
    if token.kind == SyntaxKind.Identifier
      then token.scope.getBinding(token.name)
    else if token.kind == SyntaxKind.MemberAccess
      then getBinding(token.object)
    else if token.kind == SyntaxKind.IndexAccess
      then getBinding(token.object)
  }

  fn checkFunctionCall(function: FunctionType, c: CallExpression) {
    if not function then return undefined
    let name = c.func.name or function.name

    if not function.arguments
      then reportError(c, '$name is not callable')

    if function.selfBinding and function.selfBinding.mutable {
      let binding = getBinding(c.func)
      if binding and not binding.mutable
        then reportError(c, '$name can only be called on a mutable binding')
    }

    if let Result::Err(error) = checkRange(c.argumentList, function.argumentRange, 'arguments', name)
      then reportError(c, error)

    let function =
      if isTypeClass(function) {
        let mut parameterMap = ObjectMapTrait.new()

        function.arguments.forEach(|parameter, i| {
          let argument =
            if i < c.argumentList.length
              then c.argumentList[i]
              else parameter

          if parameter.type_ and argument.type_ and
             isTypeParameter(parameter.type_) and not isTypeParameter(argument.type_) {
            if parameterMap[parameter.type_.name] {
              let existingMapping = parameterMap[parameter.type_.name]
              if not isAssignable(existingMapping, argument.type_) {
                if isAssignable(argument.type_, existingMapping) {
                  parameterMap[parameter.type_.name] = argument.type_
                }
                else reportError(argument, notAssignableError(existingMapping, argument.type_))
              }
            }
            else {
              parameterMap[parameter.type_.name] = argument.type_
            }
          }
        })
        resolveTypeParameters(parameterMap)(function)
      }
      else function

    c.argumentList.forEach(|argument, i| {
      let parameter = function.arguments[i]

      if not isAssignable(parameter.type_, argument.type_)
        then reportError(argument, notAssignableError(parameter.type_, argument.type_))

      if parameter.mutable and argument.kind == SyntaxKind.Identifier {
        let argumentName = argument.name
        let argumentBinding = argument.scope.getBinding(argumentName)

        if not argumentBinding.mutable {
          let parameterName =
            if parameter.pattern.kind == 'Identifier'
              then parameter.pattern.value[0].name
              else i
          reportError(argument
            'Parameter $parameterName of $name requires a mutable binding ' +
            'but $argumentName is declared as immutable.'
          )
        }
      }
    })

    return function
  }

  fn checkFunctionAssignability(to: FunctionType, subject: FunctionType, token) {
    checkRange(subject.arguments, to.argumentRange, reportError, 'arguments', subject.name, token)

    subject.arguments.forEach(|subjectArgument, i| {
      let toArgument = to.arguments[i]

      if not isAssignable(toArgument.type_, subjectArgument.type_)
        then reportError(
          token
          'Types of parameter #$i does not match. ' + subjectArgument.type_.name +
          ' is not assignable to ' + toArgument.type_.name
        )

      if subjectArgument.mutable and not toArgument.mutable
        then reportError(
          token
          'Parameter #$i is required to be immutable'
        )
    })

    if not isAssignable(to.returnType, subject.returnType)
      then reportError(
        token
        'Return type ' + subject.returnType.name + ' is not assignable to ' + to.returnType.name
      )
  }

  fn defineHoisted(expressions, visitor) {
    expressions.forEach(|mut e| {
      if e.kind == SyntaxKind.Function {
        e.hoisting = true
        visitor.visitFunctionDeclaration(e)
        e.hoisted = true
      }
      if e.kind == SyntaxKind.ExportDirective and
          e.expression.kind == SyntaxKind.Function {
        e.expression.hoisting = true
        visitor.visitFunctionDeclaration(e.expression)
        e.expression.hoisted = true
      }
    })
  }

  Object.assign({}, visit.walkingVisitor, structureVisitor, {
    reportError

    visitBlock: |self, mut b: Block| {
      b.scope = self.scope

      defineHoisted(b.expressions, self)

      visit.walkBlock(self, b)
    }
    visitFunctionDeclaration: |mut self, mut f: FunctionDeclaration| {
      structureVisitor.visitFunctionDeclaration.call(self, f)

      if not f.hoisting or f.hoisted {
        self.scope = f.scope

        f.parameterList.forEach(|p| self.visitVariableDeclaration(p))
        if f.body then self.visitBlock(f.body)

        self.scope = self.scope.parent
      }
    }
    visitIdentifier: |self, mut i: Identifier| {
      i.scope = self.scope
      let binding = i.scope.getBinding(i.name)
      if not binding
        then reportError(i, 'Use of undefined variable ' + i.name)
        else i.type_ = binding.type_
      visit.walkIdentifier(self, i)
    }
    visitImplDeclaration: |self, mut i: ImplDeclaration| {
      i.members.forEach(self.visitFunctionDeclaration.bind(self))
    }
    visitModule: |mut self, mut m: Module| {
      self.scope = m.scope

      defineHoisted(m.expressions, self)

      visit.walkModule(self, m)
    }
    visitObjectDestructure: |self, mut i: ObjectDestructure| {}
    visitTraitDeclaration: |mut self, mut t: TraitDeclaration| {
      self.scope = t.scope
      visit.walkTraitDeclaration(self, t)
      self.scope = self.scope.parent
    }
    visitTypeDeclaration: |self, mut t: TypeDeclaration| {}
    visitVariableDeclaration: |mut self, mut d: VariableDeclaration, visitInitializer, type_, allowNotExhaustive = false| {
      structureVisitor.visitVariableDeclaration.call(
        self
        d
        if visitInitializer
          then visitInitializer
          else |e| {
            let parentAssignedTo = self.assignedTo
            self.assignedTo = d
            self.visitExpression(e)
            self.assignedTo = parentAssignedTo
          }
        type_
        allowNotExhaustive
      )
    }

    visitExportDirective: |self, mut e: ExportDirective| {
      visit.walkExportDirective(self, e)
    }
    visitImportDirective: |self, mut i: ImportDirective| {}

    visitAssignmentExpression: |self, mut e: AssignmentExpression| {
      e.scope = self.scope
      visit.walkAssignmentExpression(self, e)
      let binding = getBinding(e.lhs)
      if binding {
        if not binding.mutable
          then reportError(e, "Can't assign to immutable variable " + binding.name)

        if not isAssignable(e.lhs.type_, e.rhs.type_)
          then reportError(e, notAssignableError(e.lhs.type_, e.rhs.type_))
      }

      e.type_ = e.lhs.type_ or e.rhs.type_
    }
    visitBinaryExpression: |self, mut e: BinaryExpression| {
      e.scope = self.scope
      visit.walkBinaryExpression(self, e)
    }
    visitCallExpression: |mut self, mut e: CallExpression| {
      e.scope = self.scope
      self.visitExpression(e.func)

      let mut functionType = e.func.type_

      if e.func.kind == SyntaxKind.MemberAccess and e.func.object.type_ {
        let name = e.func.member.name
        let objectType = e.func.object.type_
        let isDirectTraitCall = isTrait(objectType)

        if isTrait(objectType) {
          functionType = objectType.functions[name]

          if not functionType
            then reportError(e, objectType.name + ' has no function named $name')

          if functionType.selfBinding
            then throw 'direct trait calls for functions with self bindings are not implemented'
        }
        else if isStruct(objectType) {
          fn getImplementations(type_: Struct) {
            let implementations = type_.implementations
              .filter(|i| i.trait_.functions[name])

            let implementations =
              if implementations.length > 1
                then implementations
                  .filter(|i| e.scope.getTypeBinding(
                    if isTypeInstance(i.trait_)
                      then i.trait_.class.name
                      else i.trait_.name
                  ))
              else implementations

            let implementations =
              if implementations.length > 1
                then implementations
                  .map(|i| i.trait_.functions[name].argumentRange)
                  .filter(|range: Range| range.contains(e.argumentList.length))
              else implementations

            if implementations.length > 1 then reportError(e, 'Ambiguous trait call')

            if implementations.length == 0 and isTypeInstance(type_)
              then getImplementations(type_.class)
              else implementations
          }

          let implementations = getImplementations(objectType)

          if implementations.length == 1 {
            let implementation = implementations[0]
            let traitName =
              if isTypeInstance(implementation.trait_)
                then implementation.trait_.class.name
                else implementation.trait_.name
            if not e.scope.getTypeBinding(traitName)
              then reportError(e, 'The function $name is defined in trait $traitName but it is not in scope')

            e.traitName = traitName
            e.implementationType = implementation.type_

            functionType = implementation.trait_.functions[name]

            if objectType.parameterMap {
              functionType = resolveTypeParameters(objectType.parameterMap)(functionType)
            }
          }
        }
      }
      let parentAssignedTo = self.assignedTo
      e.argumentList.forEach(|a, i| {
        self.assignedTo = if functionType and functionType.arguments then functionType.arguments[i]
        self.visitExpression(a)
      })
      self.assignedTo = parentAssignedTo

      if functionType {
        functionType = checkFunctionCall(functionType, e)
        e.type_ = functionType.returnType
      }
    }
    visitForExpression: |mut self, mut e: ForExpression| {
      self.scope = createScope(context, file, self.scope)
      e.scope = self.scope
      visit.walkForExpression(self, e)
      self.scope = self.scope.parent
    }
    visitIfExpression: |mut self, mut e: IfExpression| {
      self.scope = createScope(context, file, self.scope)
      e.scope = self.scope
      visit.walkIfExpression(self, e)
      self.scope = self.scope.parent
    }
    visitIfLetExpression: |mut self, mut e: IfLetExpression| {
      self.scope = createScope(context, file, self.scope)
      e.scope = self.scope
      self.visitVariableDeclaration(e.variableDeclaration, undefined, undefined, true)
      self.visitBlock(e.then_)
      if let Option::Some(else_) = e.else_ then self.visitBlock(else_)
      self.scope = self.scope.parent
    }
    visitLoopExpression: |mut self, mut e: LoopExpression| {
      self.scope = createScope(context, file, self.scope)
      e.scope = self.scope
      visit.walkLoopExpression(self, e)
      self.scope = self.scope.parent
    }
    visitMatchExpression: |mut self, mut e: MatchExpression| {
      e.scope = self.scope
      let oldMatchExpression = matchExpression
      matchExpression = Some(e)

      self.visitExpression(e.expression)
      e.type_ = e.expression.type_

      e.patterns.forEach(|a| self.visitMatchArm(a))

      if let Result::Err(error) = checkExhaustive(e) {
        self.reportError(e, error)
      }

      matchExpression = oldMatchExpression
    }
    visitMatchArm: |mut self, mut a: MatchArm| {
      self.scope = createScope(context, file, self.scope)
      a.scope = self.scope

      let m = matchExpression.unwrap()

      let result: Result<(), ()> = declarePatternVariables(a.scope, self, a.pattern, false, m.type_, true)
      if result.isOk() {
        let patternTy = result.value[0]

        if not isAssignable(m.type_, patternTy)
          then self.reportError(a, notAssignableError(m.type_, patternTy))
      }
      else {
        if result.value[0].kind == 'PatternMismatch' {
          let (pattern, to, subject) = result.value[0].value
          self.reportError(a, notAssignableError(to, subject))
        }
      }

      self.visitBlock(a.block)

      self.scope = self.scope.parent
    }
    visitTypePathExpression: |self, mut e: TypePathExpression| {
      e.scope = self.scope
      let typePath = e.typePath
      if typePath.kind == '_Object' {
        let binding = e.scope.getTypeBinding(typePath.value[0].name)
        if not binding
          then self.reportError(e, 'Use of undeclared type ' + typePath.value[0].name)
        let type_ = binding.type_

        if typePath.value[1].kind != 'Member'
          then self.reportError(e, 'Nested type paths are not supported')
        let memberIdentifier = typePath.value[1].value[0]

        if isEnumType(type_) {
          let member = type_.members[memberIdentifier.name]
          if not member {
            reportError(memberIdentifier, type_.name + ' has no member named ' + memberIdentifier.name)
          }
          else if isObjectType(member) {
            e.type_ = {
              kind: 'Function'
              name: memberIdentifier.name
              parameterRange: type_.parameterRange
              typeParameters: type_.typeParameters
              instances: []
              arguments: [{
                name: memberIdentifier.name
                token: memberIdentifier
                mutable: false
                type_: member
                redefined: false
              }]
              argumentRange: {start: 1, end: 2}
              returnType: type_
              isAbstract: false
            }
          }
          else if isTupleType(member) {
            e.type_ = {
              kind: 'Function'
              name: memberIdentifier.name
              parameterRange: type_.parameterRange
              typeParameters: type_.typeParameters
              instances: []
              arguments: member.properties.map(|p, i| {{
                name: i.toString()
                token: memberIdentifier
                mutable: false
                type_: p
                redefined: false
              }})
              argumentRange: {start: member.properties.length, end: member.properties.length + 1}
              returnType: type_
              isAbstract: false
            }
          }
          else {
            e.type_ = {
              kind: type_.kind
              name: type_.name + '.' + member.name
              parameterRange: type_.parameterRange
              typeParameters: type_.typeParameters
              instances: []
            }
          }
        }
      }
    }
    visitUnaryExpression: |self, mut e: UnaryExpression| {
      e.scope = self.scope
      visit.walkUnaryExpression(self, e)

      e.type_ =
        if e.operator.kind == SyntaxKind.NotKeyword
          then e.scope.getTypeBinding('Bool').type_
        else if e.operator.kind == SyntaxKind.MinusToken
             or e.operator.kind == SyntaxKind.PlusToken
          then e.scope.getTypeBinding('Num').type_
    }
    visitWhileExpression: |mut self, mut e: WhileExpression| {
      self.scope = createScope(context, file, self.scope)
      e.scope = self.scope
      visit.walkWhileExpression(self, e)
      self.scope = self.scope.parent
    }
    visitIndexAccess: |self, mut a: IndexAccess| {
      a.scope = self.scope
      visit.walkIndexAccess(self, a)
    }
    visitMemberAccess: |self, mut a: MemberAccess| {
      a.scope = self.scope
      visit.walkExpression(self, a.object)
      if a.object.type_ {
        if isEnumType(a.object.type_) {
          // TODO: Enable this check when possible
          // reportError(a, 'can not read a property on an enum type')
        }
        else if isStruct(a.object.type_) {
          a.type_ = a.object.type_.properties[a.member.name]
        }
      }
    }

    visitBreak: |self, mut b: Token| {
      b.scope = self.scope
      visit.walkBreak(self, b)
    }
    visitReturn: |self, mut r: ReturnStatement| {
      r.scope = self.scope
      visit.walkReturn(self, r)
    }

    visitListLiteral: |self, mut l: ListLiteral| {
      l.scope = self.scope
      visit.walkListLiteral(self, l)
    }
    visitBooleanLiteral: |self, mut l: BooleanLiteral| {
      l.scope = self.scope
      l.type_ = self.scope.getTypeBinding('Bool').type_
      visit.walkBooleanLiteral(self, l)
    }
    visitNumberLiteral: |self, mut l: NumberLiteral| {
      l.scope = self.scope
      l.type_ = self.scope.getTypeBinding('Num').type_
      visit.walkNumberLiteral(self, l)
    }
    visitObjectLiteral: |self, mut l: ObjectLiteral| {
      l.scope = self.scope
      l.members.forEach(|m| {
        self.visitExpression(m.value)
      })
    }
    visitStringLiteral: |self, mut l: StringLiteral| {
      l.scope = self.scope
      l.type_ = self.scope.getTypeBinding('String').type_
      visit.walkStringLiteral(self, l)
    }
    visitTupleLiteral: |self, mut l: TupleLiteral| {
      l.scope = self.scope
      visit.walkTupleLiteral(self, l)
      let properties = l.expressions.map(|e| e.type_)
      l.type_ = {
        kind: 'Tuple'
        name: getTupleTypeName(properties)
        properties
      }
    }
  })
}

fn isIndividuallyExhaustive(p: Pattern) {
  match p {
    Pattern::CatchAll => true
    Pattern::Identifier(_) => true
    Pattern::Record(record) => record.properties.every(|p| isIndividuallyExhaustive(p.pattern))
    Pattern::RecordType(_, record) => record.properties.every(|p| isIndividuallyExhaustive(p.pattern))
    Pattern::Tuple(tuple) => tuple.properties.every(isIndividuallyExhaustive)
    Pattern::TupleType(_, tuple) => tuple.properties.every(isIndividuallyExhaustive)
    Pattern::UnitType(_) => true
  }
}

fn getEnumMember(typePath: TypePath) {
  match typePath {
    TypePath::Object(_, typePath) => match typePath {
      TypePath::Member(member) => member.name
      _ => throw 'Invalid typepath'
    }
    _ => throw 'Invalid typepath'
  }
}

fn isEnumPattern(p: Pattern) {
  match p {
    Pattern::CatchAll => false
    Pattern::Identifier(_) => false
    Pattern::Record(record) => false
    Pattern::RecordType(_, record) => true
    Pattern::Tuple(tuple) => false
    Pattern::TupleType(_, tuple) => true
    Pattern::UnitType(_) => true
  }
}

fn isEnumArm(p: Pattern) {
  match p {
    Pattern::CatchAll => false
    Pattern::Identifier(_) => false
    Pattern::Record(record) => false
    Pattern::RecordType(_, record) => record.properties.some(|p| isEnumPattern(p.pattern))
    Pattern::Tuple(tuple) => false
    Pattern::TupleType(_, tuple) => tuple.properties.some(isEnumPattern)
    Pattern::UnitType(_) => false
  }
}

fn checkExhaustive(e: MatchExpression) -> Result<(), String> {
  if isEnumType(e.type_) {
    checkExhaustiveEnum(e.patterns.map(|a| a.pattern), e.type_)
  }
  else Ok(())
}

fn getSubPatterns(pattern: Pattern) -> List<Pattern> {
  match pattern {
    Pattern::RecordType(_, record) => record.properties.map(|p| p.pattern)
    Pattern::TupleType(_, tuple) => tuple.properties
    _ => []
  }
}

fn checkExhaustiveEnum(patterns: List<Pattern>, enum_: EnumType) -> Result<(), String> {
  let typeName = enum_.name
  let mut exhaustiveMap = ObjectMapTrait.new()
  let mut enumArmsMap = ObjectMapTrait.new()

  if let Option::Some(_) = patterns.find(|pattern| {
    let member = match pattern {
      Pattern::CatchAll => return true
      Pattern::Identifier(_) => return true
      Pattern::Record(_) => throw 'Invalid pattern'
      Pattern::RecordType(typePath, _) => getEnumMember(typePath)
      Pattern::Tuple(_) => throw 'Invalid pattern'
      Pattern::TupleType(typePath, _) => getEnumMember(typePath)
      Pattern::UnitType(typePath) => getEnumMember(typePath)
    }

    if not exhaustiveMap[member] {
      let individuallyExhaustive = isIndividuallyExhaustive(pattern)
      let isEnum = isEnumArm(pattern)

      exhaustiveMap[member] = individuallyExhaustive and not isEnum

      if isEnum {
        if not enumArmsMap[member] {
          enumArmsMap[member] = []
        }
        enumArmsMap[member].push(pattern)
      }
    }

    false
  })
    then return Ok(())

  let mut innerErrors = []
  enumArmsMap.forEach(|(member, patterns)| {
    let enumPatterns = getSubPatterns(patterns[0])
      .enumerate()
      .filter(|(pattern, _)| isEnumPattern(pattern))
      .map(|(pattern, index)| {
        let p: Pattern = pattern
        let {type_} = match p {
          Pattern::RecordType(typePath, _) => typePath
          Pattern::TupleType(typePath, _) => typePath
          Pattern::UnitType(typePath) => typePath
          _ => throw 'Invalid pattern6'
        }

        let subPatterns = patterns
          .map(getSubPatterns)
          .map(|subPatterns| subPatterns[index]);

        (type_, subPatterns)
      })

    let errors = enumPatterns
      .map(|(type_, subPatterns)| checkExhaustiveEnum(subPatterns, type_))
      .filter(|result: Result<(), String>| result.isErr())

    innerErrors = innerErrors.concat(errors)

    exhaustiveMap[member] = errors.length == 0
  })

  if (innerErrors.length > 0) {
    return innerErrors[0]
  }

  let mapSize = exhaustiveMap.size()
  let memberCount = enum_.members.size()

  if mapSize == memberCount - 1 {
    let mut (missing, _) = enum_.members.find(|(member, _)| not exhaustiveMap[member]).unwrap()
    return Err('Match is not exhaustive. It is missing a case for $typeName::$missing')
  }
  else if mapSize < memberCount {
    return Err('Match is not exhaustive.')
  }
  else if let Option::Some((member, a)) = exhaustiveMap.find(|(_, exhaustive)| not exhaustive) {
    return Err('Match is not exhaustive. $typeName::$member is not exhaustive. $a')
  }

  Ok(())
}
