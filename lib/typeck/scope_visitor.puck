import 'puck:core' as core
import 'puck:js' as {Object, global, undefined}
import 'node:util' as {inspect}
import '../ast/ast.puck' as {
  Module
  TopLevelStatement
  BlockLevelStatement
  Expression

  EnumDeclaration
  EnumMember
  ImplDeclaration
  ImplShorthandDeclaration
  TraitDeclaration
  TypeDeclaration

  ExportDirective
  ExportedStatement
  ImportDirective
  ObjectDestructure

  Block
  BreakStatement
  ReturnStatement
  WhileLoop

  Identifier
  FunctionDeclaration
  VariableDeclaration

  AssignmentExpression
  BinaryExpression
  CallExpression
  IfExpression
  IfLetExpression
  MatchExpression
  MatchArm
  TypePathExpression
  TypePath
  UnaryExpression

  IndexAccess
  MemberAccess

  BooleanLiteral
  ListLiteral
  NumberLiteral
  RecordLiteral
  StringLiteral
  TupleLiteral

  Pattern
  RecordPattern
  TuplePattern

  TypeBound
  FunctionTypeBound
  NamedTypeBound
  RecordTypeBound
  RecordTypeBoundMember
  TupleTypeBound
  TypeParameter
}
import '../ast/span.puck' as {ToSpan}
import '../ast/token.puck' as {SyntaxKind}
import '../ast/visit.puck' as visit
import 'src/enums.puck' as {checkExhaustive}
import 'src/functions.puck' as {resolveFunctionTypeParameters}
import 'src/impls.puck' as {getImplementation}
import 'src/patterns.puck' as {PatternError, declarePatternVariables}
import 'src/range.puck' as {checkRange}
import 'src/scope.puck' as {Binding, Scope}
import 'src/structure_visitor.puck' as {notAssignableError, structureVisitor}
import 'src/type_function.puck' as {enumMemberToFunction}
import 'src/types.puck' as {
  createTypeInstance
  findCommonType
  isAssignable
  isSameType
  resolveTypeParameters
}
import '../entities.puck' as {
  Function
  Implementation
  Struct
  StructKind
  Type
  TypeInstance
  TypeKind
}

fn asType(a) -> Type {a}
fn asIterable<E>(a: List<E>) -> Iterable<E> {a}

export fn ScopeVisitor(context, file) {
  let mut importDirective: ImportDirective
  let mut matchExpression: Option<MatchExpression> = None
  let reportError: (ToSpan, String) -> () = context.reportError.bind(context, file)

  fn getBinding(e: Expression) -> Option<Binding> {
    match e {
      Expression::Identifier(i) => {
        let scope: Scope = i.scope
        scope.getBinding(i.name)
      }
      Expression::IndexAccess(i) => getBinding(i.object)
      Expression::MemberAccess(i) => getBinding(i.object)
      _ => None
    }
  }

  fn checkFunctionCall(mut functionType: Type, c: CallExpression) {
    if not functionType then return undefined
    let namei: Option<String> =
      match c.func {
        Expression::Identifier(i) => Some(i.name)
        _ => None
      }
    let name = namei.unwrapOrElse(|| functionType.displayName())

    let function = match functionType.kind {
      TypeKind::Function(func) => func
      _ => {
        reportError(c, '$name is not callable')
        return undefined
      }
    }

    if let Option::Some(selfBinding) = function.selfBinding {
      if selfBinding.mutable {
        if not getBinding(c.func).mapOr(true, |binding| binding.mutable)
          then reportError(c, '$name can only be called on a mutable binding')
      }
    }

    if let Result::Err(error) = checkRange(c.argumentList, function.parameterRange, 'arguments', name) {
      reportError(c, error)
      return function
    }

    c.argumentList.enumerate().forEach(|(argument, i): (Expression, Num)| {
      let parameter = function.parameters.get(i).unwrap()
      let parameterName = parameter.name
      let pType: Type = parameter.type_

      if not isAssignable(parameter.type_, argument.getType())
        then reportError(argument
          notAssignableError(parameter.type_, argument.getType()) +
          ' in parameter $parameterName of function $name'
        )

      if parameter.mutable {
        if let Option::Some(argumentBinding) = getBinding(argument) {
          let argumentName = argumentBinding.name

          if not argumentBinding.mutable {
            reportError(argument
              'Parameter $parameterName of function $name requires a mutable binding ' +
              'but $argumentName is declared as immutable.'
            )
          }
        }
      }
    })

    function
  }

  let structureVisitorInstance = structureVisitor(reportError)
  Object.assign({}, visit.walkingVisitor, structureVisitorInstance, {
    reportError

    visitModule: |mut self, mut m: Module| {
      self.scope = m.scope

      // Hoist function declarations
      m.statements.forEach(|s| match s {
        TopLevelStatement::ExportDirective(
          {statement: ExportedStatement::FunctionDeclaration(f)}
        ) => {
          self.visitFunctionDeclaration(f, true)
        }
        TopLevelStatement::BlockLevelStatement(
          BlockLevelStatement::Expression(Expression::FunctionDeclaration(f))
        ) => {
          self.visitFunctionDeclaration(f, true)
        }
        _ => {}
      })

      m.statements.forEach(|s| {
        self.isUsed = false
        self.visitTopLevelStatement(s)
      })
    }
    visitExpression: |mut self, e: Expression| {
      self.isUsed = true
      visit.walkingVisitor.visitExpression.call(self, e)
    }

    visitImplDeclaration: |self, mut i: ImplDeclaration| {
      i.members.forEach(|f| self.visitFunctionDeclaration(f))
    }
    visitImplShorthandDeclaration: |self, mut i: ImplShorthandDeclaration| {
      i.members.forEach(|f| self.visitFunctionDeclaration(f))
    }
    visitTraitDeclaration: |mut self, mut t: TraitDeclaration| {
      let parentScope = self.scope
      self.scope = t.scope
      visit.walkTraitDeclaration(self, t)
      self.scope = parentScope
    }
    visitTypeDeclaration: |self, mut t: TypeDeclaration| {}

    visitExportDirective: |self, mut e: ExportDirective| {
      visit.walkExportDirective(self, e)
    }
    visitImportDirective: |self, mut i: ImportDirective| {}
    visitObjectDestructure: |self, mut i: ObjectDestructure| {}

    visitBlock: |mut self, mut b: Block, isUsed = true| {
      b.scope = self.scope

      // Hoist function declarations
      b.statements.forEach(|s| match s {
        BlockLevelStatement::Expression(Expression::FunctionDeclaration(f)) => {
          self.visitFunctionDeclaration(f, true)
        }
        _ => {}
      })

      let lastIndex = b.statements.size() - 1
      b.statements.enumerate().forEach(|(s, index)| {
        self.isUsed = isUsed and index == lastIndex
        self.visitBlockLevelStatement(s)
      })

      b.type_ =
        if let Option::Some(last) = b.statements.last()
          then last.getType()
          else Type.empty()
    }
    visitBreak: |self, mut b: BreakStatement| {
      b.scope = self.scope
    }
    visitReturn: |mut self, mut r: ReturnStatement| {
      visit.walkReturn(self, r)
      if let Some(returnType) = self.functionContext.returnType {
        if not isAssignable(returnType, r.expression.getType())
          then reportError(r.expression, notAssignableError(returnType, r.expression.getType()))
      }
      else if r.expression.getType() {
        self.functionContext.returnTypes.push(r.expression.getType())
      }
    }
    visitWhileLoop: |mut self, mut e: WhileLoop| {
      let parentScope: Scope = self.scope
      self.scope = parentScope.createChild()
      e.scope = self.scope
      self.visitExpression(e.condition)
      self.visitBlock(e.body, false)
      e.type_ = Type.empty()
      self.scope = parentScope
    }

    visitIdentifier: |self, mut i: Identifier| {
      let scope: Scope = self.scope
      i.scope = self.scope
      if let Option::Some(binding) = scope.getBinding(i.name) {
        let mut b = binding
        i.binding = binding
        i.type_ =
          if binding.type_ and binding.type_.providesType.isSome()
            then enumMemberToFunction(b.type_)
            else binding.type_
      }
      else reportError(i, 'Use of undefined variable ' + i.name)
      visit.walkIdentifier(self, i)
    }
    visitFunctionDeclaration: |mut self, mut f: FunctionDeclaration, isHoisting = false| {
      structureVisitorInstance.visitFunctionDeclaration.call(self, f)

      if not isHoisting {
        let selfScope = self.scope
        self.scope = f.scope

        f.parameterList.forEach(|p| self.visitVariableDeclaration(p))
        if let Option::Some(body) = f.body {
          let parentAssignedTo = self.assignedTo
          let parentContext = self.functionContext
          let mut isUsed = true
          self.functionContext = {
            returnType: None
            returnTypes: []
          }
          if let TypeKind::Function(func) = f.type_.kind {
            self.assignedTo = func.returnType
            if func.returnType {
              self.functionContext.returnType = Some(func.returnType)

              if func.returnType.isEmpty() {
                isUsed = false
              }
            }
          }
          self.visitBlock(body, isUsed)
          if let Option::None = self.functionContext {
          }

          if let TypeKind::Function(func) = f.type_.kind {
            if func.returnType {
              if not isAssignable(func.returnType, body.type_) and not func.returnType.isEmpty()
                then reportError(f, notAssignableError(func.returnType, body.type_))
            }
            else {
              let mut types: List<Type> = self.functionContext.returnTypes
              if body.type_ {
                types.push(body.type_)
              }

              if types.isNotEmpty() {
                match findCommonType(types) {
                  Result::Ok(type_) => {
                    Object.assign(func, {
                      returnType: body.type_
                    })
                  }
                  Result::Err(_) => reportError(f,
                    'No best common type exists among return expressions. Found ' + types.map(|type_| type_.displayName()).join(', ')
                  )
                }
              }
            }
          }

          self.assignedTo = parentAssignedTo
          self.functionContext = parentContext
        }

        self.scope = selfScope
      }
    }
    visitVariableDeclaration: |mut self, mut d: VariableDeclaration, visitInitializer, type_, allowNotExhaustive = false| {
      structureVisitorInstance.visitVariableDeclaration.call(
        self
        d
        if visitInitializer
          then visitInitializer
          else |e| {
            let parentAssignedTo = self.assignedTo
            self.assignedTo = d.type_
            self.isUsed = true
            self.visitExpression(e)
            self.assignedTo = parentAssignedTo
          }
        type_
        allowNotExhaustive
      )
    }

    visitAssignmentExpression: |self, mut e: AssignmentExpression| {
      e.scope = self.scope
      visit.walkAssignmentExpression(self, e)
      if let Option::Some(binding) = getBinding(e.lhs) {
        if not binding.mutable
          then reportError(e, "Can't assign to immutable variable " + binding.name)

        if not isAssignable(e.lhs.getType(), e.rhs.getType())
          then reportError(e, notAssignableError(e.lhs.getType(), e.rhs.getType()))
      }

      e.type_ = e.lhs.getType() or e.rhs.getType()
    }
    visitBinaryExpression: |self, mut e: BinaryExpression| {
      e.scope = self.scope
      visit.walkBinaryExpression(self, e)
    }
    visitCallExpression: |mut self, mut e: CallExpression| {
      e.scope = self.scope
      let scope: Scope = e.scope
      self.visitExpression(e.func)

      let mut functionType = e.func.getType()

      if let Expression::MemberAccess(access) = e.func {
        if access.object.getType() {
          let name = access.member.name
          let objectType: Type = access.object.getType()

          // If the call is directly on the type, for example Num.parse()
          if let Option::Some(providesType) = objectType.providesType {
            match providesType.kind {
              TypeKind::Enum(enum_) => {
                functionType = enum_.implementations
                  .find(|{trait_}| trait_.getTrait().isShorthand)
                  .map(|{trait_}| {
                    trait_.getTrait().functions[name]
                  })
                  .unwrapOr(undefined)
              }
              TypeKind::Struct(struct) => {
                functionType = struct.implementations
                  .find(|{trait_}| trait_.getTrait().isShorthand)
                  .map(|{trait_}| {
                    trait_.getTrait().functions[name]
                  })
                  .unwrapOr(undefined)
              }
              TypeKind::Trait(trait_) => {
                functionType = trait_.functions[name]
              }
              _ => {}
            }

            if functionType {
              let function = functionType.getFunction()

              if function.selfBinding.isSome() {
                reportError(e, providesType.displayName() + '::$name takes a self parameter and can\'t be called directly')
              }
              else {
                e.traitName = scope.getBindingByTypeId(providesType.id.unwrap()).unwrap().name
                e.isTraitObject =  true
              }
            }
            else reportError(e, providesType.displayName() + ' has no function named $name')
          }
          // It is a normal trait call, for example 'hello'.toUpperCase()
          else {
            if let TypeKind::Trait(trait_) = objectType.kind {
              functionType = trait_.functions[name]

              if functionType {
                let function = functionType.getFunction()

                if function.selfBinding.isSome() {
                  if let Some(binding) = scope.getBindingByTypeId(objectType.id.unwrap()) {
                    e.traitName = binding.name
                    e.isTraitObject =  true
                  }
                  else {
                    let typeName = objectType.name.unwrap()
                    reportError(e, 'The function $name is defined in trait $typeName but it is not in scope')
                  }
                }
              }
            }
            else if let Option::Some(implementation) = getImplementation(name, objectType, e, reportError) {
              let trait_: Type =
                if let Option::Some(instance) = implementation.trait_.instance
                  then instance.class
                  else implementation.trait_

              if let Some(binding) = scope.getBindingByTypeId(trait_.id.unwrap()) {
                e.traitName = binding.name
                e.isShorthand =  trait_.getTrait().isShorthand
                e.implementation = implementation

                functionType = asType(implementation.trait_).getTrait().functions[name]
              }
              else {
                let traitName = trait_.name.unwrap()
                let id = trait_.id.unwrap()
                reportError(e, 'The function $name is defined in trait $traitName but it is not in scope')
              }
            }

            if e.traitName {
              if let Option::Some(instance) = objectType.instance {
                functionType = resolveTypeParameters(instance.parameterMap)(functionType)
              }
            }
          }
        }
      }

      let mut parentAssignedTo
      if functionType and functionType.isFunction() {
        let callTypeParameters = functionType.class.map(|class| class.typeParameters).unwrapOr([])
        let mut callParameterMap: ObjectMap<Type> = ObjectMap.new()
        let parentAssignedTo = self.assignedTo
        let functionKind = functionType.getFunction()
        e.argumentList.enumerate()
          // If too many arguments are passed e.argumentList will be longer than functionKind.parameters
          .take(functionKind.parameters.size())
          .forEach(|(a, i): (Expression, Num)| {
            let parameter = functionKind.parameters[i]
            self.assignedTo = parameter.type_
            self.visitExpression(a)
            if callTypeParameters.isNotEmpty() and parameter.type_ and a.getType() {
              resolveFunctionTypeParameters(
                callParameterMap
                callTypeParameters
                parameter.type_
                a.getType()
              )
            }
          })
        if callTypeParameters.isNotEmpty() {
          functionType = resolveTypeParameters(callParameterMap)(functionType)
        }
        self.assignedTo = parentAssignedTo
      } else {
        let parentAssignedTo = self.assignedTo
        self.assignedTo = undefined
        e.argumentList.forEach(|a| self.visitExpression(a))
        self.assignedTo = parentAssignedTo
      }
      if functionType {
        e.functionType = functionType
        let function = checkFunctionCall(functionType, e)
        if function {
          e.type_ = function.returnType
        }
      }
    }
    visitIfExpression: |mut self, mut e: IfExpression| {
      let parentScope: Scope = self.scope
      e.scope = self.scope
      let isUsed = self.isUsed
      self.visitExpression(e.condition)
      self.scope = parentScope.createChild()
      self.visitBlock(e.then_, isUsed and e.else_.isSome())
      if let Option::Some(else_) = e.else_ {
        self.scope = parentScope.createChild()
        self.visitBlock(else_, isUsed)
      }
      if isUsed {
        e.type_ =
          if let Option::Some(else_) = e.else_ {
            match  findCommonType([e.then_.type_, else_.type_]) {
              Result::Ok(type_) => type_
              Result::Err(_) => {
                reportError(e
                  'Type ' + e.then_.type_.displayName() + ' and ' + asType(else_.type_).displayName() + ' is not compatible'
                )
                Type.empty()
              }
            }
          }
          else Type.empty()
      }
      self.scope = parentScope
    }
    visitIfLetExpression: |mut self, mut e: IfLetExpression| {
      let parentScope: Scope = self.scope
      e.scope = self.scope
      self.scope = parentScope.createChild()
      let isUsed = self.isUsed
      self.visitPattern(e.pattern)
      self.visitExpression(e.expression)
      match declarePatternVariables(self.scope, self, e.pattern, false, e.expression.getType(), true) {
        Result::Ok(_) => {}
        Result::Err(PatternError::PatternMismatch(pattern, to, subject)) => {
          reportError(e.expression, notAssignableError(to, subject))
        }
        Result::Err(PatternError::ScopeError(token, err)) => reportError(token, err)
        Result::Err(PatternError::NotExhaustive) => {
          // Allowed in if let expressions
        }
      }
      let expressionScope: Scope = self.scope
      self.scope = expressionScope.createChild()
      self.visitBlock(e.then_, isUsed)
      if let Option::Some(else_) = e.else_ {
        self.scope = expressionScope.createChild()
        self.visitBlock(else_, isUsed)
      }
      if isUsed {
        e.type_ =
          if let Option::Some(else_) = e.else_ {
            match findCommonType([e.then_.type_, else_.type_]) {
              Result::Ok(type_) => type_
              Result::Err(_) => {
                reportError(e
                  'Type ' + e.then_.type_.displayName() + ' and ' + asType(else_.type_).displayName() + ' is not compatible'
                )
                Type.empty()
              }
            }
          }
          else Type.empty()
      }
      self.scope = parentScope
    }
    visitMatchExpression: |mut self, mut e: MatchExpression| {
      e.scope = self.scope
      let oldMatchExpression = matchExpression
      matchExpression = Some(e)

      let isUsed = self.isUsed

      self.visitExpression(e.expression)

      e.patterns.forEach(|a| self.visitMatchArm(a, isUsed))

      if let Result::Err(error) = checkExhaustive(e) {
        reportError(e, error)
      }
      if isUsed {
        e.type_ =
          if e.patterns.isNotEmpty() {
            match findCommonType(e.patterns.map(|arm| arm.type_).toList()) {
              Result::Ok(type_) => type_
              Result::Err(_) => {
                reportError(e
                  'Match arms return mixed types ' + e.patterns.map(|arm| asType(arm.type_).displayName()).join(', ')
                )
                Type.empty()
              }
            }
          }
          else Type.empty()
      }

      matchExpression = oldMatchExpression
    }
    visitMatchArm: |mut self, mut a: MatchArm, isUsed| {
      let parentScope: Scope = self.scope
      self.scope = parentScope.createChild()
      a.scope = self.scope

      let m = matchExpression.unwrap()

      self.visitPattern(a.pattern)
      match declarePatternVariables(a.scope, self, a.pattern, false, m.expression.getType(), true) {
        Result::Ok(_) => {}
        Result::Err(PatternError::PatternMismatch(pattern, to, subject)) => {
          reportError(a, notAssignableError(to, subject))
        }
        Result::Err(PatternError::ScopeError(token, err)) => reportError(token, err)
        Result::Err(PatternError::NotExhaustive) => {
          // Allowed in match expressions
        }
      }

      self.visitBlock(a.block, isUsed)
      a.type_ = a.block.type_

      self.scope = parentScope
    }
    visitTypePathExpression: |self, mut e: TypePathExpression| {
      e.scope = self.scope
      let typePath = e.typePath
      self.visitTypePath(e.typePath)
      let mut type_: Type = e.typePath.type_
      if type_ {
        e.type_ = enumMemberToFunction(type_)
      }
    }
    visitUnaryExpression: |self, mut e: UnaryExpression| {
      let scope: Scope = self.scope
      e.scope = self.scope
      visit.walkUnaryExpression(self, e)

      match e.operator.kind {
        SyntaxKind::NotKeyword => {
          if let Some(binding) = scope.getBindingByTypeId('Bool') {
            e.type_ = binding.type_.providesType.unwrap()
          }
          else reportError(e
            'puck:core::Bool is not in scope. Please import Bool from puck:core to use boolean literals.'
          )
        }
        SyntaxKind::MinusToken => {
          if let Some(binding) = scope.getBindingByTypeId('Num') {
            e.type_ = binding.type_.providesType.unwrap()
          }
          else reportError(e
            'puck:core::Num is not in scope. Please import Num from puck:core to use number literals.'
          )
        }
        SyntaxKind::PlusToken => {
          if let Some(binding) = scope.getBindingByTypeId('Num') {
            e.type_ = binding.type_.providesType.unwrap()
          }
          else reportError(e
            'puck:core::Num is not in scope. Please import Num from puck:core to use number literals.'
          )
        }
        _ => {}
      }
      ()
    }

    visitIndexAccess: |self, mut a: IndexAccess| {
      a.scope = self.scope
      visit.walkIndexAccess(self, a)
    }
    visitMemberAccess: |self, mut a: MemberAccess| {
      a.scope = self.scope
      visit.walkExpression(self, a.object)
      if a.object.getType() {
        if let TypeKind::Struct({kind: StructKind::Record(record)}) = a.object.getType().kind {
          a.type_ = record.properties[a.member.name]
        } else {
          // TODO: Enable this check when possible
          // reportError(a, 'can not read a property on an enum type')
        }
      }
    }

    visitBooleanLiteral: |self, mut l: BooleanLiteral| {
      let scope: Scope = self.scope
      l.scope = self.scope
      if let Some(binding) = scope.getBindingByTypeId('Bool') {
        l.type_ = binding.type_.providesType.unwrap()
      }
      else reportError(l
        'puck:core::Bool is not in scope. Please import Bool from puck:core to use boolean literals.'
      )
      visit.walkBooleanLiteral(self, l)
    }
    visitListLiteral: |self, mut l: ListLiteral| {
      let scope: Scope = self.scope
      let mut listType =
        if let Some(binding) = scope.getBindingByTypeId('List') {
          binding.type_.providesType.unwrap()
        }
        else return reportError(l
          'puck:core::List is not in scope. Please import List from puck:core to use list literals.'
        )
      l.scope = self.scope
      visit.walkListLiteral(self, l)
      if l.members.length >= 1 {
        let types = l.members.map(|m| m.getType()).toList()
        let result: Result<Type, ()> = findCommonType(types)
        match result {
          Result::Ok(type_) => {
            if not type_ {
              l.type_ = listType
            } else {
              l.type_ = createTypeInstance(listType, asIterable([type_]))
            }
          }
          Result::Err(_) => reportError(l, 'List contains mixed types')
        }
      }
      else {
        l.type_ = listType
      }
      ()
    }
    visitNumberLiteral: |self, mut l: NumberLiteral| {
      let scope: Scope = self.scope
      if let Some(binding) = scope.getBindingByTypeId('Num') {
        l.type_ = binding.type_.providesType.unwrap()
        ()
      }
      else reportError(l
        'puck:core::Num is not in scope. Please import Num from puck:core to use number literals.'
      )
    }
    visitRecordLiteral: |self, mut l: RecordLiteral| {
      l.scope = self.scope
      l.members.forEach(|m| {
        self.visitExpression(m.value)
      })
      l.type_ = Type({
        id: None
        displayName: None
        name: None
        kind: TypeKind::Struct({
          implementations: []
          kind: StructKind::Record({
            properties: ObjectMap.fromIter(l.members.map(|m| {
              (m.name.name, m.value.getType())
            }))
          })
        })
        class: None
        instance: None
        providesType: None
        enumMember: None
        complete: true
      })
    }
    visitStringLiteral: |self, mut l: StringLiteral| {
      let scope: Scope = self.scope
      l.scope = self.scope
      if let Some(binding) = scope.getBindingByTypeId('String') {
        l.type_ = binding.type_.providesType.unwrap()
      }
      else reportError(l
        'puck:core::String is not in scope. Please import String from puck:core to use string literals.'
      )
      visit.walkStringLiteral(self, l)
    }
    visitTupleLiteral: |self, mut l: TupleLiteral| {
      l.scope = self.scope
      visit.walkTupleLiteral(self, l)
      l.type_ = Type({
        id: None
        displayName: None
        name: None
        kind: TypeKind::Struct({
          implementations: []
          kind: StructKind::Tuple({
            properties: l.expressions.map(|e| e.getType()).toList()
          })
        })
        class: None
        instance: None
        providesType: None
        enumMember: None
        complete: true
      })
    }

    visitPattern: |self, mut p: Pattern| {
      p.scope = self.scope
      visit.walkPattern(self, p)
      p.type_ =
        match p {
          Pattern::CatchAll => Type.unused()
          Pattern::Identifier(identifier) => undefined
          Pattern::Record(record) => record.type_
          Pattern::RecordType(typePath, record) => {
            let type_: Type = typePath.providesType
            if not isAssignable(record.type_, type_)
              then reportError(p, type_.displayName() + ' is not assignable to pattern ' + record.displayName())
            type_.enumMember.mapOr(type_, |(_, enum_)| enum_)
          }
          Pattern::Tuple(tuple) => tuple.type_
          Pattern::TupleType(typePath, tuple) => {
            let type_: Type = typePath.providesType
            if not isAssignable(tuple.type_, type_)
              then reportError(p, type_.displayName() + ' is not assignable to pattern ' + tuple.displayName())
            type_.enumMember.mapOr(type_, |(_, enum_)| enum_)
          }
          Pattern::UnitType(typePath) => undefined
        }
    }

    visitRecordPattern: |self, mut p: RecordPattern| {
      p.scope = self.scope
      visit.walkRecordPattern(self, p)
      p.type_ = Type({
        id: None
        displayName: None
        name: None
        kind: TypeKind::Struct({
          implementations: []
          kind: StructKind::Record({properties: ObjectMap.fromIter(
            p.properties.map(|p| (p.property.name, p.pattern.type_))
          )})
        })
        instance: None
        class: None
        providesType: None
        enumMember: None
        complete: true
      })
    }
    visitTuplePattern: |self, mut p: TuplePattern| {
      p.scope = self.scope
      visit.walkTuplePattern(self, p)
      p.type_ = Type({
        id: None
        displayName: None
        name: None
        kind: TypeKind::Struct({
          implementations: []
          kind: StructKind::Tuple({properties: p.properties.map(|p| p.type_).toList()})
        })
        instance: None
        class: None
        providesType: None
        enumMember: None
        complete: true
      })
    }
  })
}
