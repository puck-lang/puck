import 'puck:core' as core
import 'puck:js' as {Object, global, undefined}
import 'node:util' as {inspect}
import '../ast/ast.puck' as {
  Module
  TopLevelStatement
  BlockLevelStatement
  Expression

  EnumDeclaration
  EnumMember
  ImplDeclaration
  ImplShorthandDeclaration
  TraitDeclaration
  TypeDeclaration

  ExportDirective
  ExportedStatement
  ImportDirective
  ObjectDestructure

  Block
  BreakStatement
  ReturnStatement
  ForLoop
  WhileLoop

  Identifier
  FunctionDeclaration
  VariableDeclaration

  AssignmentExpression
  BinaryExpression
  CallExpression
  IfExpression
  IfLetExpression
  MatchExpression
  MatchArm
  TypePathExpression
  TypePath
  UnaryExpression

  IndexAccess
  MemberAccess
  TupleIndexAccess
  UnknownAccess
  UnknownIndexAccess

  BooleanLiteral
  ListLiteral
  NumberLiteral
  RangeLiteral
  RecordLiteral
  RecordLiteralMember
  StringLiteral
  TupleLiteral

  Pattern
  RecordPattern
  TuplePattern

  TypeBound
  FunctionTypeBound
  NamedTypeBound
  RecordTypeBound
  RecordTypeBoundMember
  TupleTypeBound
  TypeParameter
}
import '../ast/span.puck' as {Span, ToSpan}
import '../compiler.puck' as {CompilerContext}
import '../ast/token.puck' as {SyntaxKind}
import '../ast/visit.puck' as visit
import 'src/enums.puck' as {checkExhaustive}
import 'src/functions.puck' as {
  checkFunctionCall
  resolveFunctionTypeParameters
  resolveFunctionTypeParametersByReturnValue
}
import 'src/impls.puck' as {getImplementation, getImplementationForTrait, getImplementationForTraitCall, resolveImplTypeParameters}
import 'src/patterns.puck' as {PatternError, declarePatternVariables}
import 'src/range.puck' as {checkRange}
import 'src/scope.puck' as {Binding, Scope}
import 'src/structure_visitor.puck' as {notAssignableError, structureVisitor}
import 'src/type_function.puck' as {enumMemberToFunction}
import 'src/types.puck' as {
  createTypeInstance
  findCommonType
  isAssignable
  isSameType
  resolveTypeParameters
}
import '../entities.puck' as {
  CompilationError
  RecordMember
  File
  Definition
  Function
  Implementation
  Struct
  StructKind
  Type
  TypeInstance
  TypeKind
}
import 'src/core_type_helpers.puck' as {getCoreType, getRecordPropType}

fn asType(a: Unknown) -> Type {a.transmute()}

export fn getBinding(e: Expression) -> Option<Binding> {
  match e {
    Expression::Identifier(i) => {
      let scope: Scope = i->scope.transmute()
      scope.getBinding(i.name)
    }
    Expression::IndexAccess(i) => getBinding(i.object)
    Expression::MemberAccess(i) => getBinding(i.object)
    _ => None
  }
}

fn asTraitCall(visitor, mut e: BinaryExpression, trait_: String, method: String, desription: String) -> Result<(), String> {
  match getCoreType(visitor.scope, trait_, desription) {
    Ok((_, binding)) => {
      let mut call = CallExpression({
        func: Expression::MemberAccess({
          object: Expression::Identifier({name: binding.name, span: e.operator.span})
          dotToken: e.operator
          member: {name: method, span: {start: e.operator.span.start, end: e.operator.span.end}}
        })
        typeArguments: None
        openParen: e.operator
        argumentList: [e.lhs, e.rhs]
        closeParen: e.operator
      })
      visitor.visitCallExpression(call)
      e->call = call
      e->type_ = call->type_
      Ok(())
    }
    Err(err) => Err(err)
  }
}

export fn ScopeVisitor(context: CompilerContext, file: File) {
  let mut importDirective: ImportDirective
  let mut matchExpression: Option<MatchExpression> = None
  let mut accessError: Option<(ToSpan, String)> = None

  fn reportError(token: ToSpan, message: String) {
    context.reportError(file, token, CompilationError::Other(message))
  }

  let structureVisitorInstance = structureVisitor(context, file)
  Object->assign({}, visit.walkingVisitor, structureVisitorInstance, {
    reportError

    visitModule: |mut self, mut m: Module| {
      self.scope = m->scope

      // Hoist function declarations
      m.statements.forEach(|s| match s {
        TopLevelStatement::ExportDirective(
          {statement: ExportedStatement::FunctionDeclaration(f)}
        ) => {
          self.visitFunctionDeclaration(f, true)
        }
        TopLevelStatement::BlockLevelStatement(
          BlockLevelStatement::Expression(Expression::FunctionDeclaration(f))
        ) => {
          self.visitFunctionDeclaration(f, true)
        }
        _ => {}
      })

      m.statements.forEach(|s| {
        self.isUsed = false
        self.visitTopLevelStatement(s)
      })
    }
    visitBlockLevelStatement: |mut self, s: BlockLevelStatement, assignedTo = undefined, isUsed = true| {
      match s {
        BlockLevelStatement::Expression(e) => self.visitExpression(e, assignedTo, isUsed)
        _ => visit.walkBlockLevelStatement(self, s)
      }
    }
    visitExpression: |mut self, e: Expression, assignedTo = undefined, isUsed = true| {
      self.isUsed = isUsed
      let parentAssignedTo = self.assignedTo
      self.assignedTo = assignedTo
      visit.walkExpression(self, e)
      self.assignedTo = parentAssignedTo
    }

    visitImplDeclaration: |self, mut i: ImplDeclaration| {
      i.members.forEach(|f| self.visitFunctionDeclaration(f))
    }
    visitImplShorthandDeclaration: |self, mut i: ImplShorthandDeclaration| {
      i.members.forEach(|f| self.visitFunctionDeclaration(f))
    }
    visitTraitDeclaration: |mut self, mut t: TraitDeclaration| {
      let parentScope = self.scope
      self.scope = t->scope
      visit.walkTraitDeclaration(self, t)
      self.scope = parentScope
    }
    visitTypeDeclaration: |self, mut t: TypeDeclaration| {}

    visitExportDirective: |self, mut e: ExportDirective| {
      visit.walkExportDirective(self, e)
    }
    visitImportDirective: |self, mut i: ImportDirective| {}
    visitObjectDestructure: |self, mut i: ObjectDestructure| {}

    visitBlock: |mut self, mut b: Block, isUsed = true| {
      b->scope = self.scope
      let assignedTo = self.assignedTo

      // Hoist function declarations
      b.statements.forEach(|s| match s {
        BlockLevelStatement::Expression(Expression::FunctionDeclaration(f)) => {
          self.visitFunctionDeclaration(f, true)
        }
        _ => {}
      })

      let lastIndex = b.statements.size() - 1
      b.statements.enumerate().forEach(|(index, s)| {
        if index == lastIndex
          then self.visitBlockLevelStatement(s, assignedTo, isUsed)
          else self.visitBlockLevelStatement(s, undefined, false)
      })

      b->type_ =
        if let Option::Some(last) = b.statements.last()
          then last.getType()
          else Type.empty({file, token: b})
    }
    visitBreak: |self, mut b: BreakStatement| {
      b->scope = self.scope
    }
    visitReturn: |mut self, mut r: ReturnStatement| {
      if not self.functionContext
        then reportError(r, 'Return used outside of a function')

      r->type_ = Type.never({file, token: r})

      let returnType: Option<Type> = self.functionContext.returnType

      if let Some(returnType) = returnType {
        self.visitExpression(r.expression, returnType)
        if not isAssignable(returnType, r.expression.getType())
          then reportError(r.expression, notAssignableError(returnType, r.expression.getType()))
      }
      else {
        self.visitExpression(r.expression)
        if r.expression.getType() {
          self.functionContext.returnTypes.push(r.expression.getType())
        }
      }
    }
    visitForLoop: |mut self, mut e: ForLoop| {
      let parentScope: Scope = self.scope
      self.scope = parentScope.createChild()
      e->scope = self.scope
      self.visitPattern(e.pattern)
      self.visitExpression(e.expression)
      if let Some(intoIteratorBinding) = parentScope.getBindingByTypeId('IntoIterator') {
        if let Some(iteratorBinding) = parentScope.getBindingByTypeId('Iterator') {
          if let Some(optionBinding) = parentScope.getBindingByTypeId('Option') {
            let intoIteratorType = intoIteratorBinding.type_.providesType.unwrap()
            let iteratorType = iteratorBinding.type_.providesType.unwrap()
            if not isAssignable(intoIteratorType, e.expression.getType())
              then reportError(e.expression
                notAssignableError(intoIteratorType, e.expression.getType())
              )
            match getImplementationForTrait(e.expression.getType(), intoIteratorType) {
              Ok(Some(mut implementation)) => {
                let type_ = resolveImplTypeParameters(implementation, e.expression.getType())
                  .unwrap().instance.unwrap().typeParameters.first().unwrap()

                let mut createIterCall = CallExpression({
                  func: Expression::MemberAccess({
                    object: Expression::Identifier({name: intoIteratorBinding.name, span: e.expression.span()})
                    dotToken: e.ofKeyword
                    member: {name: 'iter', span: e.expression.span()}
                  })
                  typeArguments: None
                  openParen: e.ofKeyword
                  argumentList: [e.expression]
                  closeParen: e.ofKeyword
                })
                e->createIterCall = createIterCall

                let mut nextCall = CallExpression({
                  func: Expression::MemberAccess({
                    object: Expression::CallExpression(createIterCall)
                    dotToken: e.ofKeyword
                    member: {name: 'next', span: e.pattern.span()}
                  })
                  typeArguments: None
                  openParen: e.ofKeyword
                  argumentList: []
                  closeParen: e.ofKeyword
                })
                e->nextCall = nextCall
                self.visitCallExpression(nextCall)

                let optionSome = TypePath::Object(
                  {name: optionBinding.name, span: e.pattern.span()}
                  TypePath::Member({name: 'Some', span: e.pattern.span()})
                )
                e->optionSome = optionSome
                self.visitTypePath(optionSome)

                match declarePatternVariables(self.scope, self, e.pattern, type_, false) {
                  Result::Ok(_) => {}
                  Result::Err(PatternError::PatternMismatch(pattern, to, subject)) => {
                    reportError(e.expression, notAssignableError(to, subject))
                  }
                  Result::Err(PatternError::ScopeError(token, err)) => reportError(token, err)
                  Result::Err(PatternError::NotExhaustive) => {
                    reportError(e.pattern, 'non exhaustive pattern')
                  }
                }
              }
              Ok(Option::None) => {
                reportError(e,
                  intoIteratorType.displayName() ++ ' has not been implemented for type ' ++ e.expression.getType().displayName()
                )
              }
              Err => reportError(e, 'Ambiguous trait call')
            }
          }
          else reportError(e
            'puck:core::Option is not in scope. Please import Option from puck:core to use for loops.'
          )
        }
        else reportError(e
          'puck:core::Iterator is not in scope. Please import Iterator from puck:core to use for loops.'
        )
      }
      else reportError(e
        'puck:core::IntoIterator is not in scope. Please import IntoIterator from puck:core to use for loops.'
      )
      self.visitBlock(e.body, false)
      e->type_ = Type.empty({file, token: e})
      self.scope = parentScope
    }
    visitWhileLoop: |mut self, mut e: WhileLoop| {
      let parentScope: Scope = self.scope
      self.scope = parentScope.createChild()
      e->scope = self.scope
      self.visitExpression(e.condition)
      self.visitBlock(e.body, false)
      e->type_ = Type.empty({file, token: e})
      self.scope = parentScope
    }

    visitIdentifier: |self, mut i: Identifier| {
      let scope: Scope = self.scope
      i->scope = self.scope
      if let Option::Some(binding) = scope.getBinding(i.name) {
        let mut b = binding
        i->binding = binding
        i->type_ =
          if binding.type_ and binding.type_.providesType.isSome()
            then enumMemberToFunction(b.type_)
            else binding.type_
      }
      else context.reportError(
        file
        i
        CompilationError::UndefinedVariable(i.name)
      )
      ()
    }
    visitFunctionDeclaration: |mut self, mut f: FunctionDeclaration, isHoisting = false| {
      structureVisitorInstance.visitFunctionDeclaration->call(self, f)

      if not isHoisting {
        let selfScope = self.scope
        self.scope = f->scope

        if self.variableDeclarationScope {
          let vdScope: Scope = self.variableDeclarationScope
          let mut fScope: Scope = self.scope
          let mut bindings = fScope.bindings
          if let Some(vdParent) = vdScope.parent {
            while true {
              if let Some(fParent) = fScope.parent {
                if identical(vdParent, fParent) {
                  break
                }
                else {
                  bindings = Object->assign({}, fParent.bindings, bindings).transmute()
                  fScope = fParent
                }
              }
              else break
            }
          }
          self.scope = Scope({
            context: self.scope.context
            parent: Some(self.variableDeclarationScope)
            bindings: bindings
            bindingsByTypeId: self.scope.bindingsByTypeId
          })
        }

        if let Option::Some(body) = f.body {
          let parentAssignedTo = self.assignedTo
          let parentContext = self.functionContext
          let mut isUsed = true
          self.functionContext = {
            returnType: None
            returnTypes: []
          }
          if let TypeKind::Function(func) = f.type_.kind {
            self.assignedTo = func.returnType
            if func.returnType {
              self.functionContext.returnType = Some(func.returnType)

              if func.returnType.isEmpty() {
                isUsed = false
              }
            }
          }
          self.visitBlock(body, isUsed)
          if let Option::None = self.functionContext {
          }

          if let TypeKind::Function(func) = f.type_.kind {
            if func.returnType {
              if not isAssignable(func.returnType, body.type_) and not func.returnType.isEmpty()
                then reportError(f, notAssignableError(func.returnType, body.type_))
            }
            else {
              let mut types: List<Type> = self.functionContext.returnTypes
              if body.type_ {
                types.push(body.type_)
              }

              if types.isNotEmpty() {
                match findCommonType(types) {
                  Result::Ok(type_) => {
                    Object->assign(func, {
                      returnType: body.type_
                    })
                  }
                  Result::Err(_) => reportError(f,
                    'No best common type exists among return expressions. Found ' ++ types.map(|type_| type_.displayName())->join(', ').transmute::<String>()
                  )
                }
              }
            }
          }

          self.assignedTo = parentAssignedTo
          self.functionContext = parentContext
        }

        self.scope = selfScope
      }
    }
    visitVariableDeclaration: |mut self, mut d: VariableDeclaration, visitInitializer, type_| {
      structureVisitorInstance.visitVariableDeclaration->call(
        self
        d
        if visitInitializer
          then visitInitializer
          else |e| {
            self.isUsed = true
            self.visitExpression(e, d->type_)
          }
        type_
      )
    }

    visitAssignmentExpression: |self, mut e: AssignmentExpression| {
      e->scope = self.scope
      if let Expression::IndexAccess(a) = e.lhs {
        visit.walkIndexAccess(self, a)
        self.visitExpression(e.rhs)
      }
      else {
        visit.walkAssignmentExpression(self, e)
      }
      if let Option::Some(binding) = getBinding(e.lhs) {
        if not binding.mutable
          then reportError(e, "Can't assign to immutable variable " ++ binding.name)

        if not isAssignable(e.lhs.getType(), e.rhs.getType())
          then reportError(e, notAssignableError(e.lhs.getType(), e.rhs.getType()))
      }

      e->type_ = e.lhs.getType() or e.rhs.getType()
    }
    visitBinaryExpression: |self, mut e: BinaryExpression| {
      match e.operator.kind {
        SyntaxKind::PlusToken => {
          asTraitCall(self, e, 'Add', 'add', 'the addition operator')
        }
        SyntaxKind::MinusToken => {
          asTraitCall(self, e, 'Sub', 'sub', 'the subtraction operator')
        }
        SyntaxKind::AsteriskToken => {
          asTraitCall(self, e, 'Mul', 'mul', 'the multiplication operator')
        }
        SyntaxKind::SlashToken => {
          asTraitCall(self, e, 'Div', 'div', 'the division operator')
        }
        SyntaxKind::PercentToken => {
          asTraitCall(self, e, 'Rem', 'rem', 'the reminder operator')
        }
        SyntaxKind::AsteriskAsteriskToken => {
          asTraitCall(self, e, 'Mul', 'mul', 'the power operator')
        }
        SyntaxKind::EqualsEqualsToken => {
          asTraitCall(self, e, 'PartialEq', 'eq', 'equal operators')
        }
        SyntaxKind::ExclamationEqualsToken => {
          asTraitCall(self, e, 'PartialEq', 'ne', 'equal operators')
        }
        SyntaxKind::LessThanToken => {
          asTraitCall(self, e, 'PartialOrd', 'lt', 'comparison operators')
        }
        SyntaxKind::LessThanEqualsToken => {
          asTraitCall(self, e, 'PartialOrd', 'le', 'comparison operators')
        }
        SyntaxKind::GreaterThanToken => {
          asTraitCall(self, e, 'PartialOrd', 'gt', 'comparison operators')
        }
        SyntaxKind::GreaterThanEqualsToken => {
          asTraitCall(self, e, 'PartialOrd', 'ge', 'comparison operators')
        }
        SyntaxKind::PlusPlusToken => {
          asTraitCall(self, e, 'Concat', 'concat', 'the concat operator')
        }
        _ => {
          visit.walkBinaryExpression(self, e)
        }
      }
    }
    visitCallExpression: |mut self, mut e: CallExpression| {
      e->scope = self.scope
      let scope: Scope = self.scope

      let mut functionType: Type;
      let mut isUnknownCall = false
      // If it's a direct trait call the first argument is walked when
      // resolving the implementation
      let mut skipFirstArgument = false

      if let Expression::MemberAccess(access) = e.func {
        self.visitMemberAccess(access, true)
        functionType = e.func.getType()

        if access.object.getType() {
          let name = access.member.name
          let objectType = access.object.getType()

          // If the call is directly on the type, for example Num.parse()
          if let Option::Some(providesType) = objectType.providesType {
            match providesType.kind {
              TypeKind::Enum(enum_) => {
                functionType = enum_.implementations
                  .find(|{trait_}| trait_.getTrait().isShorthand)
                  .andThen(|{trait_}| trait_.getTrait().functions.get(name))
                  .unwrapOr(undefined)
              }
              TypeKind::Struct(struct) => {
                functionType = struct.implementations
                  .find(|{trait_}| trait_.getTrait().isShorthand)
                  .andThen(|{trait_}| trait_.getTrait().functions.get(name))
                  .unwrapOr(undefined)
              }
              TypeKind::Trait(trait_) => {
                functionType = trait_.functions.get(name).unwrapOr(undefined)
              }
              _ => {}
            }

            if functionType {
              let function = functionType.getFunction()

              if let Some(selfBinding) = function.selfBinding {
                functionType = {
                  definition: functionType.definition
                  id: functionType.id
                  displayName: functionType.displayName
                  name: functionType.name
                  kind: TypeKind::Function({
                    selfBinding: None
                    parameters: [selfBinding]->concat(function.parameters).transmute()
                    parameterRange: {start: function.parameterRange.start + 1, end: function.parameterRange.end + 1}
                    returnType: function.returnType
                    isAbstract: function.isAbstract
                  })
                  class: functionType.class
                  instance: functionType.instance
                  providesType: functionType.providesType
                  enumMember: functionType.enumMember
                }
                if let Some(selfArgument) = e.argumentList.first() {
                  skipFirstArgument = true
                  self.visitExpression(selfArgument)
                  if not selfArgument.getType() {
                    reportError(selfArgument, 'selfArgument has no type')
                  }
                  match getImplementationForTraitCall(name, selfArgument.getType(), objectType.providesType.unwrapOr(objectType), e, functionType) {
                    Ok(Some(implementation)) => {
                      e->traitName = scope.getBindingByTypeId(providesType.id.unwrap()).unwrap().name
                      e->traitBinding = scope.getBindingByTypeId(providesType.id.unwrap()).unwrap()
                      e->isDirectTraitCall =  true
                      e->implementation = implementation
                      if providesType.class.isSome() {
                        match resolveImplTypeParameters(e->implementation.transmute(), selfArgument.getType()) {
                          Ok(resolvedTrait) => {
                            let mut parameterMap = resolvedTrait.instance.unwrap().parameterMap
                            functionType = resolveTypeParameters(parameterMap)(functionType)
                          }
                          Err((to, subject)) => return reportError(e, notAssignableError(to, subject))
                        }
                      }
                    }
                    Ok(Option::None) => {
                      reportError(e,
                        objectType.displayName() ++ ' has not been implemented for type ' ++ selfArgument.getType().displayName()
                      )
                    }
                    Err => reportError(e, 'Ambiguous trait call')
                  }
                }
              }
              else {
                e->traitName = scope.getBindingByTypeId(providesType.id.unwrap()).unwrap().name
                e->traitBinding = scope.getBindingByTypeId(providesType.id.unwrap()).unwrap()
                e->isTraitObject =  true
              }
            }
            else reportError(e, providesType.displayName() ++ ' has no function named $name')
          }
          // It is a normal trait call, for example 'hello'.toUpperCase()
          else {
            if let TypeKind::Trait(trait_) = objectType.kind {
              if let Some(func) = trait_.functions.get(name) {
                functionType = func
                let function = functionType.getFunction()

                if function.selfBinding.isSome() {
                  if let Some(binding) = scope.getBindingByTypeId(objectType.id.unwrap()) {
                    e->traitName = binding.name
                    e->traitBinding = binding
                    e->isTraitObject =  true
                  }
                  else {
                    let typeName = objectType.name.unwrap()
                    context.reportError(
                      file
                      e
                      CompilationError::TraitNotInScope({
                        functionName: name
                        traitName: typeName
                        id: objectType.id.unwrap()
                      })
                    )
                  }
                }
              }
            }
            else match getImplementation(name, objectType, e) {
              Ok(Some(implementation)) => {
                let trait_: Type =
                  if let Option::Some(instance) = implementation.trait_.instance
                    then instance.class
                    else implementation.trait_

                if let Some(binding) = scope.getBindingByTypeId(trait_.id.unwrap()) {
                  e->traitName = binding.name
                  e->traitBinding = binding
                  e->isShorthand =  trait_.getTrait().isShorthand
                  e->implementation = implementation

                  functionType = implementation.trait_.getTrait().functions[name]
                }
                else {
                  let traitName = trait_.name.unwrap()
                  context.reportError(
                    file
                    e
                    CompilationError::TraitNotInScope({
                      functionName: name
                      traitName
                      id: trait_.id.unwrap()
                    })
                  )
                }
              }
              Ok(None) => {}
              Err => reportError(e, 'Ambiguous trait call')
            }

            if e->traitName {
              if let Option::Some(instance) = objectType.instance {
                functionType = resolveTypeParameters(instance.parameterMap)(functionType)
              }
            }
          }
        }

        if e->traitName {
          accessError = None
        }
        else if let Some((token, message)) = accessError {
          reportError(token, message)
          accessError = None
        }
      }
      else {
        self.visitExpression(e.func)
        functionType = e.func.getType()

        if let Expression::UnknownAccess(_) = e.func {
          isUnknownCall = true
        }
        else if let Expression::UnknownIndexAccess(_) = e.func {
          isUnknownCall = true
        }
      }

      if let Some(t) = e.typeArguments {
        let callParameterMap: ObjectMap<Type> = ObjectMap.new()

        t.typeArguments.forEach(|t| self.visitTypeBound(t))

        if functionType {
          if let Some(class) = functionType.class {
            if class.parameterRange.contains(t.typeArguments.size()) {
              functionType = createTypeInstance(functionType, t.typeArguments.map(|t| t.getType()).toList())
            }
          }
        }
      }

      if not isUnknownCall and functionType and functionType.isFunction() {
        let callTypeParameters = functionType.class.map(|class| class.typeParameters).unwrapOr([])
        let mut callParameterMap: ObjectMap<Type> = ObjectMap.new()
        let mut functionKind = functionType.getFunction()
        let resolveParameter = resolveTypeParameters(callParameterMap, false)

        if self.assignedTo and functionKind.returnType {
          resolveFunctionTypeParametersByReturnValue(
            callParameterMap
            callTypeParameters
            functionKind.returnType
            self.assignedTo
          )
        }

        e.argumentList.enumerate()
          // If too many arguments are passed e.argumentList will be longer than functionKind.parameters
          .take(functionKind.parameters.size())
          .forEach(|(i, a)| {
            let mut parameter = functionKind.parameters[i]
            let parameterType =
              if not parameter.type_ or callTypeParameters.isEmpty()
                then parameter.type_
                else resolveParameter(parameter.type_)
            if not skipFirstArgument or i > 0 {
              self.visitExpression(a, parameterType)
            }
            if callTypeParameters.isNotEmpty() and parameterType and a.getType() {
              resolveFunctionTypeParameters(
                callParameterMap
                callTypeParameters
                parameterType
                a.getType()
              )
            }
          })
        if callTypeParameters.isNotEmpty() {
          functionType = resolveTypeParameters(callParameterMap)(functionType)
        }
      }
      else {
        e.argumentList.forEach(|a| self.visitExpression(a))
      }
      if isUnknownCall {
        e->type_ = functionType
      }
      else if functionType {
        e->functionType = functionType
        match checkFunctionCall(functionType, e) {
          Ok(function) => {
            if function {
              e->type_ = function.returnType
            }
          }
          Err((token, message)) => reportError(token, message)
        }
      }
      ()
    }
    visitIfExpression: |mut self, mut e: IfExpression| {
      let parentScope: Scope = self.scope
      e->scope = self.scope
      let isUsed = self.isUsed
      self.visitExpression(e.condition)
      self.scope = parentScope.createChild()
      self.visitBlock(e.then_, isUsed and e.else_.isSome())
      if let Option::Some(else_) = e.else_ {
        self.scope = parentScope.createChild()
        self.visitBlock(else_, isUsed)
      }
      if isUsed {
        e->type_ =
          if let Option::Some(else_) = e.else_ {
            match  findCommonType([e.then_.type_, else_.type_]) {
              Result::Ok(type_) => type_
              Result::Err(_) => {
                reportError(e
                  'Type ' ++ e.then_.type_.displayName() ++ ' and ' ++ else_.type_.displayName() ++ ' is not compatible'
                )
                Type.empty({file, token: e})
              }
            }
          }
          else Type.empty({file, token: e})
      }
      self.scope = parentScope
    }
    visitIfLetExpression: |mut self, mut e: IfLetExpression| {
      let parentScope: Scope = self.scope
      e->scope = self.scope
      self.scope = parentScope.createChild()
      let isUsed = self.isUsed
      self.visitPattern(e.pattern)
      self.visitExpression(e.expression)
      match declarePatternVariables(self.scope, self, e.pattern, e.expression.getType(), true) {
        Result::Ok(_) => {}
        Result::Err(PatternError::PatternMismatch(pattern, to, subject)) => {
          reportError(e.expression, notAssignableError(to, subject))
        }
        Result::Err(PatternError::ScopeError(token, err)) => reportError(token, err)
        Result::Err(PatternError::NotExhaustive) => {
          // Allowed in if let expressions
        }
      }
      let expressionScope: Scope = self.scope
      self.scope = expressionScope.createChild()
      self.visitBlock(e.then_, isUsed)
      if let Option::Some(else_) = e.else_ {
        self.scope = expressionScope.createChild()
        self.visitBlock(else_, isUsed)
      }
      if isUsed {
        e->type_ =
          if let Option::Some(else_) = e.else_ {
            match findCommonType([e.then_.type_, else_.type_]) {
              Result::Ok(type_) => type_
              Result::Err(_) => {
                reportError(e
                  'Type ' ++ e.then_.type_.displayName() ++ ' and ' ++ else_.type_.displayName() ++ ' is not compatible'
                )
                Type.empty({file, token: e})
              }
            }
          }
          else Type.empty({file, token: e})
      }
      self.scope = parentScope
    }
    visitMatchExpression: |mut self, mut e: MatchExpression| {
      e->scope = self.scope
      let oldMatchExpression = matchExpression
      matchExpression = Some(e)

      let isUsed = self.isUsed

      self.visitExpression(e.expression)

      e.patterns.forEach(|a| self.visitMatchArm(a, isUsed))

      if not e.expression.getType() {
        return reportError(e.expression, 'No type in match expression')
      }

      if let Result::Err(error) = checkExhaustive(e) {
        reportError(e, error)
      }
      if isUsed {
        e->type_ =
          if e.patterns.isNotEmpty() {
            match findCommonType(e.patterns.map(|arm| arm->type_.transmute()).toList()) {
              Result::Ok(type_) => type_
              Result::Err(_) => {
                reportError(e
                  'Match arms return mixed types ' ++ e.patterns.map(|arm| asType(arm->type_.transmute()).displayName())->join(', ').transmute::<String>()
                )
                Type.empty({file, token: e})
              }
            }
          }
          else Type.empty({file, token: e})
      }

      matchExpression = oldMatchExpression
      ()
    }
    visitMatchArm: |mut self, mut a: MatchArm, isUsed| {
      let parentScope: Scope = self.scope
      self.scope = parentScope.createChild()
      a->scope = self.scope

      let m = matchExpression.unwrap()

      self.visitPattern(a.pattern)
      match declarePatternVariables(self.scope, self, a.pattern, m.expression.getType(), true) {
        Result::Ok(_) => {}
        Result::Err(PatternError::PatternMismatch(pattern, to, subject)) => {
          reportError(a, notAssignableError(to, subject))
        }
        Result::Err(PatternError::ScopeError(token, err)) => reportError(token, err)
        Result::Err(PatternError::NotExhaustive) => {
          // Allowed in match expressions
        }
      }

      self.visitBlock(a.block, isUsed)
      a->type_ = a.block->type_

      self.scope = parentScope
    }
    visitTypePathExpression: |self, mut e: TypePathExpression| {
      e->scope = self.scope
      let typePath = e.typePath
      self.visitTypePath(e.typePath)
      let mut type_: Type = e.typePath->type_.transmute()
      if type_ {
        e->type_ = enumMemberToFunction(type_)
      }
    }
    visitUnaryExpression: |self, mut e: UnaryExpression| {
      let scope: Scope = self.scope
      e->scope = self.scope
      visit.walkUnaryExpression(self, e)

      match e.operator.kind {
        SyntaxKind::NotKeyword => {
          if let Some(binding) = scope.getBindingByTypeId('Bool') {
            e->type_ = binding.type_.providesType.unwrap()
          }
          else reportError(e
            'puck:core::Bool is not in scope. Please import Bool from puck:core to use boolean literals.'
          )
        }
        SyntaxKind::MinusToken => {
          if let Some(binding) = scope.getBindingByTypeId('Num') {
            e->type_ = binding.type_.providesType.unwrap()
          }
          else reportError(e
            'puck:core::Num is not in scope. Please import Num from puck:core to use number literals.'
          )
        }
        SyntaxKind::PlusToken => {
          if let Some(binding) = scope.getBindingByTypeId('Num') {
            e->type_ = binding.type_.providesType.unwrap()
          }
          else reportError(e
            'puck:core::Num is not in scope. Please import Num from puck:core to use number literals.'
          )
        }
        _ => {}
      }
      ()
    }

    visitIndexAccess: |self, mut a: IndexAccess| {
      match getCoreType(self.scope, 'Index', 'index access') {
        Ok((_, binding)) => {
          let mut call = CallExpression({
            func: Expression::MemberAccess({
              object: Expression::Identifier({name: binding.name, span: a.object.span()})
              dotToken: a.openBracket
              member: {name: 'index', span: {start: a.openBracket.span.start, end: a.closeBracket.span.end}}
            })
            typeArguments: None
            openParen: a.openBracket
            argumentList: [a.object, a.index]
            closeParen: a.closeBracket
          })
          self.visitCallExpression(call)
          a->call = call
          a->type_ = call->type_
          ()
        }
        Err(err) => reportError(a, err)
      }
    }
    visitMemberAccess: |self, mut a: MemberAccess, inCallExpression = false| {
      self.visitExpression(a.object)
      if a.object.getType() {
        if let TypeKind::Struct({kind: StructKind::Record(record)}) = a.object.getType().kind {
          match record.properties.get(a.member.name).map(getRecordPropType(self.scope)) {
            Some(Ok(type_)) => a->type_ = type_
            Some(Err(err)) => reportError(a, err)
            None => {
              let message = a.object.getType().displayName() ++ ' has no property ' ++ a.member.name
              let token: ToSpan = a.member
              if inCallExpression
                then accessError = Some((token, message))
                else reportError(a, message)
            }
          }
        }
        else {
          let message = 'Can only read properties on record types'
          let token: ToSpan = a.member
          if inCallExpression
            then accessError = Some((token, message))
            else reportError(a, message)
        }
      }
    }
    visitTupleIndexAccess: |self, mut a: TupleIndexAccess, inCallExpression = false| {
      self.visitExpression(a.object)
      if a.object.getType() {
        if let TypeKind::Struct({kind: StructKind::Tuple(record)}) = a.object.getType().kind {
          match record.properties.get(a.index.value) {
            Some(type_) => a->type_ = type_
            None => {
              let message = a.object.getType().displayName() ++ ' has no index ' ++ a.index.value.toString()
              let token: ToSpan = a.index
              if inCallExpression
                then accessError = Some((token, message))
                else reportError(a, message)
            }
          }
        }
        else {
          let message = 'Can only read properties on tuple types'
          let token: ToSpan = a.index
          if inCallExpression
            then accessError = Some((token, message))
            else reportError(a, message)
        }
      }
    }
    visitUnknownAccess: |self, mut a: UnknownAccess| {
      visit.walkExpression(self, a.object)
      match getCoreType(self.scope, 'Unknown', 'unknown access') {
        Ok((type_, _)) => a->type_ = type_
        Err(err) => reportError(a, err)
      }
      ()
    }
    visitUnknownIndexAccess: |self, mut a: UnknownIndexAccess| {
      visit.walkUnknownIndexAccess(self, a)
      match getCoreType(self.scope, 'Unknown', 'unknown access') {
        Ok((type_, _)) => a->type_ = type_
        Err(err) => reportError(a, err)
      }
      ()
    }

    visitBooleanLiteral: |self, mut l: BooleanLiteral| {
      let scope: Scope = self.scope
      l->scope = self.scope
      if let Some(binding) = scope.getBindingByTypeId('Bool') {
        l->type_ = binding.type_.providesType.unwrap()
      }
      else reportError(l
        'puck:core::Bool is not in scope. Please import Bool from puck:core to use boolean literals.'
      )
      ()
    }
    visitListLiteral: |self, mut l: ListLiteral| {
      let scope: Scope = self.scope
      let mut listType =
        if let Some(binding) = scope.getBindingByTypeId('List') {
          binding.type_.providesType.unwrap()
        }
        else return reportError(l
          'puck:core::List is not in scope. Please import List from puck:core to use list literals.'
        )
      let mut type_: Option<Type> = None
      if self.assignedTo {
        let a: Type = self.assignedTo
        if let TypeKind::Struct(_) = a.kind {
          if a.id.unwrapOr('') == 'List' {
            type_ = Some(a)
          }
        }
      }
      visit.walkListLiteral(self, l)
      if let Some(type_) = type_ {
        l->type_ = type_
      } else {
        if l.members.size() >= 1 {
          let types = l.members.map(|m| m.getType()).toList()
          match findCommonType(types) {
            Result::Ok(type_) => {
              if not type_ {
                l->type_ = listType
              } else {
                l->type_ = createTypeInstance(listType, [type_])
              }
            }
            Result::Err(_) => reportError(l, 'List contains mixed types')
          }
        }
        else {
          l->type_ = listType
        }
      }
      ()
    }
    visitNumberLiteral: |self, mut l: NumberLiteral| {
      let scope: Scope = self.scope
      if let Some(binding) = scope.getBindingByTypeId('Num') {
        l->type_ = binding.type_.providesType.unwrap()
        ()
      }
      else reportError(l
        'puck:core::Num is not in scope. Please import Num from puck:core to use number literals.'
      )
    }
    visitRangeLiteral: |self, mut l: RangeLiteral| {
      visit.walkRangeLiteral(self, l)
      let scope: Scope = self.scope
      match getCoreType(scope, 'Range', 'range literals') {
        Ok((_, binding)) => {
          let mut call = CallExpression({
            func: Expression::MemberAccess({
              object: Expression::Identifier({name: binding.name, span: l.dotDotToken.span})
              dotToken: l.dotDotToken
              member: {name: 'new', span: l.dotDotToken.span}
            })
            typeArguments: None
            openParen: l.dotDotToken
            argumentList: [l.start, l.end]
            closeParen: l.dotDotToken
          })
          self.visitCallExpression(call)
          l->call = call
          l->type_ = call->type_
        }
        Err(err) => reportError(l, err)
      }
      ()
    }
    visitRecordLiteral: |self, mut l: RecordLiteral| {
      visit.walkRecordLiteral(self, l)
      let mut properties = ObjectMap.new::<RecordMember>()
      l.members.forEach(|m| {
        match m {
          RecordLiteralMember::Property {name, value} => {
            properties.set(name.name, {type_: value.getType(), optional: false})
          }
          RecordLiteralMember::Spread(e) => {
            match e.getType().kind {
              TypeKind::Struct({kind: StructKind::Record(r)}) => {
                properties.merge(r.properties)
              }
              _ => {}
            }
          }
        }
      })
      l->type_ = Type({
        definition: Definition({file, token: l})
        id: None
        displayName: None
        name: None
        kind: TypeKind::Struct({
          implementations: []
          kind: StructKind::Record({properties})
        })
        class: None
        instance: None
        providesType: None
        enumMember: None
      })
    }
    visitRecordLiteralMember: |self, mut l: RecordLiteralMember| {
      visit.walkRecordLiteralMember(self, l)
      if let RecordLiteralMember::Spread(e) = l {
        match e.getType().kind {
          TypeKind::Struct({kind: StructKind::Record(_)}) => {}
          _ => {
            reportError(e, 'Can only spread record types')
          }
        }
      }
    }
    visitStringLiteral: |self, mut l: StringLiteral| {
      let scope: Scope = self.scope
      l->scope = self.scope
      if let Some(binding) = scope.getBindingByTypeId('String') {
        l->type_ = binding.type_.providesType.unwrap()
      }
      else reportError(l
        'puck:core::String is not in scope. Please import String from puck:core to use string literals.'
      )
      visit.walkStringLiteral(self, l)
    }
    visitTupleLiteral: |self, mut l: TupleLiteral| {
      l->scope = self.scope
      visit.walkTupleLiteral(self, l)
      l->type_ = Type({
        definition: Definition({file, token: l})
        id: None
        displayName: None
        name: None
        kind: TypeKind::Struct({
          implementations: []
          kind: StructKind::Tuple({
            properties: l.expressions.map(|e| e.getType()).toList()
          })
        })
        class: None
        instance: None
        providesType: None
        enumMember: None
      })
    }

    visitPattern: |self, mut p: Pattern| {
      p->scope = self.scope
      visit.walkPattern(self, p)
      p->type_ =
        match p {
          Pattern::CatchAll => Type.unused({file, token: p})
          Pattern::Identifier {identifier} => undefined
          Pattern::Record(record) => record->type_.transmute()
          Pattern::RecordType(typePath, record) => {
            let type_: Type = typePath->providesType.transmute()
            if not isAssignable(record->type_.transmute(), type_)
              then reportError(p, type_.displayName() ++ ' is not assignable to pattern ' ++ record.displayName())
            type_.enumMember.mapOr(type_, |(_, enum_)| enum_)
          }
          Pattern::Tuple(tuple) => tuple->type_.transmute()
          Pattern::TupleType(typePath, tuple) => {
            let type_: Type = typePath->providesType.transmute()
            if not isAssignable(tuple->type_.transmute(), type_)
              then reportError(p, type_.displayName() ++ ' is not assignable to pattern ' ++ tuple.displayName())
            type_.enumMember.mapOr(type_, |(_, enum_)| enum_)
          }
          Pattern::UnitType(typePath) => undefined
        }
    }

    visitRecordPattern: |self, mut p: RecordPattern| {
      p->scope = self.scope
      visit.walkRecordPattern(self, p)
      p->type_ = Type({
        definition: Definition({file, token: p})
        id: None
        displayName: None
        name: None
        kind: TypeKind::Struct({
          implementations: []
          kind: StructKind::Record({properties: ObjectMap.fromIter(p.properties.map(|p| {
            let type_: Type = p.pattern->type_.transmute()
            (p.property.name, {type_, optional: false})
          }))})
        })
        instance: None
        class: None
        providesType: None
        enumMember: None
      })
    }
    visitTuplePattern: |self, mut p: TuplePattern| {
      p->scope = self.scope
      visit.walkTuplePattern(self, p)
      p->type_ = Type({
        definition: Definition({file, token: p})
        id: None
        displayName: None
        name: None
        kind: TypeKind::Struct({
          implementations: []
          kind: StructKind::Tuple({properties: p.properties.map(|p| p->type_.transmute()).toList()})
        })
        instance: None
        class: None
        providesType: None
        enumMember: None
      })
    }
  })
}
