import 'puck:core' as core
import 'puck:js' as {Object, global, undefined}
import 'node:util' as {inspect}
import '../ast/ast.puck' as {
  Expression

  Block
  FunctionDeclaration
  Identifier
  ImplDeclaration
  ImplShorthandDeclaration
  Module
  ObjectDestructure
  TypeBound
  FunctionTypeBound
  NamedTypeBound
  TraitDeclaration
  TypeDeclaration
  TypeParameter
  TypePath
  VariableDeclaration

  ExportDirective
  ImportDirective

  Pattern

  AssignmentExpression
  BinaryExpression
  CallExpression
  ForExpression
  IfExpression
  IfLetExpression
  MatchExpression
  MatchArm
  TypePathExpression
  UnaryExpression
  WhileLoop

  IndexAccess
  MemberAccess

  Token
  ReturnStatement

  ListLiteral
  BooleanLiteral
  NumberLiteral
  ObjectLiteral
  StringLiteral
  TupleLiteral
}
import '../ast/visit.puck' as visit
import '../compiler/ast.ts' as {SyntaxKind}
import 'src/enums.puck' as {checkExhaustive}
import 'src/functions.puck' as {resolveFunctionTypeParameters}
import 'src/impls.puck' as {getImplementation}
import 'src/range.puck' as {checkRange}
import 'src/scope.puck' as {createScope}
import 'src/structure_visitor.puck' as {declarePatternVariables, notAssignableError, structureVisitor}
import 'src/types.puck' as {
  createTypeInstance
  findCommonType
  getType
  isAssignable
  isSameType
  resolveTypeParameters
}
import '../entities.puck' as {
  Binding
  Function
  Implementation
  Scope
  Struct
  StructKind
  Type
  TypeInstance
  TypeKind
}

fn asType(a) -> Type {a}
fn asIterable<E>(a: List<E>) -> Iterable<E> {a}

export fn ScopeVisitor(context, file) {
  let mut importDirective: ImportDirective
  let mut matchExpression: Option<MatchExpression> = None
  let reportError = context.reportError.bind(context, file)

  fn getBinding(token: Expression) {
    if token.kind == SyntaxKind.Identifier
      then token.scope.getBinding(token.name)
    else if token.kind == SyntaxKind.MemberAccess
      then getBinding(token.object)
    else if token.kind == SyntaxKind.IndexAccess
      then getBinding(token.object)
  }

  fn checkFunctionCall(functionType: Type, c: CallExpression) {
    if not functionType then return undefined
    let name = c.func.name or None
    let iName: Option<String> = if not name.kind
      then Some(name)
      else name
    let name = iName.unwrapOrElse(|| functionType.displayName())

    let function = match functionType.kind {
      TypeKind::Function(func) => func
      _ => reportError(c, '$name is not callable')
    }

    if let Option::Some(selfBinding) = function.selfBinding {
      if selfBinding.mutable {
        let binding = getBinding(c.func)
        if binding and not binding.mutable
          then reportError(c, '$name can only be called on a mutable binding')
      }
    }

    if let Result::Err(error) = checkRange(c.argumentList, function.argumentRange, 'arguments', name)
      then reportError(c, error)

    let function: Function =
      if let Option::Some(class) = functionType.class {
        let mut parameterMap = ObjectMap.new()

        function.arguments.enumerate().forEach(|(parameter, i): (Binding, Num)| {
          let argument: VariableDeclaration =
            if i < c.argumentList.length
              then c.argumentList[i]
              else parameter

          if parameter.type_ and argument.type_ {
            if let TypeKind::Parameter = parameter.type_.kind {
              if parameterMap[parameter.type_.name.unwrap()] {
                let existingMapping = parameterMap[parameter.type_.name.unwrap()]
                if not isAssignable(existingMapping, argument.type_) {
                  if isAssignable(argument.type_, existingMapping) {
                    parameterMap[parameter.type_.name.unwrap()] = argument.type_
                  }
                  else reportError(argument, notAssignableError(existingMapping, argument.type_))
                }
              }
              else {
                parameterMap[parameter.type_.name.unwrap()] = argument.type_
              }
            }
          }
        })
        let resolvedFunction: Type = resolveTypeParameters(parameterMap)(functionType)

        match resolvedFunction.kind {
          TypeKind::Function(func) => func
          _ => throw 'resolved function is not a function'
        }
      }
      else function

    c.argumentList.enumerate().forEach(|(argument, i)| {
      let parameter = function.arguments[i]
      let parameterName =
        if parameter.pattern
          then if let Pattern::Identifier({name}) = parameter.pattern
            then name
            else '$i'
          else '$i'

      if not isAssignable(parameter.type_, argument.type_)
        then reportError(argument
          notAssignableError(parameter.type_, argument.type_) +
          ' in parameter $parameterName of function $name'
        )

      if parameter.mutable and argument.kind == SyntaxKind.Identifier {
        let argumentName = argument.name
        let argumentBinding = argument.scope.getBinding(argumentName)

        if not argumentBinding.mutable {
          reportError(argument
            'Parameter $parameterName of function $name requires a mutable binding ' +
            'but $argumentName is declared as immutable.'
          )
        }
      }
    })

    function
  }

  fn defineHoisted(expressions, visitor) {
    expressions.forEach(|mut e| {
      if e.kind == SyntaxKind.Function {
        e.hoisting = true
        visitor.visitFunctionDeclaration(e)
        e.hoisted = true
      }
      if e.kind == SyntaxKind.ExportDirective and
          e.expression.kind == SyntaxKind.Function {
        e.expression.hoisting = true
        visitor.visitFunctionDeclaration(e.expression)
        e.expression.hoisted = true
      }
    })
  }

  Object.assign({}, visit.walkingVisitor, structureVisitor, {
    reportError

    visitExpression: |mut self, e: Expression, isUsed = true| {
      self.isUsed = isUsed
      visit.walkingVisitor.visitExpression.call(self, e)
    }

    visitBlock: |self, mut b: Block, isBlockUsed = true| {
      b.scope = self.scope

      defineHoisted(b.expressions, self)

      b.expressions.enumerate().forEach(|(e, i)| {
        let isUsed = isBlockUsed and i + 1 == b.expressions.size()
        self.visitExpression(e, isUsed)
      })

      b.type_ =
        if let Option::Some(last) = b.expressions.last()
          then last.type_
          else Type.empty()
    }
    visitFunctionDeclaration: |mut self, mut f: FunctionDeclaration| {
      structureVisitor.visitFunctionDeclaration.call(self, f)

      if not f.hoisting or f.hoisted {
        let selfScope = self.scope
        self.scope = f.scope

        f.parameterList.forEach(|p| self.visitVariableDeclaration(p))
        if let Option::Some(body) = f.body {
          self.visitBlock(body)

          if let TypeKind::Function(func) = f.type_.kind {
            if func.returnType {
              if not isAssignable(func.returnType, body.type_)
                then reportError(f, notAssignableError(func.returnType, body.type_))
            }
            else {
              Object.assign(func, {
                returnType: body.type_
              })
            }
          }
        }

        self.scope = selfScope
      }
    }
    visitIdentifier: |self, mut i: Identifier| {
      i.scope = self.scope
      let binding = i.scope.getBinding(i.name)
      if not binding
        then reportError(i, 'Use of undefined variable ' + i.name)
        else i.type_ = binding.type_
      visit.walkIdentifier(self, i)
    }
    visitImplDeclaration: |self, mut i: ImplDeclaration| {
      i.members.forEach(self.visitFunctionDeclaration.bind(self))
    }
    visitImplShorthandDeclaration: |self, mut i: ImplShorthandDeclaration| {
      i.members.forEach(self.visitFunctionDeclaration.bind(self))
    }
    visitModule: |mut self, mut m: Module| {
      self.scope = m.scope

      defineHoisted(m.expressions, self)
      m.expressions.forEach(|e| {
        self.visitExpression(e, false)
      })
    }
    visitObjectDestructure: |self, mut i: ObjectDestructure| {}
    visitTraitDeclaration: |mut self, mut t: TraitDeclaration| {
      self.scope = t.scope
      visit.walkTraitDeclaration(self, t)
      self.scope = self.scope.parent
    }
    visitTypeDeclaration: |self, mut t: TypeDeclaration| {}
    visitVariableDeclaration: |mut self, mut d: VariableDeclaration, visitInitializer, type_, allowNotExhaustive = false| {
      structureVisitor.visitVariableDeclaration.call(
        self
        d
        if visitInitializer
          then visitInitializer
          else |e| {
            let parentAssignedTo = self.assignedTo
            self.assignedTo = d
            self.visitExpression(e)
            self.assignedTo = parentAssignedTo
          }
        type_
        allowNotExhaustive
      )
    }

    visitExportDirective: |self, mut e: ExportDirective| {
      visit.walkExportDirective(self, e)
    }
    visitImportDirective: |self, mut i: ImportDirective| {}

    visitAssignmentExpression: |self, mut e: AssignmentExpression| {
      e.scope = self.scope
      visit.walkAssignmentExpression(self, e)
      let binding = getBinding(e.lhs)
      if binding {
        if not binding.mutable
          then reportError(e, "Can't assign to immutable variable " + binding.name)

        if not isAssignable(e.lhs.type_, e.rhs.type_)
          then reportError(e, notAssignableError(e.lhs.type_, e.rhs.type_))
      }

      e.type_ = e.lhs.type_ or e.rhs.type_
    }
    visitBinaryExpression: |self, mut e: BinaryExpression| {
      e.scope = self.scope
      visit.walkBinaryExpression(self, e)
    }
    visitCallExpression: |mut self, mut e: CallExpression| {
      e.scope = self.scope
      self.visitExpression(e.func)

      let mut functionType: Type = e.func.type_

      if e.func.kind == SyntaxKind.MemberAccess and e.func.object.type_ {
        let name = e.func.member.name
        let objectType: Type = e.func.object.type_

        if let TypeKind::Trait(trait_) = objectType.kind {
          functionType = trait_.functions[name]

          // if not functionType
          //   then reportError(e, objectType.displayName() + ' has no function named $name')

          if functionType {
            let function = functionType.getFunction()

            if function.selfBinding.isSome() {
              e.traitName = objectType.name.unwrap()
              e.isTraitObject =  true
            }
          }
        }
        else if let Option::Some(implementation) = getImplementation(name, objectType, e, reportError) {
          let trait_: Type =
            if let Option::Some(instance) = implementation.trait_.instance
              then instance.class
              else implementation.trait_
          let traitName = trait_.name.unwrap()
          if not e.scope.getTypeBinding(traitName)
            then reportError(e, 'The function $name is defined in trait $traitName but it is not in scope')

          e.traitName = traitName
          e.isShorthand =  trait_.getTrait().isShorthand
          e.implementationType = implementation.type_

          functionType = asType(implementation.trait_).getTrait().functions[name]
        }

        if let Option::Some(instance) = objectType.instance {
          functionType = resolveTypeParameters(instance.parameterMap)(functionType)
        }
      }
      if functionType and functionType.isFunction() {
        let callTypeParameters = functionType.class.map(|class| class.typeParameters).unwrapOr([])
        let mut callParameterMap = ObjectMap.new()
        let parentAssignedTo = self.assignedTo
        e.argumentList.enumerate().forEach(|(a, i)| {
          self.assignedTo = functionType.getFunction().arguments[i]
          self.visitExpression(a)
          if callTypeParameters.isNotEmpty() and functionType.getFunction().arguments[i].type_ and a.type_ {
            resolveFunctionTypeParameters(
              callParameterMap
              callTypeParameters
              functionType.getFunction().arguments[i].type_
              a.type_
            )
          }
        })
        if callTypeParameters.isNotEmpty() {
          functionType = resolveTypeParameters(callParameterMap)(functionType)
        }
        self.assignedTo = parentAssignedTo
      } else {
        e.argumentList.forEach(|a| self.visitExpression(a))
      }
      if functionType {
        e.functionType = functionType
        let function = checkFunctionCall(functionType, e)
        e.type_ = function.returnType
      }
    }
    visitForExpression: |mut self, mut e: ForExpression| {
      self.scope = createScope(context, file, self.scope)
      e.scope = self.scope
      visit.walkForExpression(self, e)
      self.scope = self.scope.parent
    }
    visitIfExpression: |mut self, mut e: IfExpression| {
      self.scope = createScope(context, file, self.scope)
      e.scope = self.scope
      let isUsed = self.isUsed
      self.visitExpression(e.condition)
      self.visitBlock(e.then_, isUsed)
      if let Option::Some(else_) = e.else_ then self.visitBlock(else_, isUsed)
      if isUsed {
        e.type_ =
          if let Option::Some(else_) = e.else_ {
            let result: Result<Type, ()> = findCommonType([e.then_.type_, else_.type_])
            match result {
              Result::Ok(type_) => type_
              Result::Err(_) => reportError(e
                'Type ' + e.then_.type_.displayName() + ' and ' + asType(else_.type_).displayName() + ' is not compatible'
              )
            }
          }
          else {{
            displayName: None
            name: None
            kind: TypeKind::Struct({
              implementations: []
              kind: StructKind::Tuple({properties: []})
            })
            class: None
            instance: None
          }}
      }
      self.scope = self.scope.parent
    }
    visitIfLetExpression: |mut self, mut e: IfLetExpression| {
      self.scope = createScope(context, file, self.scope)
      e.scope = self.scope
      let isUsed = self.isUsed
      self.visitVariableDeclaration(e.variableDeclaration, undefined, undefined, true)
      self.visitBlock(e.then_, isUsed)
      if let Option::Some(else_) = e.else_ then self.visitBlock(else_, isUsed)
      if isUsed {
        e.type_ =
          if let Option::Some(else_) = e.else_ {
            let result: Result<Type, ()> = findCommonType([e.then_.type_, else_.type_])
            match result {
              Result::Ok(type_) => type_
              Result::Err(_) => reportError(e
                'Type ' + e.then_.type_.displayName() + ' and ' + asType(else_.type_).displayName() + ' is not compatible'
              )
            }
          }
          else {{
            displayName: None
            name: None
            kind: TypeKind::Struct({
              implementations: []
              kind: StructKind::Tuple({properties: []})
            })
            class: None
            instance: None
          }}
      }
      self.scope = self.scope.parent
    }
    visitMatchExpression: |mut self, mut e: MatchExpression| {
      e.scope = self.scope
      let oldMatchExpression = matchExpression
      matchExpression = Some(e)

      let isUsed = self.isUsed

      self.visitExpression(e.expression)

      e.patterns.forEach(|a| self.visitMatchArm(a, isUsed))

      if let Result::Err(error) = checkExhaustive(e) {
        self.reportError(e, error)
      }
      if isUsed {
        e.type_ =
          if e.patterns.isNotEmpty() {
            let result: Result<Type, ()> = findCommonType(e.patterns.map(|arm| arm.type_).toList())
            match result {
              Result::Ok(type_) => type_
              Result::Err(_) => reportError(e, 'Match arms return mixed types ' + e.patterns.map(|arm| asType(arm.type_).displayName()).join(', '))
            }
          }
          else {{
            displayName: None
            name: None
            kind: TypeKind::Struct({
              implementations: []
              kind: StructKind::Tuple({properties: []})
            })
            class: None
            instance: None
          }}
      }

      matchExpression = oldMatchExpression
    }
    visitMatchArm: |mut self, mut a: MatchArm, isUsed| {
      self.scope = createScope(context, file, self.scope)
      a.scope = self.scope

      let m = matchExpression.unwrap()

      let result: Result<(), ()> = declarePatternVariables(a.scope, self, a.pattern, false, m.expression.type_, true)
      if result.isOk() {
        let patternTy = result.value[0]

        if not isAssignable(m.expression.type_, patternTy)
          then self.reportError(a, notAssignableError(m.expression.type_, patternTy))
      }
      else {
        if result.value[0].kind == 'PatternMismatch' {
          let (pattern, to, subject) = result.value[0].value
          self.reportError(a, notAssignableError(to, subject))
        }
      }

      self.visitBlock(a.block, isUsed)
      a.type_ = a.block.type_

      self.scope = self.scope.parent
    }
    visitTypePathExpression: |self, mut e: TypePathExpression| {
      e.scope = self.scope
      let typePath = e.typePath
      if typePath.kind == '_Object' {
        let binding = e.scope.getTypeBinding(typePath.value[0].name)
        if not binding
          then self.reportError(e, 'Use of undeclared type ' + typePath.value[0].name)
        let type_: Type = binding.type_

        if typePath.value[1].kind != 'Member'
          then self.reportError(e, 'Nested type paths are not supported')

        if let TypeKind::Enum(enum_) = type_.kind {
          let memberIdentifier = typePath.value[1].value[0]
          let member: Type = enum_.members[memberIdentifier.name]
          if not member {
            reportError(memberIdentifier, type_.displayName() + ' has no member named ' + memberIdentifier.name)
          }
          else match member.kind {
            TypeKind::Struct(struct) => match struct.kind {
              StructKind::Record(record) => {
                e.type_ = {
                  displayName: type_.name.map(|name| name + '::' + memberIdentifier.name)
                  name: type_.name
                  kind: TypeKind::Function({
                    selfBinding: None
                    arguments: [{
                      name: memberIdentifier.name
                      token: memberIdentifier
                      mutable: false
                      type_: member
                      redefined: false
                    }]
                    argumentRange: {start: 1, end: 2}
                    returnType:
                      if let Option::Some(class) = type_.class
                        then createTypeInstance(type_, asIterable(class.typeParameters))
                        else type_
                    isAbstract: false
                  })
                  class: type_.class.map(|class| Object.assign({}, class, {instances: []}))
                  instance: type_.instance
                }
              }

              StructKind::Tuple(tuple) => {
                e.type_ = {
                  displayName: type_.name.map(|name| name + '::' + memberIdentifier.name)
                  name: type_.name
                  kind: TypeKind::Function({
                    selfBinding: None
                    arguments: tuple.properties.enumerate().map(|(p, i)| {{
                      name: i.toString()
                      token: memberIdentifier
                      mutable: false
                      type_: p
                      redefined: false
                    }}).toList()
                    argumentRange: {start: tuple.properties.length, end: tuple.properties.length + 1}
                    returnType:
                      if let Option::Some(class) = type_.class
                        then createTypeInstance(type_, asIterable(class.typeParameters))
                        else type_
                    isAbstract: false
                  })
                  class: type_.class.map(|class| Object.assign({}, class, {instances: []}))
                  instance: type_.instance
                }
              }

              StructKind::Unit => {
                e.type_ = {
                  displayName: type_.name.map(|name| name + '::' + memberIdentifier.name)
                  name: type_.name
                  kind: type_.kind
                  class: type_.class
                  instance: type_.instance
                }
              }
            }
            _ => {
              throw 'enum arm is not a struct'
            }
          }
        }
      }
    }
    visitUnaryExpression: |self, mut e: UnaryExpression| {
      e.scope = self.scope
      visit.walkUnaryExpression(self, e)

      e.type_ =
        if e.operator.kind == SyntaxKind.NotKeyword
          then e.scope.getTypeBinding('Bool').type_
        else if e.operator.kind == SyntaxKind.MinusToken
             or e.operator.kind == SyntaxKind.PlusToken
          then e.scope.getTypeBinding('Num').type_
    }
    visitWhileLoop: |mut self, mut e: WhileLoop| {
      self.scope = createScope(context, file, self.scope)
      e.scope = self.scope
      self.visitExpression(e.condition)
      self.visitBlock(e.body, false)
      e.type_ = Type.empty()
      self.scope = self.scope.parent
    }
    visitIndexAccess: |self, mut a: IndexAccess| {
      a.scope = self.scope
      visit.walkIndexAccess(self, a)
    }
    visitMemberAccess: |self, mut a: MemberAccess| {
      a.scope = self.scope
      visit.walkExpression(self, a.object)
      if a.object.type_ {
        if let TypeKind::Struct({kind: StructKind::Record(record)}) = a.object.type_.kind {
          a.type_ = record.properties[a.member.name]
        } else {
          // TODO: Enable this check when possible
          // reportError(a, 'can not read a property on an enum type')
        }
      }
    }

    visitBreak: |self, mut b: Token| {
      b.scope = self.scope
      visit.walkBreak(self, b)
    }
    visitReturn: |self, mut r: ReturnStatement| {
      r.scope = self.scope
      visit.walkReturn(self, r)
    }

    visitListLiteral: |self, mut l: ListLiteral| {
      l.scope = self.scope
      visit.walkListLiteral(self, l)
      if l.members.length >= 1 {
        let types = l.members.map(|m| m.type_).toList()
        let result: Result<Type, ()> = findCommonType(types)
        match result {
          Result::Ok(type_) => {
            if not type_ {
              l.type_ = self.scope.getTypeBinding('List').type_
            } else {
              l.type_ = createTypeInstance(self.scope.getTypeBinding('List').type_, asIterable([type_]))
            }
          }
          Result::Err(_) => reportError(l, 'List contains mixed types')
        }
      }
      else {
        l.type_ = self.scope.getTypeBinding('List').type_
      }
    }
    visitBooleanLiteral: |self, mut l: BooleanLiteral| {
      l.scope = self.scope
      l.type_ = self.scope.getTypeBinding('Bool').type_
      visit.walkBooleanLiteral(self, l)
    }
    visitNumberLiteral: |self, mut l: NumberLiteral| {
      l.scope = self.scope
      l.type_ = self.scope.getTypeBinding('Num').type_
      visit.walkNumberLiteral(self, l)
    }
    visitObjectLiteral: |self, mut l: ObjectLiteral| {
      l.scope = self.scope
      l.members.forEach(|m| {
        self.visitExpression(m.value)
      })
      l.type_ = {
        displayName: None
        name: None
        kind: TypeKind::Struct({
          implementations: []
          kind: StructKind::Record({
            properties: ObjectMap.fromIter(l.members.map(|m| (m.name.name, m.value.type_)))
          })
        })
        class: None
        instance: None
      }
    }
    visitStringLiteral: |self, mut l: StringLiteral| {
      l.scope = self.scope
      l.type_ = self.scope.getTypeBinding('String').type_
      visit.walkStringLiteral(self, l)
    }
    visitTupleLiteral: |self, mut l: TupleLiteral| {
      l.scope = self.scope
      visit.walkTupleLiteral(self, l)
      let properties = l.expressions.map(|e| e.type_).toList()
      l.type_ = {
        displayName: None
        name: None
        kind: TypeKind::Struct({
          implementations: []
          kind: StructKind::Tuple({
            properties
          })
        })
        class: None
        instance: None
      }
    }
  })
}
