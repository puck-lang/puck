import 'puck:js' as {Object, undefined}
import 'node:util' as {inspect}
import '../ast/ast.puck' as {
  Expression

  Block
  FunctionDeclaration
  Identifier
  ImplDeclaration
  Module
  ObjectDestructure
  TypeBound
  FunctionTypeBound
  NamedTypeBound
  TraitDeclaration
  TypeDeclaration
  TypeParameter
  TypePath
  VariableDeclaration

  ExportDirective
  ImportDirective

  Pattern

  AssignmentExpression
  BinaryExpression
  CallExpression
  ForExpression
  IfExpression
  IfLetExpression
  MatchExpression
  MatchArm
  TypePathExpression
  UnaryExpression
  WhileExpression

  IndexAccess
  MemberAccess

  Token
  ReturnStatement

  ListLiteral
  BooleanLiteral
  NumberLiteral
  ObjectLiteral
  StringLiteral
  TupleLiteral
}
import '../ast/visit.puck' as visit
import '../compiler/ast.ts' as {SyntaxKind}
import 'src/enums.puck' as {checkExhaustive}
import 'src/range.puck' as {checkRange}
import 'src/scope.puck' as {createScope}
import 'src/structure_visitor.puck' as {declarePatternVariables, notAssignableError, structureVisitor}
import 'src/types.puck' as {createTypeInstance, getType, isAssignable, isSameType, resolveTypeParameters}
import '../entities.puck' as {
  Binding
  Function
  Implementation
  Scope
  Struct
  StructKind
  Type
  TypeInstance
  TypeKind
  TypeTrait
}

fn asType(a) -> Type {a}

export fn ScopeVisitor(context, file) {
  let mut importDirective: ImportDirective
  let mut matchExpression: Option<MatchExpression> = None
  let reportError = context.reportError.bind(context, file)

  fn getBinding(token: Expression) {
    if token.kind == SyntaxKind.Identifier
      then token.scope.getBinding(token.name)
    else if token.kind == SyntaxKind.MemberAccess
      then getBinding(token.object)
    else if token.kind == SyntaxKind.IndexAccess
      then getBinding(token.object)
  }

  fn checkFunctionCall(functionType: Type, c: CallExpression) {
    if not functionType then return undefined
    let name = c.func.name or None
    let iName: Option<String> = if not name.kind
      then Some(name)
      else name
    let name = iName.unwrapOrElse(|| functionType.displayName())

    let function = match functionType.kind {
      TypeKind::Function(func) => func
      _ => reportError(c, '$name is not callable')
    }

    if let Option::Some(selfBinding) = function.selfBinding {
      if selfBinding.mutable {
        let binding = getBinding(c.func)
        if binding and not binding.mutable
          then reportError(c, '$name can only be called on a mutable binding')
      }
    }

    if let Result::Err(error) = checkRange(c.argumentList, function.argumentRange, 'arguments', name)
      then reportError(c, error)

    let function =
      if let Option::Some(class) = functionType.class {
        let mut parameterMap = ObjectMapTrait.new()

        function.arguments.forEach(|parameter: Binding, i| {
          let argument: VariableDeclaration =
            if i < c.argumentList.length
              then c.argumentList[i]
              else parameter

          if parameter.type_ and argument.type_ {
            if let TypeKind::Parameter = parameter.type_.kind {
              if parameterMap[parameter.type_.name.unwrap()] {
                let existingMapping = parameterMap[parameter.type_.name.unwrap()]
                if not isAssignable(existingMapping, argument.type_) {
                  if isAssignable(argument.type_, existingMapping) {
                    parameterMap[parameter.type_.name.unwrap()] = argument.type_
                  }
                  else reportError(argument, notAssignableError(existingMapping, argument.type_))
                }
              }
              else {
                parameterMap[parameter.type_.name.unwrap()] = argument.type_
              }
            }
          }
        })
        let resolvedFunction: Type = resolveTypeParameters(parameterMap)(functionType)

        match resolvedFunction.kind {
          TypeKind::Function(func) => func
          _ => throw 'resolved function is not a function'
        }
      }
      else function

    c.argumentList.forEach(|argument, i| {
      let parameter = function.arguments[i]

      if not isAssignable(parameter.type_, argument.type_)
        then reportError(argument, notAssignableError(parameter.type_, argument.type_))

      if parameter.mutable and argument.kind == SyntaxKind.Identifier {
        let argumentName = argument.name
        let argumentBinding = argument.scope.getBinding(argumentName)

        if not argumentBinding.mutable {
          let parameterName =
            if parameter.pattern.kind == 'Identifier'
              then parameter.pattern.value[0].name
              else i
          reportError(argument
            'Parameter $parameterName of $name requires a mutable binding ' +
            'but $argumentName is declared as immutable.'
          )
        }
      }
    })

    function
  }

  fn defineHoisted(expressions, visitor) {
    expressions.forEach(|mut e| {
      if e.kind == SyntaxKind.Function {
        e.hoisting = true
        visitor.visitFunctionDeclaration(e)
        e.hoisted = true
      }
      if e.kind == SyntaxKind.ExportDirective and
          e.expression.kind == SyntaxKind.Function {
        e.expression.hoisting = true
        visitor.visitFunctionDeclaration(e.expression)
        e.expression.hoisted = true
      }
    })
  }

  Object.assign({}, visit.walkingVisitor, structureVisitor, {
    reportError

    visitBlock: |self, mut b: Block| {
      b.scope = self.scope

      defineHoisted(b.expressions, self)

      visit.walkBlock(self, b)

      if let Option::Some(last) = b.expressions.last() {
        b.type_ = last.type_
      }
    }
    visitFunctionDeclaration: |mut self, mut f: FunctionDeclaration| {
      structureVisitor.visitFunctionDeclaration.call(self, f)

      if not f.hoisting or f.hoisted {
        self.scope = f.scope

        f.parameterList.forEach(|p| self.visitVariableDeclaration(p))
        if f.body {
          self.visitBlock(f.body)

          if let TypeKind::Function(func) = f.type_.kind {
            if func.returnType {
              if not isAssignable(func.returnType, f.body.type_)
                then reportError(f, notAssignableError(func.returnType, f.body.type_))
            }
            else {
              Object.assign(func, {
                returnType: f.body.type_
              })
            }
          }
        }

        self.scope = self.scope.parent
      }
    }
    visitIdentifier: |self, mut i: Identifier| {
      i.scope = self.scope
      let binding = i.scope.getBinding(i.name)
      if not binding
        then reportError(i, 'Use of undefined variable ' + i.name)
        else i.type_ = binding.type_
      visit.walkIdentifier(self, i)
    }
    visitImplDeclaration: |self, mut i: ImplDeclaration| {
      i.members.forEach(self.visitFunctionDeclaration.bind(self))
    }
    visitModule: |mut self, mut m: Module| {
      self.scope = m.scope

      defineHoisted(m.expressions, self)

      visit.walkModule(self, m)
    }
    visitObjectDestructure: |self, mut i: ObjectDestructure| {}
    visitTraitDeclaration: |mut self, mut t: TraitDeclaration| {
      self.scope = t.scope
      visit.walkTraitDeclaration(self, t)
      self.scope = self.scope.parent
    }
    visitTypeDeclaration: |self, mut t: TypeDeclaration| {}
    visitVariableDeclaration: |mut self, mut d: VariableDeclaration, visitInitializer, type_, allowNotExhaustive = false| {
      structureVisitor.visitVariableDeclaration.call(
        self
        d
        if visitInitializer
          then visitInitializer
          else |e| {
            let parentAssignedTo = self.assignedTo
            self.assignedTo = d
            self.visitExpression(e)
            self.assignedTo = parentAssignedTo
          }
        type_
        allowNotExhaustive
      )
    }

    visitExportDirective: |self, mut e: ExportDirective| {
      visit.walkExportDirective(self, e)
    }
    visitImportDirective: |self, mut i: ImportDirective| {}

    visitAssignmentExpression: |self, mut e: AssignmentExpression| {
      e.scope = self.scope
      visit.walkAssignmentExpression(self, e)
      let binding = getBinding(e.lhs)
      if binding {
        if not binding.mutable
          then reportError(e, "Can't assign to immutable variable " + binding.name)

        if not isAssignable(e.lhs.type_, e.rhs.type_)
          then reportError(e, notAssignableError(e.lhs.type_, e.rhs.type_))
      }

      e.type_ = e.lhs.type_ or e.rhs.type_
    }
    visitBinaryExpression: |self, mut e: BinaryExpression| {
      e.scope = self.scope
      visit.walkBinaryExpression(self, e)
    }
    visitCallExpression: |mut self, mut e: CallExpression| {
      e.scope = self.scope
      self.visitExpression(e.func)

      let mut functionType = e.func.type_

      if e.func.kind == SyntaxKind.MemberAccess and e.func.object.type_ {
        let name = e.func.member.name
        let objectType: Type = e.func.object.type_

        if let TypeKind::Trait(trait_) = objectType.kind {
          functionType = trait_.functions[name]

          if not functionType
            then reportError(e, objectType.displayName() + ' has no function named $name')

          if functionType.selfBinding
            then throw 'direct trait calls for functions with self bindings are not implemented'
        }
        else {
          fn getFunction(type_: Type) -> Function {
            match type_.kind {
              TypeKind::Function(func_) => func_
              _ => throw 'Type is not a function'
            }
          }
          fn getTrait(type_: Type) {
            match type_.kind {
              TypeKind::Trait(trait_) => trait_
              _ => throw 'Type is not a trait'
            }
          }
          fn getImplementations(type_: Type) {
            let implementations =  match type_.kind {
              TypeKind::Enum(enum_) => enum_.implementations
              TypeKind::Struct(struct) => struct.implementations
              TypeKind::Parameter => []
              _ => throw 'Not an enum or a struct'
            }

            let implementations = implementations
              .filter(|i| getTrait(i.trait_).functions[name])

            let implementations =
              if implementations.length > 1
                then implementations
                  .filter(|i| e.scope.getTypeBinding(
                    asType(i.trait_).name.unwrap()
                  ))
              else implementations

            let implementations =
              if implementations.length > 1
                then implementations
                  .filter(|i| getFunction(getTrait(i.trait_).functions[name]).argumentRange
                    .contains(e.argumentList.length)
                  )
              else implementations

            let implementations: List<Implementation> =
              if implementations.length > 1 {
                let hasInstance = implementations.find(|i: Implementation| i.trait_.instance.isJust())
                if hasInstance.isJust()
                  then implementations
                    .filter(|i: Implementation| i.trait_.instance.isJust())
                  else implementations
              }
              else implementations

            if implementations.length > 1 then reportError(e, 'Ambiguous trait call')

            if implementations.length == 0 {
              if let Option::Some(instance) = type_.instance {
                getImplementations(instance.class)
              }
              else implementations
            }
            else implementations
          }

          let implementations = getImplementations(objectType)

          if implementations.length == 1 {
            let implementation = implementations[0]
            let traitName =
              if let Option::Some(instance) = implementation.trait_.instance
                then asType(instance.class).name.unwrap()
                else asType(implementation.trait_).name.unwrap()
            if not e.scope.getTypeBinding(traitName)
              then reportError(e, 'The function $name is defined in trait $traitName but it is not in scope')

            e.traitName = traitName
            e.implementationType = implementation.type_

            functionType = getTrait(implementation.trait_).functions[name]

            if let Option::Some(instance) = objectType.instance {
              functionType = resolveTypeParameters(instance.parameterMap)(functionType)
            }
          }
        }
      }
      let parentAssignedTo = self.assignedTo
      e.argumentList.forEach(|a, i| {
        self.assignedTo = if functionType
          then if let TypeKind::Function(func) = functionType.kind then func.arguments[i]
        self.visitExpression(a)
      })
      self.assignedTo = parentAssignedTo

      if functionType {
        let function = checkFunctionCall(functionType, e)
        e.type_ = function.returnType
      }
    }
    visitForExpression: |mut self, mut e: ForExpression| {
      self.scope = createScope(context, file, self.scope)
      e.scope = self.scope
      visit.walkForExpression(self, e)
      self.scope = self.scope.parent
    }
    visitIfExpression: |mut self, mut e: IfExpression| {
      self.scope = createScope(context, file, self.scope)
      e.scope = self.scope
      visit.walkIfExpression(self, e)
      self.scope = self.scope.parent
    }
    visitIfLetExpression: |mut self, mut e: IfLetExpression| {
      self.scope = createScope(context, file, self.scope)
      e.scope = self.scope
      self.visitVariableDeclaration(e.variableDeclaration, undefined, undefined, true)
      self.visitBlock(e.then_)
      if let Option::Some(else_) = e.else_ then self.visitBlock(else_)
      self.scope = self.scope.parent
    }
    visitMatchExpression: |mut self, mut e: MatchExpression| {
      e.scope = self.scope
      let oldMatchExpression = matchExpression
      matchExpression = Some(e)

      self.visitExpression(e.expression)
      e.type_ = e.expression.type_

      e.patterns.forEach(|a| self.visitMatchArm(a))

      if let Result::Err(error) = checkExhaustive(e) {
        self.reportError(e, error)
      }
      e.type_ = undefined

      matchExpression = oldMatchExpression
    }
    visitMatchArm: |mut self, mut a: MatchArm| {
      self.scope = createScope(context, file, self.scope)
      a.scope = self.scope

      let m = matchExpression.unwrap()

      let result: Result<(), ()> = declarePatternVariables(a.scope, self, a.pattern, false, m.type_, true)
      if result.isOk() {
        let patternTy = result.value[0]

        if not isAssignable(m.type_, patternTy)
          then self.reportError(a, notAssignableError(m.type_, patternTy))
      }
      else {
        if result.value[0].kind == 'PatternMismatch' {
          let (pattern, to, subject) = result.value[0].value
          self.reportError(a, notAssignableError(to, subject))
        }
      }

      self.visitBlock(a.block)

      self.scope = self.scope.parent
    }
    visitTypePathExpression: |self, mut e: TypePathExpression| {
      e.scope = self.scope
      let typePath = e.typePath
      if typePath.kind == '_Object' {
        let binding = e.scope.getTypeBinding(typePath.value[0].name)
        if not binding
          then self.reportError(e, 'Use of undeclared type ' + typePath.value[0].name)
        let type_: Type = binding.type_

        if typePath.value[1].kind != 'Member'
          then self.reportError(e, 'Nested type paths are not supported')

        if let TypeKind::Enum(enum_) = type_.kind {
          let memberIdentifier = typePath.value[1].value[0]
          let member: Type = enum_.members[memberIdentifier.name]
          if not member {
            reportError(memberIdentifier, type_.displayName() + ' has no member named ' + memberIdentifier.name)
          }
          else match member.kind {
            TypeKind::Struct(struct) => match struct.kind {
              StructKind::Record(record) => {
                e.type_ = {
                  displayName: type_.name.map(|name| name + '::' + memberIdentifier.name)
                  name: type_.name
                  kind: TypeKind::Function({
                    selfBinding: None
                    arguments: [{
                      name: memberIdentifier.name
                      token: memberIdentifier
                      mutable: false
                      type_: member
                      redefined: false
                    }]
                    argumentRange: {start: 1, end: 2}
                    returnType: type_
                    isAbstract: false
                  })
                  class: type_.class
                  instance: type_.instance
                }
              }

              StructKind::Tuple(tuple) => {
                e.type_ = {
                  displayName: type_.name.map(|name| name + '::' + memberIdentifier.name)
                  name: type_.name
                  kind: TypeKind::Function({
                    selfBinding: None
                    arguments: tuple.properties.enumerate().map(|(p, i)| {{
                      name: i.toString()
                      token: memberIdentifier
                      mutable: false
                      type_: p
                      redefined: false
                    }})
                    argumentRange: {start: tuple.properties.length, end: tuple.properties.length + 1}
                    returnType: type_
                    isAbstract: false
                  })
                  class: type_.class
                  instance: type_.instance
                }
              }

              StructKind::Unit => {
                e.type_ = {
                  displayName: type_.name.map(|name| name + '::' + memberIdentifier.name)
                  name: type_.name
                  kind: type_.kind
                  class: type_.class
                  instance: type_.instance
                }
              }
            }
            _ => {
              throw 'enum arm is not a struct'
            }
          }
        }
      }
    }
    visitUnaryExpression: |self, mut e: UnaryExpression| {
      e.scope = self.scope
      visit.walkUnaryExpression(self, e)

      e.type_ =
        if e.operator.kind == SyntaxKind.NotKeyword
          then e.scope.getTypeBinding('Bool').type_
        else if e.operator.kind == SyntaxKind.MinusToken
             or e.operator.kind == SyntaxKind.PlusToken
          then e.scope.getTypeBinding('Num').type_
    }
    visitWhileExpression: |mut self, mut e: WhileExpression| {
      self.scope = createScope(context, file, self.scope)
      e.scope = self.scope
      visit.walkWhileExpression(self, e)
      self.scope = self.scope.parent
    }
    visitIndexAccess: |self, mut a: IndexAccess| {
      a.scope = self.scope
      visit.walkIndexAccess(self, a)
    }
    visitMemberAccess: |self, mut a: MemberAccess| {
      a.scope = self.scope
      visit.walkExpression(self, a.object)
      if a.object.type_ {
        if let TypeKind::Struct({kind: StructKind::Record(record)}) = a.object.type_.kind {
          a.type_ = record.properties[a.member.name]
        } else {
          // TODO: Enable this check when possible
          // reportError(a, 'can not read a property on an enum type')
        }
      }
    }

    visitBreak: |self, mut b: Token| {
      b.scope = self.scope
      visit.walkBreak(self, b)
    }
    visitReturn: |self, mut r: ReturnStatement| {
      r.scope = self.scope
      visit.walkReturn(self, r)
    }

    visitListLiteral: |self, mut l: ListLiteral| {
      l.scope = self.scope
      l.type_ = self.scope.getTypeBinding('List').type_
      visit.walkListLiteral(self, l)
    }
    visitBooleanLiteral: |self, mut l: BooleanLiteral| {
      l.scope = self.scope
      l.type_ = self.scope.getTypeBinding('Bool').type_
      visit.walkBooleanLiteral(self, l)
    }
    visitNumberLiteral: |self, mut l: NumberLiteral| {
      l.scope = self.scope
      l.type_ = self.scope.getTypeBinding('Num').type_
      visit.walkNumberLiteral(self, l)
    }
    visitObjectLiteral: |self, mut l: ObjectLiteral| {
      l.scope = self.scope
      l.members.forEach(|m| {
        self.visitExpression(m.value)
      })
    }
    visitStringLiteral: |self, mut l: StringLiteral| {
      l.scope = self.scope
      l.type_ = self.scope.getTypeBinding('String').type_
      visit.walkStringLiteral(self, l)
    }
    visitTupleLiteral: |self, mut l: TupleLiteral| {
      l.scope = self.scope
      visit.walkTupleLiteral(self, l)
      let properties = l.expressions.map(|e| e.type_)
      l.type_ = {
        displayName: None
        name: None
        kind: TypeKind::Struct({
          implementations: []
          kind: StructKind::Tuple({
            properties
          })
        })
        class: None
        instance: None
      }
    }
  })
}
