import 'puck:js' as {undefined}
import '../../ast/ast.puck' as {FunctionDeclaration, VariableDeclaration, TypeBound, TypeParameter}
import '../../ast/span.puck' as {ToSpan}
import '../../entities.puck' as {Function, Type, TypeKind}
import 'range.puck' as {checkRange, getRange}
import 'scope.puck' as {Binding, Scope}
import 'types.puck' as {isAssignable}

export fn createFunctionType(scope: Scope, f: FunctionDeclaration, reportError: (ToSpan, String) -> {}) -> Type {
  let class =
    if f.typeParameters.length {
      Some({
        parameterRange: getRange(
          f.typeParameters
          |p: TypeParameter| p.defaultValue.isSome()
          reportError
          'type parameter'
        )
        instances: []
        typeParameters: f.typeParameters.map(|p| p.type_).toList()
      })
    }
    else None

  let parameters = f.parameterList.map(|p| {{
    pattern: p.pattern
    mutable: p.mutable
    type_: p.type_
    token: p
  }}).toList()
  let returnType: Type =
    if let Option::Some(returnType) = f.returnType {
      returnType.getType()
    }
    else undefined
  let selfBinding: Option<Binding> =
    if parameters.length > 0 and parameters[0].pattern.kind == 'Identifier' and parameters[0].pattern.value[0].name == 'self'
      then Some(parameters[0].pattern.binding)
      else None
  let parameters =
    if selfBinding.isSome()
      then parameters.slice(1)
      else parameters

  {
    id: None
    displayName: None
    name: f.name.map(|identifier| identifier.name)
    kind: TypeKind::Function({
      selfBinding
      parameters
      parameterRange:
        if f.parameterList
          then getRange(
            parameters
            |p| {
              let vd: VariableDeclaration = p.token
              vd.initializer.isSome()
            }
            reportError
            'parameter'
          )
          else {{start: 0, end: 1}}
      returnType
      isAbstract: f.body.isNone()
    })
    class
    instance: None
    providesType: None
    enumMember: None
  }
}

export fn checkFunctionAssignability(functionName: String, to: Function, subject: Function) -> Result<(), String> {
  if let Result::Err(error) = checkRange(subject.parameters, to.parameterRange, 'arguments', functionName)
    then return Err(error)

  let mut errors = []
  subject.parameters.enumerate().forEach(|(subjectParameter, i): (Binding, Num)| {
    let toParameter: Binding = to.parameters[i]

    if not isAssignable(toParameter.type_, subjectParameter.type_)
      then errors.push(
        'Types of parameter #$i does not match. ' + subjectParameter.type_.displayName() +
        ' is not assignable to ' + toParameter.type_.displayName()
      )
    else if subjectParameter.mutable and not toParameter.mutable
      then errors.push('Parameter #$i is required to be immutable')
  })
  if errors.length > 0
    then return Err(errors[0])


  if not isAssignable(to.returnType, subject.returnType)
    then Err('Return type ' + subject.returnType.displayName() + ' is not assignable to ' + to.returnType.displayName())
    else Ok(())
}

export fn resolveFunctionTypeParameters(mut parameterMap: ObjectMap<Type>, typeParameters: List<Type>, parameterType: Type, argumentType: Type) {
  match parameterType.kind {
    TypeKind::Parameter(_) => {
      let name = parameterType.name.unwrap()
      if typeParameters.any(|p| p.name.unwrap() == name) {
        if not parameterMap.has(name) {
          parameterMap[name] = argumentType
        }
      }
    }
    TypeKind::Function(parameterFunction) => {
      if parameterFunction.returnType {
        if let TypeKind::Function(argumentFunction) = argumentType.kind {
          if argumentFunction.returnType {
            resolveFunctionTypeParameters(parameterMap, typeParameters, parameterFunction.returnType, argumentFunction.returnType)
          }
        }
      }
    }
    _ => ()
  }
}
