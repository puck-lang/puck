import 'puck:js' as {undefined}
import '../../ast/ast.puck' as {
  FunctionDeclaration
  VariableDeclaration
  Pattern
  TypeBound
  TypeParameter
}
import '../../ast/span.puck' as {ToSpan}
import '../../entities.puck' as {Function, StructKind, Type, TypeKind}
import 'range.puck' as {checkRange, getRange}
import 'scope.puck' as {Binding, Scope}
import 'types.puck' as {isAssignable}

fn getPatternName(pattern: Pattern) -> Option<String> {
  match pattern {
    Pattern::Identifier(i) => Some(i.name)
    _ => None
  }
}

export fn createFunctionType(scope: Scope, f: FunctionDeclaration, reportError: (ToSpan, String) -> ()) -> Type {
  let class =
    if f.typeParameters.size() {
      Some({
        parameterRange: getRange(
          f.typeParameters
          |p| p.defaultValue.isSome()
          reportError
          'type parameter'
        )
        instances: []
        typeParameters: f.typeParameters.map(|p| p->type_.transmute()).toList()
      })
    }
    else None

  let parameters: List<Binding> = f.parameterList
    .enumerate()
    .map(|(i, p)| {{
      name: getPatternName(p.pattern).unwrapOr('p$i')
      token: p
      mutable: p.mutable
      allowRedeclare: true
      type_: p->type_.transmute()
      previous: None
      completeType: None
    }})
    .toList()
  let returnType: Type =
    if let Option::Some(returnType) = f.returnType {
      returnType.getType()
    }
    else undefined
  let selfBinding =
    parameters.first().andThen(|b| {
      if b.name == 'self'
        then Some(b)
        else None
    })
  let parameters: List<Binding> =
    if selfBinding.isSome()
      then parameters.skip(1).toList()
      else parameters

  {
    id: None
    displayName: None
    name: f.name.map(|identifier| identifier.name)
    kind: TypeKind::Function({
      selfBinding
      parameters
      parameterRange:
        if f.parameterList
          then getRange(
            parameters
            |p| {
              let vd: VariableDeclaration = p->token.transmute()
              vd.initializer.isSome()
            }
            reportError
            'parameter'
          )
          else {{start: 0, end: 1}}
      returnType
      isAbstract: f.body.isNone()
    })
    class
    instance: None
    providesType: None
    enumMember: None
  }
}

export fn checkFunctionAssignability(functionName: String, to: Function, subject: Function) -> Result<(), String> {
  if let Result::Err(error) = checkRange(subject.parameters, to.parameterRange, 'arguments', functionName)
    then return Err(error)

  let mut errors = []
  subject.parameters.enumerate().forEach(|(i, subjectParameter)| {
    let toParameter: Binding = to.parameters[i]

    if not isAssignable(toParameter.type_, subjectParameter.type_)
      then errors.push(
        'Types of parameter #$i does not match. ' + subjectParameter.type_.displayName() +
        ' is not assignable to ' + toParameter.type_.displayName()
      )
    else if subjectParameter.mutable and not toParameter.mutable
      then errors.push('Parameter #$i is required to be immutable')
  })
  if errors.size() > 0
    then return Err(errors[0])

  if not isAssignable(to.returnType, subject.returnType)
    then Err('Return type ' + subject.returnType.displayName() + ' is not assignable to ' + to.returnType.displayName())
    else Ok(())
}

export fn resolveFunctionTypeParameters(mut parameterMap: ObjectMap<Type>, typeParameters: List<Type>, parameterType: Type, argumentType: Type, allowedToFollowFunction = true) {
  if not parameterType or not argumentType or argumentType.isNever() then return ()
  match parameterType.kind {
    TypeKind::Parameter(_) => {
      let name = parameterType.name.unwrap()
      if typeParameters.any(|p| p.name.unwrap() == name) {
        if not parameterMap.has(name) {
          parameterMap[name] = argumentType
        }
      }
    }
    TypeKind::Struct(struct) => {
      if not parameterType.id.isSome() {
        match struct.kind {
          StructKind::Record(parameterRecord) => {
            if let TypeKind::Struct({kind: StructKind::Record(argumentRecord)}) = argumentType.kind {
              parameterRecord.properties.forEach(|(name, parameterType)| {
                if let Some(argumentType) = argumentRecord.properties.get(name) {
                  resolveFunctionTypeParameters(
                    parameterMap
                    typeParameters
                    parameterType
                    argumentType
                  )
                }
              })
            }
          }
          StructKind::Tuple(parameterTuple) => {
            if let TypeKind::Struct({kind: StructKind::Tuple(argumentTuple)}) = argumentType.kind {
              parameterTuple.properties.enumerate().forEach(|(i, parameterType)| {
                if let Some(argumentType) = argumentTuple.properties.get(i) {
                  resolveFunctionTypeParameters(
                    parameterMap
                    typeParameters
                    parameterType
                    argumentType
                  )
                }
              })
            }
          }
          _ => {}
        }
      }
    }
    TypeKind::Function(parameterFunction) => {
      if allowedToFollowFunction and parameterFunction.returnType {
        if let TypeKind::Function(argumentFunction) = argumentType.kind {
          if argumentFunction.returnType {
            resolveFunctionTypeParameters(
              parameterMap
              typeParameters
              parameterFunction.returnType
              argumentFunction.returnType
            )
          }
        }
      }
    }
    _ => {}
  }

  match (parameterType.typeParameters(), argumentType.typeParameters()) {
    (Some(parameterParameters), Some(argumentParameters)) => {
      parameterParameters.enumerate().forEach(|(i, parameterType)| {
        if let Some(argumentType) = argumentParameters.get(i) {
          resolveFunctionTypeParameters(
            parameterMap
            typeParameters
            parameterType
            argumentType
            false
          )
        }
      })
    }
    _ => {}
  }
}
