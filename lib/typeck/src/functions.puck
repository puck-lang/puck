import '../../ast/ast.puck' as {FunctionDeclaration, VariableDeclaration, TypeParameter}
import '../../entities.puck' as {Binding, Function, Scope, Type, TypeKind}
import 'range.puck' as {checkRange, getRange}
import 'types.puck' as {getType, isAssignable}

export fn createFunctionType(scope: Scope, f: FunctionDeclaration, reportError) -> Type {
  let class =
    if f.typeParameters.length {
      Some({
        parameterRange: getRange(
          f.typeParameters
          |p: TypeParameter| p.defaultValue.isSome()
          reportError
          'type parameter'
        )
        instances: []
        typeParameters: f.typeParameters.map(|p| p.type_).toList()
      })
    }
    else None

  let arguments = f.parameterList.map(|p| {{
    pattern: p.pattern
    mutable: p.mutable
    type_: p.type_
    token: p
  }}).toList()
  let returnType: Type =
    if let Option::Some(returnType) = f.returnType {
      returnType.type_
    }
  let selfBinding: Option<Binding> =
    if arguments.length > 0 and arguments[0].pattern.kind == 'Identifier' and arguments[0].pattern.value[0].name == 'self'
      then Some(arguments[0].pattern.binding)
      else None
  let arguments =
    if selfBinding.isSome()
      then arguments.slice(1)
      else arguments

  {
    displayName: None
    name: f.name.map(|identifier| identifier.name)
    kind: TypeKind::Function({
      selfBinding
      arguments
      argumentRange:
        if f.parameterList
          then getRange(
            arguments
            |p| {
              let vd: VariableDeclaration = p.token
              vd.initializer.isSome()
            }
            reportError
            'parameter'
          )
          else {{start: 0, end: 1}}
      returnType
      isAbstract: f.body.isNone()
    })
    class
    instance: None
  }
}

export fn checkFunctionAssignability(functionName: String, to: Function, subject: Function) -> Result<(), String> {
  if let Result::Err(error) = checkRange(subject.arguments, to.argumentRange, 'arguments', functionName)
    then return Err(error)

  let mut errors = []
  subject.arguments.enumerate().forEach(|(subjectArgument, i): (Binding, Num)| {
    let toArgument: Binding = to.arguments[i]

    if not isAssignable(toArgument.type_, subjectArgument.type_)
      then errors.push(
        'Types of parameter #$i does not match. ' + subjectArgument.type_.displayName() +
        ' is not assignable to ' + toArgument.type_.displayName()
      )
    else if subjectArgument.mutable and not toArgument.mutable
      then errors.push('Parameter #$i is required to be immutable')
  })
  if errors.length > 0
    then return Err(errors[0])


  if not isAssignable(to.returnType, subject.returnType)
    then Err('Return type ' + subject.returnType.displayName() + ' is not assignable to ' + to.returnType.displayName())
    else Ok(())
}

export fn resolveFunctionTypeParameters(mut parameterMap: ObjectMap<Type>, typeParameters: List<Type>, parameterType: Type, argumentType: Type) {
  match parameterType.kind {
    TypeKind::Parameter(_) => {
      let name = parameterType.name.unwrap()
      if typeParameters.any(|p| p.name.unwrap() == name) {
        if not parameterMap.has(name) {
          parameterMap[name] = argumentType
        }
      }
    }
    TypeKind::Function(parameterFunction) => {
      if parameterFunction.returnType {
        if let TypeKind::Function(argumentFunction) = argumentType.kind {
          if argumentFunction.returnType {
            resolveFunctionTypeParameters(parameterMap, typeParameters, parameterFunction.returnType, argumentFunction.returnType)
          }
        }
      }
    }
    _ => ()
  }
}
