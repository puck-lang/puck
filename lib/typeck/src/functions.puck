import '../../ast/ast.puck' as {FunctionDeclaration, VariableDeclaration, TypeParameter}
import '../../entities.puck' as {FunctionType, Scope, TypeInstance}
import 'range.puck' as {checkRange, getRange}
import 'types.puck' as {getType, isAssignable}

export fn getFunctionTypeName(arguments: List<TypeInstance>, returnType: TypeInstance)
  then getTupleTypeName(arguments) + ' => ' + (returnType and returnType.name or '??')

export fn getTupleTypeName(properties: List<TypeInstance>)
  then '(' + properties.map(|a| (a and a.name) or '??').join(', ') + ')'

export fn createFunctionType(scope: Scope, f: FunctionDeclaration, reportError) {
  let mut parameterRange
  let mut instances
  let mut typeParameters

  if f.typeParameters and f.typeParameters.length {
    parameterRange = getRange(f.typeParameters, |p: TypeParameter| p.defaultValue.isJust(), reportError, 'type parameter')
    instances = []
    typeParameters = f.typeParameters
  }

  let arguments = f.parameterList.map(|p| {{
    pattern: p.pattern
    mutable: p.mutable
    type_: p.type_
    token: p
  }})
  let returnType = if let Maybe::Just(returnType) = f.returnType then getType(scope, returnType)
  let selfBinding =
    if arguments.length > 0 and arguments[0].pattern.kind == 'Identifier' and arguments[0].pattern.value[0].name == 'self'
      then arguments[0].pattern.binding
  let arguments =
    if selfBinding
      then arguments.slice(1)
      else arguments

  {
    kind: 'Function'
    name: f.name.mapOrElse(|| getFunctionTypeName(arguments, returnType), |ident| ident.name)
    parameterRange
    selfBinding
    arguments
    argumentRange: if f.parameterList
      then getRange(
        arguments
        |p| {
          let vd: VariableDeclaration = p.token
          vd.initializer.isJust()
        }
        reportError
        'parameter'
      )
      else {{start: 0, end: 1}}
    returnType
    isAbstract: not f.body
  }
}

export fn checkFunctionAssignability(to: FunctionType, subject: FunctionType, token): Result<(), String> {
  if let Result::Err(error) = checkRange(subject.arguments, to.argumentRange, 'arguments', subject.name)
    then return Err(error)

  let mut errors = []
  subject.arguments.forEach(|subjectArgument, i| {
    let toArgument = to.arguments[i]

    if not isAssignable(toArgument.type_, subjectArgument.type_)
      then errors.push(
        'Types of parameter #$i does not match. ' + subjectArgument.type_.name +
        ' is not assignable to ' + toArgument.type_.name
      )
    else if subjectArgument.mutable and not toArgument.mutable
      then errors.push('Parameter #$i is required to be immutable')
  })
  if errors.length > 0
    then return Err(errors[0])

  if not isAssignable(to.returnType, subject.returnType)
    then Err('Return type ' + subject.returnType.name + ' is not assignable to ' + to.returnType.name)
    else Ok(())
}
