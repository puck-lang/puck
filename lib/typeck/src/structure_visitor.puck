import 'puck:js' as {Error, Object, undefined}
import 'node:util' as {inspect}
import '../../ast/ast.puck' as {
  Expression

  FunctionDeclaration
  Identifier
  TypeParameter
  TypePath
  VariableDeclaration

  Pattern

  TypeBound
  FunctionTypeBound
  NamedTypeBound
  RecordTypeBound
  TupleTypeBound

  BooleanLiteral
  ListLiteral
  NumberLiteral
  RecordLiteral
  StringLiteral
  TupleLiteral
}
import '../../ast/span.puck' as {ToSpan}
import '../../ast/visit.puck' as visit
import '../../compiler/ast.ts' as {SyntaxKind}
import '../../entities.puck' as {
  Enum
  Scope
  StructKind
  Type
  TypeClass
  TypeKind
}
import 'enums.puck' as {getEnumMember}
import 'functions.puck' as {createFunctionType}
import 'range.puck' as {checkRange}
import 'types.puck' as {createTypeInstance, isAssignable}

export fn notAssignableError(to: Type, subject: Type) {
  subject.displayName() + ' is not assignable to type ' + to.displayName()
}

export fn structureVisitor(reportError: (ToSpan, String) -> {}) {{
  visitEnumMember: visit.walkingVisitor.visitEnumMember
  visitFunctionDeclaration: |mut self, mut f: FunctionDeclaration| {
    if not f.scope {
      self.scope = self.scope.createChild()
      f.scope = self.scope

      let assignedTo =
        if self.assignedTo and self.assignedTo.type_ then
          if let TypeKind::Function(func) = self.assignedTo.type_.kind
            then func

      f.typeParameters.forEach(self.visitTypeParameter.bind(self))
      f.parameterList.enumerate().forEach(|(p, i)| {
        let type_ =
          if assignedTo and assignedTo.parameters[i] then assignedTo.parameters[i].type_
        self.visitVariableDeclaration(p, undefined, type_)
      })
      if let Option::Some(returnType) = f.returnType then self.visitTypeBound(returnType)

      f.type_ = createFunctionType(f.scope, f, reportError)
      if let Option::Some(name) = f.name then
        f.scope.parent.define({
          name: name.name
          token: f
          mutable: false
          type_: f.type_
        })

      self.scope = f.scope.parent
    }
  }
  visitMethodDeclaration: |mut self, mut f: FunctionDeclaration, selfType: Type| {
    if not f.scope {
      self.scope = self.scope.createChild()
      f.scope = self.scope

      f.typeParameters.forEach(self.visitTypeParameter.bind(self))

      if let Option::Some(first) = f.parameterList.first() {
        if let Pattern::Identifier({name, span}) = first.pattern {
          if name == 'self' {
            let selfTypeBound: Option<TypeBound> = first.typeBound
            if selfTypeBound.isNone() {
              f.parameterList[0].typeBound = Some(TypeBound::NamedTypeBound({
                path: TypePath::Member({name: 'Self', span})
                typeParameters: []
              }))
            }
            else {
              self.visitVariableDeclaration(first)
              if not isAssignable(first.type_, selfType)
                then reportError(first, notAssignableError(first.type_, selfType))
            }
          }
        }
      }

      f.parameterList.forEach(|p| self.visitVariableDeclaration(p))
      if let Option::Some(returnType) = f.returnType then self.visitTypeBound(returnType)

      f.type_ = createFunctionType(f.scope, f, reportError)

      self.scope = f.scope.parent
    }
  }
  // visitFunctionParameter: |self, mut v: VariableDeclaration, type_| {
  //   self.visitVariableDeclaration(v, self.visitLiteral.bind(self), type_)
  // }
  visitTypeBound: |self, mut t: TypeBound| {
    visit.walkTypeBound(self, t)
  }
  visitFunctionTypeBound: |mut self, mut t: FunctionTypeBound| {
    if not t.scope {
      self.scope = self.scope.createChild()
      t.scope = self.scope

      visit.walkFunctionTypeBound(self, t)
      let parameters = t.parameters.properties
        .enumerate()
        .map(|(t, i): (TypeBound, Num)| {{
          name: '$i'
          mutable: false
          type_: t.getType()
        }})
        .toList()

      t.type_ = {
        displayName: None
        name: None
        kind: TypeKind::Function({
          selfBinding: None
          parameters
          parameterRange: {start: parameters.length, end: parameters.length + 1}
          returnType: t.returnType.getType()
          isAbstract: false
        })
        class: TypeClass.fromAstNode(t, reportError)
        instance: None
      }

      self.scope = self.scope.parent
    }
  }
  visitNamedTypeBound: |self, mut t: NamedTypeBound| {
    if not t.scope {
      t.scope = self.scope

      self.visitTypePath(t.path)
      let type_: Type = t.path.type_

      let isSelf =
        if let TypePath::Member({name}) = t.path {
          if name == 'Self' {
            if t.typeParameters.length > 0
              then reportError(t, 'Self is not generic')

            if let Option::Some(class) = type_.class {
              t.typeParameters = class.typeParameterBindings.map(|{name}| TypeBound::NamedTypeBound({
                kind: SyntaxKind.NamedTypeBound
                path: TypePath::Member(name)
                typeParameters: []
              }))
            }
            true
          }
          else false
        }
        else false

      if not isSelf {
        if let Option::Some(class) = type_.class {
          if let Result::Err(error) =
            checkRange(t.typeParameters, class.parameterRange, 'type parameters', type_.displayName()) {
            reportError(t, error)
          }
        }
        else if t.typeParameters.length > 0
          then reportError(t, 'Type ' + type_.displayName() + ' is not generic')
      }

      visit.walkNamedTypeBound(self, t)

      t.type_ =
        if type_.class.isSome()
          then createTypeInstance(type_, t.typeParameters.map(|typeBound| typeBound.getType()))
          else type_
    }
  }
  visitRecordTypeBound: |self, mut t: RecordTypeBound| {
    if not t.scope {
      t.scope = self.scope

      visit.walkRecordTypeBound(self, t)

      t.type_ = {
        displayName: None
        name: None
        kind: TypeKind::Struct({
          implementations: []
          kind: StructKind::Record({
            properties: ObjectMap.fromIter(t.properties.map(|member| (
              member.name.name
              member.typeBound.getType()
            )))
          })
        })
        class: None
        instance: None
      }
    }
  }
  visitRecordTypeBoundMember: visit.walkingVisitor.visitRecordTypeBoundMember,
  visitTupleTypeBound: |self, mut t: TupleTypeBound| {
    if not t.scope {
      t.scope = self.scope

      visit.walkTupleTypeBound(self, t)

      t.type_ = {
        displayName: None
        name: None
        kind: TypeKind::Struct({
          implementations: []
          kind: StructKind::Tuple({properties: t.properties.map(|p| p.getType()).toList()})
        })
        class: None
        instance: None
      }
    }
  }
  visitTypeParameter: |self, mut t: TypeParameter| {
    if not t.scope {
      t.scope = self.scope
      visit.walkTypeParameter(self, t)
      t.type_ = {
        displayName: None
        name: Some(t.name.name)
        kind: TypeKind::Parameter({
          defaultValue: t.defaultValue.map(|typeBound| typeBound.getType())
        })
        class: TypeClass.fromAstNode(t, reportError)
        instance: None
      }
      self.scope.defineType(t.type_, t)
    }
  }
  visitTypePath: |self, mut t: TypePath| {
    if not t.type_ {
      t.scope = self.scope
      let result: Result<{name: String, type_: Type}, String> = self.scope.getTypePath(t)
      match result {
        Result::Ok(binding) => t.type_= binding.type_
        Result::Err(err) => reportError(t, err)
      }
    }
  }
  visitVariableDeclaration: |self, mut d: VariableDeclaration, visitInitializer, type_, allowNotExhaustive = false| {
    if d.scope then return undefined
    d.scope = self.scope
    d.type_ = d.typeBound.mapOr(type_, |bound| {
      self.visitTypeBound(bound)
      bound.getType() or type_
    })

    let mut patternType = None

    match declarePatternVariables(d.scope, self, d.pattern, d.mutable, d.type_, allowNotExhaustive) {
      Result::Ok(patternTy) => {
        patternType = Some(patternTy)
        if not isAssignable(patternTy, d.type_)
          then reportError(d, notAssignableError(patternTy, d.type_))
      }
      Result::Err(PatternError::PatternMismatch(_, to, subject)) => {
        reportError(d, notAssignableError(to, subject))
      }
      Result::Err(PatternError::NotExhaustive) => {
        reportError(d, 'non exhaustive pattern')
      }
    }

    if let Option::Some(initializer) = d.initializer {
      visitInitializer(initializer)
      let initializerType = initializer.getType()
      if not d.type_ and d.pattern.binding {
        d.pattern.binding.type_ = initializerType
        d.type_ = initializerType
      }
      else if not isAssignable(d.type_, initializerType)
        then reportError(d, notAssignableError(d.type_, initializerType))
      else if let Option::Some(patternTy) = patternType {
        let patternTy: Type = patternTy
        if not isAssignable(patternTy, initializerType)
          then reportError(d, notAssignableError(patternTy, initializerType))
      }
    }
    ()
  }
}}

export enum PatternError {
  PatternMismatch(Pattern, Type, Type)
  NotExhaustive
}

export fn declarePatternVariables(scope: Scope, visitor, mut p: Pattern, mutable: Bool, type_: Type, allowNotExhaustive: Bool) ->
    Result<Type, PatternError> {
  match p {
    Pattern::CatchAll => Ok(false)
    Pattern::Identifier(identifier) => {
      p.binding = scope.define({
        name: identifier.name
        mutable
        token: p
        type_
      }, true)
      Ok(false)
    }
    Pattern::Record(record) => {
      let props =
        if type_
          then match type_.kind {
            TypeKind::Struct(struct) => match struct.kind {
              StructKind::Record(record) => record.properties
              _ => throw 'bad type'
            }
            TypeKind::Parameter => {{}}
            _ => {
              throw 'abd type'
            }
          }
          else ObjectMap.new()

      let properties: Result<ObjectMap<Type>, PatternError> = record.properties
        .map(|mut p| (p.property.name, declarePatternVariables(scope, visitor, p.pattern, mutable, props[p.property.name], allowNotExhaustive)))
        .reduce(|acc: Result<ObjectMap<Type>, PatternError>, (name, type_): (String, Result<Type, PatternError>)| {
          acc.andThen(|props| type_.map(|prop| {
            let mut newProps = Object.assign({}, props)
            newProps[name] = prop
            newProps
          }))
        }, Ok(ObjectMap.new()))

      properties.map(|_| false)
    }
    Pattern::RecordType(typePath, record) => {
      visitor.visitTypePath(typePath)

      let enumType: Option<Type> =
        match typePath {
          TypePath::Member(_) => None
          TypePath::Object({name}, _) => {
            let type_ = scope.getTypeBinding(name).type_
            if type_.isEnum()
              then Some(type_)
              else None
          }
        }

      let recordType: Type =
        if type_
          then type_
          else typePath.type_
      let recordType: Type = match recordType.kind {
        TypeKind::Enum(enum_) => {
          let member = getEnumMember(typePath)
          let enumArmType = enum_.members[member]
          enumArmType
        }
        _ => recordType
      }
      let props = match recordType.kind {
        TypeKind::Struct(struct) => match struct.kind {
          StructKind::Record(record) => record.properties
          _ => throw 'bad type'
        }
        TypeKind::Parameter => {{}}
        _ => {
          throw 'abd type'
        }
      }

      let properties: Result<ObjectMap<Type>, PatternError> = record.properties
        .toList()
        .map(|mut p| (p.property.name, declarePatternVariables(scope, visitor, p.pattern, mutable, props[p.property.name], allowNotExhaustive)))
        .reduce(|acc: Result<ObjectMap<Type>, PatternError>, (name, type_): (String, Result<Type, PatternError>)| {
          acc.andThen(|props| type_.map(|prop| {
            let mut newProps = Object.assign({}, props)
            newProps[name] = prop
            newProps
          }))
        }, Ok(ObjectMap.new()))

      // properties.map(|_| typePath.type_)

      properties.andThen(|properties| {
        let type_ = {
          displayName: None
          name: None
          kind: TypeKind::Struct({
            implementations: []
            kind: StructKind::Record({
              properties
            })
          })
          class: None
          instance: None
        }

        if let Option::Some(enumType) = enumType {
          if not allowNotExhaustive and enumType.getEnum().members.size() > 1
            then Err(PatternError::NotExhaustive)
            else {
              let member = getEnumMember(typePath)
              let enumArmType = enumType.getEnum().members[member]

              if isAssignable(enumArmType, type_)
                then Ok(enumType)
                else Err(PatternError::PatternMismatch(p, enumArmType, type_))
            }
        } else {
          if isAssignable(typePath.type_, type_)
            then Ok(typePath.type_)
            else Err(PatternError::PatternMismatch(p, typePath.type_, type_))
        }
      })
    }
    Pattern::Tuple(tuple) => {
      let props =
        if type_
          then match type_.kind {
            TypeKind::Struct(struct) => {
              match struct.kind {
                StructKind::Tuple(tuple) => tuple.properties
                _ => return Err(PatternError::PatternMismatch(p, p.type_, type_))
              }
            }
            TypeKind::Parameter => []
            _ => return Err(PatternError::PatternMismatch(p, p.type_, type_))
          }
          else []

      let properties: Result<List<Type>, PatternError> = tuple.properties
        .enumerate()
        .map(|mut (p, i)| declarePatternVariables(scope, visitor, p, mutable, props[i], allowNotExhaustive))
        .toList()
        .reduce(|acc: Result<List<Type>, PatternError>, cur: Result<Type, PatternError>| {
          acc.andThen(|props| cur.map(|prop| props.concat(prop)))
        }, Ok([]))

      properties.map(|properties| {{
        displayName: None
        name: None
        kind: TypeKind::Struct({
          implementations: []
          kind: StructKind::Tuple({
            properties
          })
        })
        class: None
        instance: None
      }})
    }
    Pattern::TupleType(typePath, tuple) => {
      visitor.visitTypePath(typePath)

      let enumType: Option<Type> =
        match typePath {
          TypePath::Member(_) => None
          TypePath::Object({name}, _) => {
            let enumType = scope.getTypeBinding(name).type_
            if enumType.isEnum() {
              if type_ and type_.isEnum() and not isAssignable(enumType, type_)
                then return Err(PatternError::PatternMismatch(p, enumType, type_))
              Some(enumType)
            }
            else None
          }
        }

      let tupleType: Type =
        if type_
          then type_
          else typePath.type_

      let tupleType: Type = match tupleType.kind {
        TypeKind::Enum(enum_) => {
          let member = getEnumMember(typePath)
          let enumArmType = enum_.members[member]
          enumArmType
        }
        _ => tupleType
      }
      let props = match tupleType.kind {
        TypeKind::Struct(struct) => {
          match struct.kind {
            StructKind::Tuple(tuple) => tuple.properties
            _ => return Err(PatternError::PatternMismatch(p, p.type_, tupleType))
          }
        }
        TypeKind::Parameter => []
        _ => return Err(PatternError::PatternMismatch(p, p.type_, tupleType))
      }

      let properties: Result<List<Type>, PatternError> = tuple.properties
        .enumerate()
        .map(|mut (p, i)| declarePatternVariables(scope, visitor, p, mutable, props[i], allowNotExhaustive))
        .toList()
        .reduce(|acc: Result<List<Type>, PatternError>, cur: Result<Type, PatternError>| {
          acc.andThen(|props| cur.map(|prop| props.concat(prop)))
        }, Ok([]))

      properties.andThen(|properties| {
        let type_ = {
          displayName: None
          name: None
          kind: TypeKind::Struct({
            implementations: []
            kind: StructKind::Tuple({
              properties
            })
          })
          class: None
          instance: None
        }

        if let Option::Some(enumType) = enumType {
          if not allowNotExhaustive and enumType.getEnum().members.size() > 1
            then Err(PatternError::NotExhaustive)
            else {
              let member = getEnumMember(typePath)
              let enumArmType = enumType.getEnum().members[member]

              if isAssignable(enumArmType, type_)
                then Ok(enumType)
                else Err(PatternError::PatternMismatch(p, enumArmType, type_))
            }
        } else {
          if isAssignable(typePath.type_, type_)
            then Ok(typePath.type_)
            else Err(PatternError::PatternMismatch(p, typePath.type_, type_))
        }
      })
    }
    Pattern::UnitType(typePath) => {
      visitor.visitTypePath(typePath)
      Ok(false)
    }
  }
}
