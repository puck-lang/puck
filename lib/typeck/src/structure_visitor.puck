import 'puck:js' as {Object, undefined}
import 'node:util' as {inspect}
import '../../ast/ast.puck' as {
  FunctionDeclaration
  Identifier
  TypeParameter
  TypePath
  VariableDeclaration

  Pattern

  FunctionTypeBound
  NamedTypeBound
  ObjectTypeBound
  TupleTypeBound

  BooleanLiteral
  ListLiteral
  NumberLiteral
  ObjectLiteral
  StringLiteral
  TupleLiteral
}
import '../../ast/visit.puck' as visit
import '../../compiler/ast.ts' as {SyntaxKind}
import '../../entities.puck' as {
  Scope
  TypeInstance
  isEnumType
  isFunctionType
  isObjectType
  isStruct
  isTupleType
  isTypeClass
  isTypeParameter
}
import 'functions.puck' as {createFunctionType, getTupleTypeName}
import 'range.puck' as {checkRange}
import 'types.puck' as {createTypeInstanceTypeCast, getType, isAssignable}

export fn notAssignableError(to: TypeInstance, subject: TypeInstance)
  then subject.name + ' is not assignable to type ' + to.name

export let structureVisitor = {
  visitEnumMember: visit.walkingVisitor.visitEnumMember
  visitFunctionDeclaration: |mut self, mut f: FunctionDeclaration| {
    if not f.scope {
      self.scope = self.scope.createChild()
      f.scope = self.scope

      let assignedTo =
        if self.assignedTo then self.assignedTo.type_

      if f.typeParameters
        then f.typeParameters.forEach(self.visitTypeParameter.bind(self))
      f.parameterList.forEach(|p, i| {
        let type_ =
          if assignedTo then assignedTo.arguments[i].type_
        self.visitFunctionParameter(p, type_)
      })
      if let Maybe::Just(returnType) = f.returnType then self.visitTypeBound(returnType)

      f.type_ = createFunctionType(f.scope, f, self.reportError)
      if let Maybe::Just(name) = f.name then
        f.scope.parent.define({
          name: name.name
          token: f
          mutable: false
          type_: f.type_
        })

      self.scope = f.scope.parent
    }
  }
  visitFunctionParameter: |self, mut v: VariableDeclaration, type_| {
    self.visitVariableDeclaration(v, self.visitLiteral.bind(self), type_)
  }
  visitFunctionTypeBound: |mut self, mut t: FunctionTypeBound| {
    if not t.scope {
      self.scope = self.scope.createChild()
      t.scope = self.scope

      visit.walkFunctionTypeBound(self, t)
      t.type_ = getType(t.scope, t)

      self.scope = self.scope.parent
    }
  }
  visitNamedTypeBound: |self, mut t: NamedTypeBound| {
    if not t.scope {
      t.scope = self.scope

      self.visitTypePath(t.path)
      if isTypeClass(t.path.type_) {
        if let Result::Err(error) = checkRange(t.typeParameters, t.path.type_.parameterRange, 'type parameters', t.path.type_.name)
        then self.reportError(t, error)
      }
      else if t.typeParameters.length > 0
        then self.reportError(t, 'Type ' + t.path.type_.name + ' is not generic')

      visit.walkNamedTypeBound(self, t)

      t.type_ =
        if isTypeClass(t.path.type_)
          then createTypeInstanceTypeCast(t.path.type_, t.typeParameters.map(|p| p.type_))
          else t.path.type_
    }
  }
  visitObjectTypeBound: |self, mut t: ObjectTypeBound| {
    if not t.scope {
      t.scope = self.scope

      visit.walkObjectTypeBound(self, t)

      t.type_ = getType(t.scope, t)
    }
  }
  visitTupleTypeBound: |self, mut t: TupleTypeBound| {
    if not t.scope {
      t.scope = self.scope

      visit.walkTupleTypeBound(self, t)

      t.type_ = getType(t.scope, t)
    }
  }
  visitTypeParameter: |self, mut t: TypeParameter| {
    if not t.scope {
      t.scope = self.scope
      visit.walkTypeParameter(self, t)
      let binding = self.scope.defineType(t)
      t.type_ = binding.type_
    }
  }
  visitTypePath: |self, mut t: TypePath| {
    if not t.scope {
      t.scope = self.scope
      let binding = t.scope.getTypeBinding(t.value[0].name)
      if not binding
        then self.reportError(t, 'Use of undeclared type ' + t.value[0].name)
      t.type_= binding.type_
    }
  }
  visitVariableDeclaration: |self, mut d: VariableDeclaration, visitInitializer, type_, allowNotExhaustive = false| {
    if d.scope then return undefined
    d.scope = self.scope
    d.type_ = d.typeBound.mapOr(type_, |bound| {
      self.visitTypeBound(bound)
      getType(d.scope, bound) or type_
    })

    let result = declarePatternVariables(d.scope, self, d.pattern, d.mutable, d.type_, allowNotExhaustive)
    if result.isOk() {
      let patternTy = result.value[0]

      if patternTy {
        if not d.type_ {
          d.type_ = patternTy
        }
        else if not isAssignable(patternTy, d.type_)
          then self.reportError(d, notAssignableError(patternTy, d.type_))
      }
    }
    else {
      if result.value[0].kind == 'PatternMismatch' {
        let (pattern, to, subject) = result.value[0].value
        self.reportError(d, notAssignableError(to, subject))
      }
      else if result.value[0].kind == 'NotExhaustive' {
        self.reportError(d, 'non exhaustive pattern')
      }
    }

    if let Maybe::Just(initializer) = d.initializer {
      visitInitializer(initializer)
      if not d.type_ and d.pattern.binding {
        d.pattern.binding.type_ = initializer.type_
        d.type_ = initializer.type_
      }
      else if not isAssignable(d.type_, initializer.type_)
        then self.reportError(d, notAssignableError(d.type_, initializer.type_))
    }
  }

  visitLiteral: |self, mut l| {
    l.scope = self.scope
    if l.kind == SyntaxKind.BooleanLiteral
      then self.visitStrictBooleanLiteral(l)
    else if l.kind == SyntaxKind.ListLiteral
      then self.visitStrictListLiteral(l)
    else if l.kind == SyntaxKind.NumberLiteral
      then self.visitStrictNumberLiteral(l)
    else if l.kind == SyntaxKind.ObjectLiteral
      then self.visitStrictObjectLiteral(l)
    else if l.kind == SyntaxKind.StringLiteral
      then self.visitStrictStringLiteral(l)
    else self.reportError(l, 'not a literal' + inspect(l))
  }
  visitStrictBooleanLiteral: |self, mut l: BooleanLiteral| {
    l.type_ = self.scope.getTypeBinding('Bool').type_
  }
  visitStrictListLiteral: |self, mut l: ListLiteral| {
    l.members.forEach(self.visitLiteral.bind(self))
  }
  visitStrictNumberLiteral: |self, mut l: NumberLiteral| {
    l.type_ = self.scope.getTypeBinding('Num').type_
  }
  visitStrictObjectLiteral: |self, mut l: ObjectLiteral| {
    l.members.forEach(|m| {
      self.visitLiteral(m.value)
    })
  }
  visitStrictStringLiteral: |self, mut l: StringLiteral| {
    l.type_ = self.scope.getTypeBinding('String').type_
     if l.parts.some(|p| p.kind == SyntaxKind.Identifier)
      then self.reportError(l, 'not a literal')
  }
  visitStrictTupleLiteral: |self, mut l: TupleLiteral| {
    l.expressions.forEach(self.visitLiteral.bind(self))
  }
}

enum PatternError
  = PatternMismatch(Pattern , TypeInstance, TypeInstance)
  | NotExhaustive
  | Other(Pattern, String)

export fn declarePatternVariables(scope: Scope, visitor, mut p: Pattern, mutable: Bool, type_, allowNotExhaustive: Bool):
    Result<TypeInstance, PatternError> {
  if p.kind == 'CatchAll' {
    Ok(false)
  }
  else if p.kind == 'Identifier' {
    p.binding = scope.define({
      name: p.value[0].name
      mutable
      token: p
      type_
    }, true)
    Ok(false)
  }
  else if p.kind == 'Record' {
    let properties: Result<List<TypeInstance>, (Pattern, TypeInstance, TypeInstance)> = p.value[0].properties
      .map(|mut p| declarePatternVariables(scope, visitor, p.pattern, mutable, type_ and type_.properties[p.property.name], allowNotExhaustive))
      .reduce(|acc: Result<List<TypeInstance>, (Pattern, TypeInstance, TypeInstance)>, cur: Result<TypeInstance, (Pattern, TypeInstance, TypeInstance)>| {
        acc.andThen(|props| cur.map(|prop| props.concat(prop)))
      }, Ok([]))
    properties.map(|_| false)
  }
  else if p.kind == 'RecordType' {
    visitor.visitTypePath(p.value[0])
    let recordType =
      if type_ and (isStruct(type_) or isEnumType(type_))
        then type_
        else p.value[0].type_
    let recordType =
      if isEnumType(recordType) {
        let member = p.value[0].value[1].value[0].name
        let enumArmType = recordType.members[member]
        enumArmType
      }
      else recordType

    let properties: Result<List<TypeInstance>, (Pattern, TypeInstance, TypeInstance)> = p.value[1].properties
      .map(|mut p| declarePatternVariables(scope, visitor, p.pattern, mutable, recordType and recordType.properties[p.property.name], allowNotExhaustive))
      .reduce(|acc: Result<List<TypeInstance>, (Pattern, TypeInstance, TypeInstance)>, cur: Result<TypeInstance, (Pattern, TypeInstance, TypeInstance)>| {
        acc.andThen(|props| cur.map(|prop| props.concat(prop)))
      }, Ok([]))
    properties.map(|_| p.value[0].type_)
  }
  else if p.kind == 'Tuple' {
    let properties: Result<List<TypeInstance>, (Pattern, TypeInstance, TypeInstance)> = p.value[0].properties
      .map(|mut p, i| declarePatternVariables(scope, visitor, p, mutable, type_ and type_.properties and type_.properties[i], allowNotExhaustive))
      .reduce(|acc: Result<List<TypeInstance>, (Pattern, TypeInstance, TypeInstance)>, cur: Result<TypeInstance, (Pattern, TypeInstance, TypeInstance)>| {
        acc.andThen(|props| cur.map(|prop| props.concat(prop)))
      }, Ok([]))
    properties.map(|properties| {{
      kind: 'Tuple'
      name: getTupleTypeName(properties)
      properties
    }})
  }
  else if p.kind == 'TupleType' {
    visitor.visitTypePath(p.value[0])
    let tupleType =
      if type_ and (isTupleType(type_) or isEnumType(type_))
        then type_
        else p.value[0].type_
    let tupleType =
      if isEnumType(tupleType) {
        let member = p.value[0].value[1].value[0].name
        let enumArmType = tupleType.members[member]
        enumArmType
      }
      else tupleType

    let properties: Result<List<TypeInstance>, PatternError> = p.value[1].properties
      .map(|mut p, i| declarePatternVariables(scope, visitor, p, mutable, tupleType and tupleType.properties[i], allowNotExhaustive))
      .reduce(|acc: Result<List<TypeInstance>, PatternError>, cur: Result<TypeInstance, PatternError>| {
        acc.andThen(|props| cur.map(|prop| props.concat(prop)))
      }, Ok([]))
    properties.andThen(|properties| {
      let type_ = {
        kind: 'Tuple'
        name: getTupleTypeName(properties)
        properties
      }

      if isEnumType(p.value[0].type_) {
        let enumType = p.value[0].type_
        if not allowNotExhaustive and Object.keys(enumType.members).length > 1
          then Err(PatternError::NotExhaustive)
          else {
            let member = p.value[0].value[1].value[0].name
            let enumArmType = p.value[0].type_.members[member]

            if isAssignable(enumArmType, type_)
              then Ok(enumType)
              else Err(PatternError::PatternMismatch(p, enumArmType, type_))
          }
      } else {
        if isAssignable(p.value[0].type_, type_)
          then Ok(p.value[0].type_)
          else Err(PatternError::PatternMismatch(p, p.value[0].type_, type_))
      }
    })
  }
  else if p.kind == 'UnitType' {
    visitor.visitTypePath(p.value[0])
    Ok(false)
  }
}
