import 'puck:js' as {Error, Object, undefined}
import 'node:util' as {inspect}
import '../../ast/ast.puck' as {
  Expression
  RecordTypeBoundMember

  FunctionDeclaration
  Identifier
  TypeParameter
  TypePath
  VariableDeclaration

  Pattern

  TypeBound
  FunctionTypeBound
  IntersectionTypeBound
  NamedTypeBound
  RecordTypeBound
  TupleTypeBound

  BooleanLiteral
  ListLiteral
  NumberLiteral
  RecordLiteral
  StringLiteral
  TupleLiteral
}
import '../../ast/span.puck' as {ToSpan}
import '../../compiler.puck' as {CompilerContext}
import '../../ast/visit.puck' as visit
import '../../compiler/ast.ts' as {SyntaxKind}
import '../../entities.puck' as {
  Definition
  RecordMember
  Enum
  File
  StructKind
  Type
  TypeClass
  TypeKind
  CompilationError
}
import 'functions.puck' as {createFunctionType}
import 'patterns.puck' as {PatternError, declarePatternVariables}
import 'range.puck' as {checkRange}
import 'scope.puck' as {Scope, ScopeError}
import 'types.puck' as {createTypeInstance, isAssignable}

export fn notAssignableError(to: Type, subject: Type) {
  subject.displayName() ++ ' is not assignable to type ' ++ to.displayName()
}

export fn structureVisitor(context: CompilerContext, file: File, visitor = '') {
  fn reportError(token: ToSpan, message: String) {
    context.reportError(file, token, CompilationError::Other(message))
  }

  {
  visitEnumMember: visit.walkingVisitor.visitEnumMember
  visitFunctionDeclaration: |mut self, mut f: FunctionDeclaration| {
    if not f->scope {
      let mut parentScope: Scope = self.scope
      self.scope = parentScope.createChild()
      f->scope = self.scope

      let assignedTo =
        if self.assignedTo
          then if let TypeKind::Function(func) = self.assignedTo.kind
            then Some(func)
            else None
          else None

      f.typeParameters.forEach(|p| self.visitTypeParameter(p))
      f.parameterList.enumerate().forEach(|(i, p)| {
        let type_: Type =
          if let Some(assignedTo) = assignedTo
            then if assignedTo.parameters.size() > i
              then assignedTo.parameters->[i]->type_.transmute()
              else undefined
            else undefined
        self.visitVariableDeclaration(p, undefined, type_)
      })
      if let Option::Some(returnType) = f.returnType then self.visitTypeBound(returnType)

      f.type_ = createFunctionType(file, f->scope.transmute(), f, reportError)
      if let Option::Some(name) = f.name {
        if let Result::Err(err) = parentScope.define({
          definition: Definition({file, token: f})
          name: name.name
          allowRedeclare: false
          mutable: false
          type_: f.type_
          previous: None
          completeType: None
        })
          then reportError(name, err)
      }

      self.scope = parentScope
    }
  }
  visitMethodDeclaration: |mut self, mut f: FunctionDeclaration, selfType: Type| {
    if not f->scope {
      let parentScope: Scope = self.scope
      self.scope = parentScope.createChild()
      f->scope = self.scope

      if f.name.isNone()
        then reportError(f, 'Trait functions must have a name')
      if f.returnType.isNone()
        then reportError(f, 'Trait functions must have a return type')

      f.typeParameters.forEach(self.visitTypeParameter.bind(self))

      if let Option::Some(first) = f.parameterList.first() {
        if let Pattern::Identifier {identifier: {name, span}} = first.pattern {
          if name == 'self' {
            let selfTypeBound = first.typeBound
            if selfTypeBound.isNone() {
              f.parameterList[0].typeBound = Some(TypeBound::NamedTypeBound({
                path: TypePath::Member({name: 'Self', span})
                typeParameters: []
              }))
            }
            else {
              self.visitVariableDeclaration(first)
              if not isAssignable(first->type_.transmute(), selfType)
                then reportError(first, notAssignableError(first->type_.transmute(), selfType))
            }
          }
        }
      }

      f.parameterList.forEach(|p| self.visitVariableDeclaration(p))
      if let Option::Some(returnType) = f.returnType then self.visitTypeBound(returnType)

      f.type_ = createFunctionType(file, f->scope.transmute(), f, reportError)

      self.scope = parentScope
    }
  }
  visitTypeBound: |self, mut t: TypeBound| {
    visit.walkTypeBound(self, t)
  }
  visitFunctionTypeBound: |mut self, mut t: FunctionTypeBound| {
    if not t->scope {
      let parentScope: Scope = self.scope
      self.scope = parentScope.createChild()
      t->scope = self.scope

      visit.walkFunctionTypeBound(self, t)
      let parameters = t.parameters.properties
        .enumerate()
        .map(|(i, t)| {{
          definition: Definition({file, token: t})
          name: '$i'
          mutable: false
          allowRedeclare: true
          type_: t.getType()
          completeType: None
          previous: None
        }})
        .toList()

      t->type_ = Type({
        definition: Definition({
          file
          token: t
        })
        id: None
        displayName: None
        name: None
        kind: TypeKind::Function({
          selfBinding: None
          parameters
          parameterRange: {start: parameters.size(), end: parameters.size() + 1}
          returnType: t.returnType.getType()
          isAbstract: false
        })
        class: TypeClass.fromAstNode(t, reportError)
        instance: None
        providesType: None
        enumMember: None
      })

      self.scope = parentScope
    }
  }
  visitIntersectionTypeBound: |self, mut t: IntersectionTypeBound| {
    if not t->scope {
      t->scope = self.scope
      visit.walkIntersectionTypeBound(self, t)

      if not t.traitBound.getType().isTrait()
        then reportError(t.traitBound
          'Can only add a trait bound, ' ++ t.traitBound.getType().displayName() ++ ' is not a trait'
        )

      t->type_ = Type({
        definition: Definition({file, token: t})
        id: None
        displayName: None
        name: None
        kind: TypeKind::Intersection({
          baseType: t.baseType.getType()
          intersectedTrait: t.traitBound.getType()
        })
        class: None
        instance: None
        providesType: None
        enumMember: None
      })
    }
  }
  visitNamedTypeBound: |self, mut t: NamedTypeBound| {
    if not t->scope {
      t->scope = self.scope

      self.visitTypePath(t.path)
      let mut type_: Type = t.path->providesType.transmute()
      if not type_ then return ()
      type_ = Type({
        definition: Definition({file, token: t})
        id: type_.id
        displayName: type_.displayName
        name: type_.name
        kind: type_.kind
        class: type_.class
        instance: type_.instance
        providesType: type_.providesType
        enumMember: type_.enumMember
      })

      let isSelf =
        if let TypePath::Member({name}) = t.path {
          if name == 'Self' {
            if t.typeParameters.size() > 0
              then reportError(t, 'Self is not generic')

            true
          }
          else false
        }
        else false

      if not isSelf {
        if let Option::Some(class) = type_.class {
          if let Result::Err(error) =
            checkRange(t.typeParameters, class.parameterRange, 'type parameters', type_.displayName()) {
            reportError(t, error)
          }
        }
        else if t.typeParameters.size() > 0
          then reportError(t, 'Type ' ++ type_.displayName() ++ ' is not generic')
      }

      visit.walkNamedTypeBound(self, t)

      t->type_ =
        if type_.class.isSome()
          then createTypeInstance(type_, t.typeParameters.map(|typeBound| typeBound.getType()).toList())
          else type_
    }
  }
  visitRecordTypeBound: |self, mut t: RecordTypeBound| {
    if not t->scope {
      t->scope = self.scope

      visit.walkRecordTypeBound(self, t)

      let mut properties = ObjectMap.new::<RecordMember>()
      t.properties.map(|p| {
        match p {
          RecordTypeBoundMember::Property {name, optional, typeBound} => {
            properties.set(name.name, {type_: typeBound.getType(), optional})
          }
          RecordTypeBoundMember::Spread(typeBound) => {
            match typeBound.getType().kind {
              TypeKind::Struct({kind: StructKind::Record(r)}) => {
                properties.merge(r.properties)
              }
              _ => {
                reportError(typeBound, 'Can only spread record types')
              }
            }
          }
        }
      })

      t->type_ = Type({
        definition: Definition({file, token: t})
        id: None
        displayName: None
        name: None
        kind: TypeKind::Struct({
          implementations: []
          kind: StructKind::Record({properties})
        })
        class: None
        instance: None
        providesType: None
        enumMember: None
      })
    }
  }
  visitRecordTypeBoundMember: visit.walkingVisitor.visitRecordTypeBoundMember,
  visitTupleTypeBound: |self, mut t: TupleTypeBound| {
    if not t->scope {
      t->scope = self.scope

      visit.walkTupleTypeBound(self, t)

      t->type_ = Type({
        definition: Definition({file, token: t})
        id: None
        displayName: None
        name: None
        kind: TypeKind::Struct({
          implementations: []
          kind: StructKind::Tuple({properties: t.properties.map(|p| p.getType()).toList()})
        })
        class: None
        instance: None
        providesType: None
        enumMember: None
      })
    }
  }
  visitTypeParameter: |self, mut t: TypeParameter| {
    if not t->scope {
      t->scope = self.scope
      visit.walkTypeParameter(self, t)
      t->type_ = Type({
        definition: Definition({file, token: t})
        id: Some(t.name.name)
        displayName: None
        name: Some(t.name.name)
        kind: TypeKind::Parameter({
          defaultValue: t.defaultValue.map(|typeBound| typeBound.getType())
        })
        class: None
        instance: None
        providesType: None
        enumMember: None
      })
      let mut scope: Scope = self.scope
      if let Result::Err(err) = scope.define({
        definition: Definition({file, token: t})
        name: t.name.name
        mutable: false
        allowRedeclare: false
        type_: Type.provides(t->type_.transmute())
        completeType: None
        previous: None
      })
        then reportError(t.name, err)
    }
  }
  visitTypePath: |self, mut t: TypePath| {
    if not t->type_ {
      t->scope = self.scope
      let scope: Scope = self.scope
      match scope.getTypePath(t, visitor) {
        Result::Ok(binding) => {
          t->type_= binding.type_
          t->providesType = binding.type_ and binding.type_.providesType.unwrapOr(binding.type_)
        }
        Result::Err(ScopeError::UndefinedType(name)) => {
          context.reportError(
            file,
            t
            CompilationError::UndefinedVariable(name)
          )
        }
        Result::Err(ScopeError::Other(err)) => reportError(t, err)
      }
    }
  }
  visitVariableDeclaration: |mut self, mut d: VariableDeclaration, visitInitializer, type_: Type| {
    if d->scope then return ()
    d->scope = self.scope
    self.visitPattern(d.pattern)
    let type_: Type = d.typeBound.mapOr(type_, |bound| {
      self.visitTypeBound(bound)
      bound.getType() or type_
    })
    d->type_ = type_
    if not isAssignable(d.pattern->type_.transmute(), type_)
      then return reportError(d.pattern, type_.displayName() ++ ' is not assignable to pattern ' ++ d.pattern.displayName())

    let mut scope: Scope = self.scope
    let mut childScope =
      if d.initializer.isSome()
        then scope.createChild()
        else scope

    match declarePatternVariables(childScope, self, d.pattern, type_, false, d.initializer.isSome()) {
      Result::Ok(_) => {}
      Result::Err(PatternError::PatternMismatch(_, to, subject)) => {
        reportError(d, notAssignableError(to, subject))
      }
      Result::Err(PatternError::NotExhaustive) => {
        reportError(d, 'non exhaustive pattern')
      }
      Result::Err(PatternError::ScopeError(token, err)) => reportError(token, err)
    }

    if let Option::Some(initializer) = d.initializer {
      let parentVariableDeclarationScope = self.variableDeclarationScope
      self.variableDeclarationScope = childScope

      if visitInitializer {
        visitInitializer(initializer)
      } else {
        self.visitExpression(initializer)
      }

      scope.merge(childScope)
      self.variableDeclarationScope = parentVariableDeclarationScope

      let initializerType = initializer.getType()
      if not d->type_ and d.pattern->binding {
        d.pattern->binding->type_ = initializerType
        d->type_ = initializerType
      }
      else if not isAssignable(type_, initializerType)
        then return reportError(initializer, notAssignableError(type_, initializerType))
      if not isAssignable(d.pattern->type_.transmute(), initializerType)
        then return reportError(d, notAssignableError(d.pattern->type_.transmute(), initializerType))
    }
  }
}}
