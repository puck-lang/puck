export fn getRange<T>(parameters: List<T>, isOptional: (T) -> Bool, reportError, name: String) -> Range {
  let mut firstOptional = parameters.length
  let mut hasOptional = false

  parameters.enumerate().forEach(|(parameter, i)|
    if isOptional(parameter) and not hasOptional {
      hasOptional = true
      firstOptional = i
      ()
    }
    else if not isOptional(parameter) and hasOptional {
      reportError(parameter
        "An optional $name can't be followed by a required $name"
      )
    }
  )

  {
    start: firstOptional
    end: parameters.length + 1
  }
}

export fn checkRange<T>(arguments: List<T>, range: Range, argumentName: String, subjectName: String) -> Result<(), String> {
  let argumentCount = arguments.length
  let max = range.end - 1
  let min = range.start
  let error: Result<(), String> =
    if argumentCount < min
      then Err('few')
    else if argumentCount > max
      then Err('many')
    else Ok(())

  error.mapErr(|error| {
    let required =
      if min == max
        then '$min'
        else '$min to $max'

    'Too $error $argumentName given to $subjectName, $required required, $argumentCount given'
  })
}
