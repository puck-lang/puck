import 'puck:js' as {Object, null, undefined}
import '../../ast/ast.puck' as {TypeBound}
import '../../ast/visit.puck' as visit
import '../../compiler/ast.ts' as {SyntaxKind}
import '../../entities.puck' as {
  Enum
  Function
  Struct
  StructKind
  Trait
  Type
  TypeClass
  TypeInstance
  TypeKind
}

fn assign(a, b) {
  Object.assign({}, a, b)
}

export let resolveTypeParameters = |parameterMap: ObjectMap<Type>, enterNamed = true| fn resolveTypeParametersInner(mut type_: Type) {
  if not type_ then return type_

  if let Option::Some(instance) = type_.instance {
    let mut i = instance
    let typeParameters: List<Type> = instance.typeParameters
    if typeParameters.any(|parameter| parameter.isParameter()) {
      return createTypeInstance(
        i.class
        typeParameters
          .map(|p|
            if p.isParameter()
              then parameterMap.get(p.name.unwrap()).unwrapOr(p)
              else p
          )
      )
    }
  }

  if not enterNamed and not type_.isParameter()
     and (type_.name.isSome() or type_.displayName.isSome())
    then return type_

   let resolvedKind = match type_.kind {
    TypeKind::Enum(enum_) => TypeKind::Enum(resolveTypeParametersEnum(parameterMap, enum_))
    TypeKind::Function(func) => {
      let mut f = func
      TypeKind::Function(resolveTypeParametersFn(parameterMap, f))
    }
    TypeKind::Parameter => return parameterMap.get(type_.name.unwrap()).unwrapOr(type_)
    TypeKind::Struct(struct) => TypeKind::Struct(resolveTypeParametersStruct(parameterMap, struct))
    TypeKind::Trait(trait_) => TypeKind::Trait(resolveTypeParametersTrait(parameterMap, trait_))
    _ => return type_
  }

  assign(type_, {
    kind: resolvedKind
  })
}

fn resolveTypeParametersEnum(parameterMap: ObjectMap<Type>, e: Enum) {
  assign(e, {
    members: e.members.map(resolveTypeParameters(parameterMap))
  })
}

fn resolveTypeParametersFn(parameterMap: ObjectMap<Type>, mut func: Function) {
  assign(func, {
    parameters: func.parameters.map(|mut binding| assign(binding, {
      type_:
        if binding.type_
          then resolveTypeParameters(parameterMap, false)(binding.type_)
    })).toList()
    returnType:
      if func.returnType
        then resolveTypeParameters(parameterMap, false)(func.returnType)
  })
}

fn resolveTypeParametersStruct(parameterMap: ObjectMap<Type>, struct: Struct) -> Struct {
  assign(struct, {
    kind: match struct.kind {
      StructKind::Record({properties}) => StructKind::Record({
        properties: properties.map(resolveTypeParameters(parameterMap, false))
      })

      StructKind::Tuple({properties}) => StructKind::Tuple({
        properties: properties.map(resolveTypeParameters(parameterMap, false)).toList()
      })

      StructKind::Unit => struct.kind
    }
  })
}

fn resolveTypeParametersTrait(parameterMap: ObjectMap<Type>, t: Trait) {
  assign(t, {
    functions: t.functions.map(resolveTypeParameters(parameterMap, false))
  })
}

fn mapObject<T>(object: ObjectMap<T>, mapper) {
  object.map(mapper)
}

export fn createTypeInstance(mut type_: Type, typeParameters_: Iterable<Type>) {
  if let Option::Some(providedType) = type_.providesType {
    let mut p = providedType
    return Type({
      id: type_.id
      displayName: type_.displayName
      name: type_.name
      kind: type_.kind
      class: type_.class
      instance: type_.instance
      providesType: createTypeInstance(p, typeParameters_)
      enumMember: type_.enumMember
      complete: type_.complete
    })
  }
  let mut class: TypeClass = type_.class.unwrap()
  let typeParameters: List<Type> =
    if typeParameters_.length < class.parameterRange.end - 1 {
      typeParameters_.concat(
        class.typeParameters
          .slice(typeParameters_.length)
          .map(|p| {
            if let TypeKind::Parameter(parameter) = p.kind {
              parameter.defaultValue.unwrapOr(p)
            }
            else throw 'not a type parameter'
          })
      )
    }
    else typeParameters_.toList()

  if let Option::Some(cachedInstance) = class.instances.find(|a: Type| {
      let i = a.instance.unwrap()
      i.typeParameters.length == typeParameters.length and
      i.typeParameters.every(|p, i| isSameType(p, typeParameters[i]))
    })
    then return cachedInstance

  let parameterMap = ObjectMap.fromIter(
    List.zip(typeParameters, class.typeParameters)
      .map(|p| {
        let typeArgument = p[0]
        let typeParameter: Type = p[1]

        (typeParameter.name.unwrap(), typeArgument)
      }))

  let mut instance: Type = {
    id: type_.id
    displayName: type_.displayName
    name: type_.name
    kind: type_.kind
    class: None
    instance: Some({
      class: type_
      typeParameters
      parameterMap
    })
    providesType: type_.providesType
    enumMember: type_.enumMember
    complete: type_.complete
  }
  class.instances.push(instance)

  instance.kind = resolveTypeParameters(parameterMap)(type_).kind

  if let TypeKind::Enum(enum_) = instance.kind {
    enum_.members.forEach(|mut (_, member)| {
      member.enumMember = member.enumMember.map(|(member, _)| (member, instance))
    })
  }

  instance
}

fn isSameId(to: Type, subject: Type) {
  match (to.id, subject.id) {
    (Some(toId), Some(subjectId)) => toId == subjectId
    _ => true
  }
}

fn checkTypeParameters(to: Type, subject: Type) {
  if to.id.isNone() or subject.id.isNone() then return true

  match (to.typeParameters(), subject.typeParameters()) {
    (Some(toParameters), Some(subjectParameters)) => {
      if toParameters.size() == subjectParameters.size()
        then List.zip(toParameters, subjectParameters)
          .all(|(toParameter, subjectParameter)| isAssignable(toParameter, subjectParameter))
        else false
    }
    (Option::None, Option::None) => true
    _ => false
  }
}

export fn isAssignable(to: Type, subject: Type) {
  if to and not subject {
    if let TypeKind::Trait(_) = to.kind then return false
  }
  if not subject or not to then return true
  if to == subject then return true

  match subject.kind {
    TypeKind::Parameter => return true
    TypeKind::Enum(enum_) => if enum_.members.size() == 0 then return true
    _ => {}
  }

  match to.kind {
    TypeKind::Enum(toEnum) => match subject.kind {
      TypeKind::Enum(subjectEnum) => {
        isSameId(to, subject) and
        isEnumAssignable(toEnum, subjectEnum) and
        checkTypeParameters(to, subject)
      }
      _ => false
    }
    TypeKind::Function(toFunc) => match subject.kind {
      TypeKind::Function(subjectFunc) => isFunctionAssignable(toFunc, subjectFunc)
      _ => false
    }
    TypeKind::Parameter => true
    TypeKind::Struct(toStruct) => match subject.kind {
      TypeKind::Struct(subjectStruct) => {
        isSameId(to, subject) and
        isStructAssignable(toStruct, subjectStruct) and
        checkTypeParameters(to, subject)
      }
      _ => false
    }
    TypeKind::Trait(toTrait) => match subject.kind {
      TypeKind::Trait(subjectTrait) => isTraitAssignable(toTrait, subjectTrait)
      TypeKind::Enum(subjectEnum) => {
        subjectEnum.implementations.any(|implementation|
          isAssignable(to, implementation.trait_)
        )
      }
      TypeKind::Struct(subjectStruct) => {
        subjectStruct.implementations.any(|implementation|
          isAssignable(to, implementation.trait_)
        )
      }
      _ => false
    }
  }
}

fn isEnumAssignable(to: Enum, subject: Enum) {
  if to.members.size() == subject.members.size()
    then to.members.toList().all(|(name, toMember)|
      isAssignable(toMember, subject.members[name])
    )
    else return false
}

fn isFunctionAssignable(to: Function, subject: Function) {
  if not to.parameterRange.isSubsetOf(subject.parameterRange)
    then return false

  to.parameters.enumerate().all(|(toArg, i)|
    isAssignable(toArg.type_, subject.parameters[i].type_)
  )
}

fn isStructAssignable(to: Struct, subject: Struct) {
  match (to.kind, subject.kind) {
    (StructKind::Record({properties: toProps}), StructKind::Record({properties: subjectProps})) => {
      toProps.toList().all(|(key, toProp)| {
        subjectProps.has(key) and isAssignable(toProp, subjectProps[key])
      })
    }
    (StructKind::Tuple({properties: toProps}), StructKind::Tuple({properties: subjectProps})) => {
      if toProps.size() != subjectProps.size() then return false
      List.zip(toProps, subjectProps)
        .all(|(toProp, subjectProp)| isAssignable(toProp, subjectProp))
    }
    (StructKind::Unit, StructKind::Unit) => to.kind.value == subject.kind.value
    _ => to.kind == subject.kind
  }
}

fn isTraitAssignable(to: Trait, subject: Trait) {
  if to.functions.size() == subject.functions.size()
    then to.functions.toList().all(|(name, toFunction)|
      isAssignable(toFunction, subject.functions[name])
    )
    else return false
}

export fn isSameType(a: Type, b: Type) {
  match (a.id, b.id) {
    (Some(aId), Some(bId)) => aId == bId
    _ => false
  }
}

export fn findCommonType(types: List<Type>) -> Result<Type, ()> {
  let mut index = 0

  while index < types.length {
    let mut type_ = types[index]

    if types.all(|t| isAssignable(type_, t)) {
      return Ok(type_)
    }
    index += 1
  }

  Err(())
}
