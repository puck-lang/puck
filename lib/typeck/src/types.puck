import 'puck:js' as {Object, null, undefined}
import '../../ast/ast.puck' as {FunctionTypeBound, NamedTypeBound}
import '../../ast/visit.puck' as visit
import '../../entities.puck' as {isTypeClass, isTypeInstance, isTypeParameter, FunctionType, Scope, Type, TypeClass}
import 'functions.puck' as {getFunctionTypeName}

export fn createTypeInstance(class, typeParameters: List<Type>) { // class: TypeClass
  if let instance = class.instances.find(|i|
      i.typeParameters.length == typeParameters.length
  and i.typeParameters.every(|p, i| isSameType(p, typeParameters[i])))
    then instance
    else {
      let instance = {
        isTrait: class.isTrait
        functions: class.functions
        properties: class.properties and Object.create(null)
        implementations: class.implementations and []
        kind: class.name
        name: class.name + '<' + typeParameters.map(|p| p.name).join(', ') + '>'
        class
        typeParameters
      }
      class.instances.push(instance)
      instance
    }
}

export fn getType(scope: Scope, t) { // t: TypeBound
  if not t then return undefined
  if t.name {
    let binding = scope.getTypeBinding(t.name.name)

    if not binding
      then binding
    else if isTypeClass(binding.ty)
      then createTypeInstance(binding.ty, t.typeParameters.map(|p| p.ty))
    else binding.ty
  }
  else {
    let arguments = t.arguments.map(|p| {{ty: getType(scope, p)}})
    let returnType = getType(scope, t.returnType)

    {
      kind: 'Function'
      name: getFunctionTypeName(arguments, returnType)
      arguments
      argumentRange: {start: arguments.length, end: arguments.length + 1}
      returnType
    }
  }
}

export fn isAssignable(to, subject) { // to: Type, subject: Type
  if not subject or not to then return true
  if isTypeParameter(to) then return true

  let sameKind = subject.kind == to.kind

  if not sameKind then return false

  if sameKind and to.kind == 'Function'
    then isFunctionAssignable(to, subject)
  else true
}

fn isFunctionAssignable(to: FunctionType, subject: FunctionType) {
  if not to.argumentRange.isSubsetOf(subject.argumentRange)
    then return false

  to.arguments.every(fn (toArg, i) {
    let subjectArg = subject.arguments[i]

    isAssignable(toArg, subjectArg)
  })
}

export fn isSameType(a, b) {
  a.kind == b.kind
}
