import 'puck:js' as {Object, null, undefined}
import '../../ast/ast.puck' as {FunctionTypeBound, NamedTypeBound}
import '../../ast/visit.puck' as visit
import '../../compiler/ast.ts' as {SyntaxKind}
import '../../entities.puck' as {
  EnumType
  FunctionType
  Scope
  ObjectType
  Struct
  TupleType
  Type
  TypeClass
  isEnumType
  isFunctionType
  isObjectType
  isStruct
  isTupleType
  isTypeClass
  isTypeInstance
  isTypeParameter
}
import 'functions.puck' as {getFunctionTypeName, getTupleTypeName}

export let resolveTypeParameters = |parameterMap| fn resolveTypeParametersInner(type_) {
  let resolved = if isEnumType(type_)
    then resolveTypeParametersEnum(parameterMap, type_)
  else if isFunctionType(type_)
    then resolveTypeParametersFn(parameterMap, type_)
  else if isObjectType(type_)
    then resolveTypeParametersObject(parameterMap, type_)
  else if isTupleType(type_)
    then resolveTypeParametersTuple(parameterMap, type_)
  else if isTypeParameter(type_) {
    parameterMap[type_.name] or type_
  }

  resolved or type_
}

fn resolveTypeParametersEnum(parameterMap, e: EnumType) {
  if (isTypeClass(e))
    then createTypeInstanceTypeCast(e, e.typeParameters.map(|p| parameterMap[p.name] or p))
    else e
}

fn resolveTypeParametersFn(parameterMap, func: FunctionType) {
  Object.assign({}, func, {
    arguments: func.arguments.map(|binding| Object.assign({}, binding, {
      type_: if binding.type_
        then resolveTypeParameters(parameterMap)(binding.type_)
    }))
    returnType: if func.returnType
      then resolveTypeParameters(parameterMap)(func.returnType)
  })
}

fn resolveTypeParametersObject(parameterMap, struct: ObjectType) {
  Object.assign({}, struct, {
    properties: struct.properties.map(resolveTypeParameters(parameterMap))
  })
}

fn resolveTypeParametersTuple(parameterMap, struct: TupleType) {
  let properties = struct.properties.map(resolveTypeParameters(parameterMap))
  Object.assign({}, struct, {
    name: getTupleTypeName(properties)
    properties
  })
}

fn mapObject<T>(object: ObjectMap<T>, mapper) {
  object.map(mapper)
}

export fn createTypeInstance(class: TypeClass, typeParameters: List<Type>) {
  let typeParameters =
    if typeParameters.length < class.parameterRange.end - 1 {
      typeParameters.concat(
        class.typeParameters
          .slice(typeParameters.length)
          .map(|p| p.defaultValue)
      )
    }
    else typeParameters

  let cachedInstance = class.instances.find(|i|
    i.typeParameters.length == typeParameters.length and
    i.typeParameters.every(|p, i| isSameType(p, typeParameters[i])))

  if cachedInstance
    then return cachedInstance

  let parameterMap = ObjectMapTrait.fromList(
    ListTrait.zip(typeParameters, class.typeParameters)
      .map(|p| {
        let typeArgument = p[0]
        let typeParameter = p[1];

        (typeParameter.name, typeArgument)
      }))

  let instance = {
    isTrait: class.isTrait
    functions: if class.functions
      then mapObject(class.functions, resolveTypeParameters(parameterMap))
    members: if class.members
      then mapObject(class.members, resolveTypeParameters(parameterMap))
    properties: if class.properties
      then mapObject(class.properties, resolveTypeParameters(parameterMap))
    implementations: class.implementations and []
    kind: class.name
    name: class.name + '<' + typeParameters.map(|p| p.name).join(', ') + '>'
    class
    typeParameters
    parameterMap
  }
  class.instances.push(instance)

  instance
}

export fn createTypeInstanceTypeCast(class, typeParameters: List<Type>) {
  createTypeInstance(class, typeParameters)
}

export fn getType(scope: Scope, t, msg = '') { // t: TypeBound
  if not t then return undefined
  if t.path {
    let binding = scope.getTypePath(t.path)

    if not binding
      then binding
    else if isTypeClass(binding.type_)
      then createTypeInstanceTypeCast(binding.type_, t.typeParameters.map(|p| p.type_))
    else binding.type_
  }
  else if t.kind == SyntaxKind.ObjectTypeBound {
    let properties = mapObject(t.properties, |p| getType(scope, p.typeBound, 'ObjectTypeBound'))

    {
      kind: 'Object'
      name: 'Object'
      properties
    }
  }
  else if t.kind == SyntaxKind.TupleTypeBound {
    let properties = t.properties.map(|p| getType(scope, p, 'TupleTypeBound'))

    {
      kind: 'Tuple'
      name: getTupleTypeName(properties)
      properties
    }
  }
  else {
    let arguments = t.arguments.properties.map(|p| {{type_: getType(scope, p)}})
    let returnType = getType(scope, t.returnType)

    {
      kind: 'Function'
      name: getFunctionTypeName(arguments, returnType)
      arguments
      argumentRange: {start: arguments.length, end: arguments.length + 1}
      returnType
    }
  }
}

export fn isAssignable(to, subject) { // to: Type, subject: Type
  if not subject or not to then return true
  if isTypeParameter(to) then return true

  let sameKind = subject.kind == to.kind

  if not sameKind then return false

  if isTypeInstance(to) and isTypeInstance(subject)
    then if not subject.typeParameters.every(|p, i| isAssignable(to.typeParameters[i], p))
      then return false

  if sameKind and to.kind == 'Function'
    then isFunctionAssignable(to, subject)
  else if sameKind and to.kind == 'Tuple'
    then subject.properties.length == to.properties.length
     and subject.properties.every(|p, i| isAssignable(to.properties[i], p))
  else true
}

fn isFunctionAssignable(to: FunctionType, subject: FunctionType) {
  if not to.argumentRange.isSubsetOf(subject.argumentRange)
    then return false

  to.arguments.every(fn (toArg, i) {
    let subjectArg = subject.arguments[i]

    isAssignable(toArg, subjectArg)
  })
}

export fn isSameType(a, b) {
  a.kind == b.kind
}
