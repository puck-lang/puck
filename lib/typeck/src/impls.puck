import 'puck:js' as {global}
import 'node:util' as {inspect}
import '../../ast/ast.puck' as {
  Expression

  Block
  FunctionDeclaration
  Identifier
  ObjectDestructure
  TypeBound
  FunctionTypeBound
  NamedTypeBound
  TypeParameter
  TypePath
  VariableDeclaration

  CallExpression
}
import '../../ast/span.puck' as {ToSpan}
import '../../entities.puck' as {
  Implementation
  Type
  TypeInstance
  TypeKind
}
import 'scope.puck' as {Scope}
import 'types.puck' as {findCommonType, isAssignable, resolveTypeParameters}

fn asType(a) -> Type {a}

fn getImplementationsForInstance(type_: Type) -> List<Implementation> {
  let implementations = match type_.kind {
    TypeKind::Enum(enum_) => enum_.implementations
    TypeKind::Struct(struct) => struct.implementations
    _ => []
  }

  if implementations.size() > 1
    then if let Option::Some(objectInstance) = type_.instance
      then implementations
        .filter(|i| {
          let implementationInstance = i.type_.instance.unwrap()

          List.zip(objectInstance.typeParameters, implementationInstance.typeParameters)
            .all(|(objectP, implP)| isAssignable(implP, objectP))
        })
        .toList()
      else implementations
    else implementations
}

fn getMostSpecificImplementations(type_: Type, implementations: List<Implementation>) -> List<Implementation> {
  if let Option::Some(objectInstance) = type_.instance {
    let mut maxSpecificity = 0

    implementations
      .map(|i| {
        let specificity = getTypeSpecificity(i.type_)
        maxSpecificity = global.Math.max(maxSpecificity, specificity)
        (i, specificity)
      })
      .filter(|(_, specificity)| specificity == maxSpecificity)
      .map(|(i, _)| i)
      .toList()
  }
  else implementations
}

export fn getImplementationForTrait(type_: Type, trait_: Type) -> Result<Option<Implementation>, List<Implementation>> {
  let implementations = getImplementationsForInstance(type_)
    .filter(|i| not i.trait_.getTrait().isShorthand)
    .filter(|i| isAssignable(i.trait_, trait_))
    .toList()

  let implementations: List<Implementation> =
    if implementations.size() > 1
      then getMostSpecificImplementations(type_, implementations)
      else implementations

  if implementations.size() > 1
    then Err(implementations)
    else Ok(implementations.first())
}

export fn getImplementation(functionName: String, type_: Type, e: CallExpression) -> Result<Option<Implementation>, List<Implementation>> {
  // Implementations implemented for the correct type instance (generics)
  let implementations = getImplementationsForInstance(type_)

  // Implementations that implements the called function
  let implementations: List<Implementation> = implementations
    .filter(|i| asType(i.trait_).getTrait().functions.has(functionName))
    .toList()

  let scope: Scope = e->scope.transmute()
  // Implementations that are in scope
  let implementations: List<Implementation> =
    if implementations.size() > 1
      then implementations
        .filter(|i| scope.getBinding(asType(i.trait_).name.unwrap()).isSome())
        .toList()
      else implementations

  // Implementations that accept the correct number of arguments
  let implementations: List<Implementation> =
    if implementations.size() > 1
      then implementations
        .filter(|i| asType(asType(i.trait_).getTrait().functions[functionName]).getFunction().parameterRange
          .contains(e.argumentList.size())
        )
        .toList()
      else implementations

  // Implementations that are more specific (only for generics)
  // For example an impl for List<String> is more specific than one for List<T>
  let implementations: List<Implementation> =
    if implementations.size() > 1 and type_.instance.isSome()
      then getMostSpecificImplementations(type_, implementations)
      else implementations

  if implementations.size() > 1
    then Err(implementations)
    else Ok(implementations.first())
}

fn getTypeSpecificity(type_: Type) -> Num {
  if let TypeKind::Parameter(_) = type_.kind
    then return 0

  match type_.instance {
    Option::Some(instance) => {
      instance.typeParameters->reduce(|sum, type_| sum + getTypeSpecificity(type_), 1).transmute()
    }
    Option::None => 1
  }
}

export fn resolveImplTypeParameters(mut implementation: Implementation, objectType: Type) -> Result<Type, (Type, Type)> {
  let mut parameterMap: ObjectMap<Type> = ObjectMap.new()

  if let Some(instance) = implementation.type_.instance {
    instance.typeParameters.forEach(|p| {
      parameterMap.set(p.name.unwrap(), p)
    })

    let mut iter = List.zip(instance.typeParameters, objectType.typeParameters().unwrap()).iter()
    while true {
      if let Some((ip, op)) = iter.next() {
        if let Err(err) = collectTypeParameters(parameterMap, ip, op)
          then return Err(err)
      }
      else break
    }
  }

  Ok(resolveTypeParameters(parameterMap)(implementation.trait_))
}

fn collectTypeParameters(mut parameterMap: ObjectMap<Type>, ip: Type, op: Type) -> Result<(), (Type, Type)> {
  match ip.kind {
    TypeKind::Parameter => {
      let name = ip.name.unwrap()
      // TODO: Use findCommonType when it handles generics correctly
      // match findCommonType([parameterMap[name], op]) {
      //   Ok(type_) => parameterMap[name] = type_
      //   Err(_) => return Err((parameterMap[name], op))
      // }
      if isAssignable(parameterMap[name], op)
        then parameterMap[name] = op
        else return Err((parameterMap[name], op))
    }
    _ => {
      if let Some(instance) = ip.instance {
        let mut iter = List.zip(instance.typeParameters, op.instance.unwrap().typeParameters).iter()
        while true {
          if let Some((ip, op)) = iter.next() {
            if let Err(err) = collectTypeParameters(parameterMap, ip, op)
              then return Err(err)
          }
          else break
        }
      }
    }
  }
  Ok(())
}
