import 'puck:js' as {Error, Object, null, undefined}
import 'node:util' as {inspect}
import '../../ast/ast.puck' as {TypeDeclaration, TypeParameter, TypePath}
import '../../compiler/ast.ts' as {SyntaxKind}
import '../../entities.puck' as {Binding, isTypeClass}
import 'range.puck' as {getRange}
import 'types.puck' as {getType}

fn any(a) then a

export fn createScope(context, file, parent = false) {
  let reportError = context.reportError.bind(context, file)
  let mut bindings = {}
  let mut typeBindings = {}

  {
    parent
    createChild: |self| createScope(context, file, self)
    clearBindings: || bindings = {}
    setTypeBinding: |binding| typeBindings[binding.name] = binding

    getLocalBinding: |name| bindings[name]
    getBinding: |name| bindings[name] or (parent and parent.getBinding(name))
    getTypeBinding: |name| typeBindings[name] or (parent and parent.getTypeBinding(name))
    getTypePath: |self, typePath: TypePath| {
      if typePath.kind == 'Member'
        then self.getTypeBinding(typePath.value[0].name)
        else {
          let mut type_ = self.getTypeBinding(typePath.value[0].name).type_
          let mut path = typePath.value[1]

          while path.kind == 'Object' {
            type_ = type_.members[path.value[0].name]
            path = path.value[1]
          }

          {
            name: path.value[0].name
            type_: type_.members[path.value[0].name]
          }
        }
    }

    define: |self, mut binding: Binding, allowRedeclare = false| {
      let name = binding.name
      if not name then throw Error('Missing name')
      binding.allowRedeclare = allowRedeclare
      binding.redefined = bindings[name] != undefined
      if binding.redefined {
        if not allowRedeclare or not bindings[name].allowRedeclare
          then reportError(binding.token, '$name has already been declared in the scope' + inspect(self))
        bindings[name].redefined = true
        binding.previous = bindings[name]
      }
      bindings[name] = binding
    }
    defineType: |self, t: TypeDeclaration, allowRedeclare = false| {
      let name = t.name.name
      if not allowRedeclare and typeBindings[name]
        then reportError(t, 'Type $name is already defined')

      let parameterRange = if t.typeParameters and t.typeParameters.length
        then getRange(t.typeParameters, |p: TypeParameter| p.defaultValue.isJust(), reportError, 'type parameter')

      let type_ =
        if t.type_
          then t.type_
          else {
            let mut type_ = {
              kind: name
              name
              parameterRange
            }

            if t.kind == SyntaxKind.EnumDeclaration {
              type_.implementations = []
              type_.members = {}
            }
            else if t.kind == SyntaxKind.TraitDeclaration {
              type_.functions = {}
            }
            else if t.kind == SyntaxKind.TypeDeclaration {
              type_.implementations = []
              if let Option::Some(typeBound) = t.bound {
                if typeBound.kind == SyntaxKind.ObjectTypeBound
                  then type_.properties = Object.create(null)
                else if typeBound.kind == SyntaxKind.TupleTypeBound
                  then type_.properties = []
              }
            }
            else if t.kind == SyntaxKind.TypeParameter {
              type_.isTypeParameter = true
              let p: TypeParameter = any(t)
              if let Option::Some(defaultValue) = p.defaultValue {
                type_.defaultValue = getType(self, defaultValue)
              }
            }
            if isTypeClass(type_) {
              type_.instances = []
              type_.typeParameters = []
            }

            type_
          }

      if allowRedeclare and typeBindings[name] {
        Object.assign(typeBindings[name].type_, type_)
        typeBindings[name]
      }
      else typeBindings[name] = {
        name
        token: t
        type_
      }
    }
    inspect: |depth, opts| {
      let mut scope = {}
      if parent then scope['[parent]'] = parent.inspect()
      Object.assign(scope, bindings)

      if not depth and not opts
        then scope
        else inspect(scope, Object.assign({}, opts, {depth}))
    }
  }
}
