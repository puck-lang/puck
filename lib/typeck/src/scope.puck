import 'puck:js' as {Error, Object, null, undefined}
import 'node:util' as {inspect}
import '../../ast/ast.puck' as {TypeDeclaration, TypeParameter, TypePath}
import '../../compiler/ast.ts' as {SyntaxKind}
import '../../entities.puck' as {Binding, Type}
import 'types.puck' as {getType}

export fn createScope(context, file, parent = false) {
  let reportError = context.reportError.bind(context, file)
  let mut bindings = ObjectMap.new()
  let mut typeBindings = ObjectMap.new()

  {
    parent
    setSelfBinding: |self, selfType| typeBindings['Self'] = self.getTypeBinding(selfType)
    createChild: |self| createScope(context, file, self)
    clearBindings: || bindings = ObjectMap.new()
    setTypeBinding: |binding| typeBindings[binding.name] = binding

    getLocalBinding: |name| bindings[name]
    getBinding: |name| {
      let mut binding = bindings[name] or (parent and parent.getBinding(name))
      if binding.inherit {
        binding.type_ = binding.inherit.type_
        if not binding.type_ {
          context.runCheckerOnFile(binding.importedFrom.file)
          let externalBinding = binding.importedFrom.module.scope.getBinding(
            binding.token.property.name
          )

          binding.type_ = externalBinding.type_
        }
      }
      binding
    }
    getTypeBinding: |name| typeBindings[name] or (parent and parent.getTypeBinding(name))
    getTypePath: |self, typePath: TypePath| {
      // match typePath {
      //   TypePath::Member({name}) => self.getTypeBinding(name)
      //   TypePath::Object({name}, path) => {
      //     let mut name_ = name
      //     let mut path_ = path
      //     let mut type_ = self.getTypeBinding(name).type_

      //     while true {
      //       type_ = type_.members[name]
      //       match path {
      //         TypePath::Member({name}) => {
      //           name_ = name
      //           break
      //         }
      //         TypePath::Object({name}, path) => {
      //           name_ = name
      //           path_ = path
      //         }
      //       }
      //     }

      //     {
      //       name: name_
      //       type_
      //     }
      //   }
      // }
      if typePath.kind == 'Member'
        then self.getTypeBinding(typePath.value[0].name)
        else {
          let mut type_ = self.getTypeBinding(typePath.value[0].name).type_
          let mut path = typePath.value[1]

          while path.kind == 'Object' {
            type_ = type_.members[path.value[0].name]
            path = path.value[1]
          }

          {
            name: path.value[0].name
            type_: type_.members[path.value[0].name]
          }
        }
    }

    define: |self, mut binding: Binding, allowRedeclare = false| {
      let name = binding.name
      if not name then throw Error('Missing name')
      binding.allowRedeclare = allowRedeclare
      binding.redefined = bindings[name] != undefined
      if binding.redefined {
        if not allowRedeclare or not bindings[name].allowRedeclare
          then reportError(binding.token, '$name has already been declared in the scope' + inspect(self))
        bindings[name].redefined = true
        binding.previous = bindings[name]
      }
      bindings[name] = binding
    }
    defineType: |self, type_: Type, token, allowRedeclare = false| {
      let name = type_.name.unwrap()
      if name == 'Self'
        then reportError(token, 'Self is a reserved name')
      if not allowRedeclare and typeBindings[name]
        then reportError(token, 'Type $name is already defined')

      if allowRedeclare and typeBindings[name] {
        Object.assign(typeBindings[name].type_, type_)
        typeBindings[name]
      }
      else typeBindings[name] = {
        name
        token
        type_
      }
    }
    inspect: |depth, opts| {
      '[Scope]'
      // let mut scope = {}
      // if parent then scope['[parent]'] = parent.inspect()
      // Object.assign(scope, bindings)

      // if not depth and not opts
      //   then scope
      //   else inspect(scope, Object.assign({}, opts, {depth}))
    }
  }
}
