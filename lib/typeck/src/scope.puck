import 'puck:js' as {Error, Object, null, undefined}
import 'node:util' as {inspect}
import '../../ast/ast.puck' as {TypeDeclaration, TypeParameter, TypePath}
import '../../ast/span.puck' as {ToSpan}
import '../../compiler/ast.ts' as {SyntaxKind}
import '../../entities.puck' as {Binding, Scope, Type}

export fn createScope(context, file, parent = false) -> Scope {
  let reportError: (ToSpan, String) -> {} = context.reportError.bind(context, file)
  let mut bindings = ObjectMap.new()
  let mut typeBindings = ObjectMap.new()

  {
    parent
    setSelfBinding: |self, selfType| typeBindings['Self'] = self.getTypeBinding(selfType)
    createChild: |self| createScope(context, file, self)
    clearBindings: || bindings = ObjectMap.new()
    setTypeBinding: |binding| typeBindings[binding.name] = binding

    getLocalBinding: |name| bindings[name]
    getBinding: |name| {
      let mut binding = bindings[name] or (parent and parent.getBinding(name))
      if binding.importedFrom and not binding.inherit {
        context.runCheckerOnFile(binding.importedFrom.file)
        let externalBinding = binding.importedFrom.module.scope.getBinding(
          binding.token.property.name
        )
        binding.inherit = externalBinding
        binding.type_ = externalBinding.type_

      }
      else if binding.inherit {
        binding.type_ = binding.inherit.token.type_
        if not binding.type_ {
          context.runCheckerOnFile(binding.importedFrom.file)
          let externalBinding = binding.importedFrom.module.scope.getBinding(
            binding.token.property.name
          )

          binding.type_ = externalBinding.type_
        }
      }
      binding
    }
    getTypeBinding: |name| typeBindings[name] or (parent and parent.getTypeBinding(name))
    getTypePath: |self, typePath: TypePath| {
      match typePath {
        TypePath::Member({name}) => {
          let binding = self.getTypeBinding(name)

          if binding
            then Ok(binding)
            else Err('Use of undeclared type $name')
        }
        TypePath::Object({name}, path) => {
          let mut name_ = name
          let mut path_ = path
          let binding = self.getTypeBinding(name)
          if not binding
            then return Err('Use of undeclared type $name')
          let mut type_: Type = binding.type_

          while true {
            let mut displayPath = '$name'
            match path_ {
              TypePath::Member({name}) => {
                name_ = name
                type_ = type_.getEnum().members[name]
                if not type_
                  then return Err('Use of undeclared type $displayPath::$name')
                break
              }
              TypePath::Object({name}, path) => {
                name_ = name
                path_ = path
                type_ = type_.getEnum().members[name]
                if not type_
                  then return Err('Use of undeclared type $displayPath::$name')
                displayPath = '$displayPath::$name'
              }
            }
          }

          Ok({
            name: name_
            type_
            token: binding.token
          })
        }
      }
    }

    define: |self, mut binding: Binding, allowRedeclare = false| {
      let name = binding.name
      if not name then throw Error('Missing name')
      binding.allowRedeclare = allowRedeclare
      binding.redefined = bindings[name] != undefined
      if binding.redefined {
        if not allowRedeclare or not bindings[name].allowRedeclare
          then reportError(binding.token, '$name has already been declared in the scope' + inspect(self))
        bindings[name].redefined = true
        binding.previous = bindings[name]
      }
      bindings[name] = binding
    }
    defineType: |self, type_: Type, token: ToSpan, allowRedeclare = false| {
      let name = type_.name.unwrap()
      if name == 'Self'
        then reportError(token, 'Self is a reserved name')
      if not allowRedeclare and typeBindings[name]
        then reportError(token, 'Type $name is already defined')

      if allowRedeclare and typeBindings[name] {
        Object.assign(typeBindings[name].type_, type_)
        typeBindings[name]
      }
      else typeBindings[name] = {
        name
        token
        type_
      }
    }
    inspect: |depth, opts| {
      '[Scope]'
      // let mut scope = {}
      // if parent then scope['[parent]'] = parent.inspect()
      // Object.assign(scope, bindings)

      // if not depth and not opts
      //   then scope
      //   else inspect(scope, Object.assign({}, opts, {depth}))
    }
  }
}
