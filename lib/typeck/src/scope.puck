import 'puck:js' as {Error, Object, null, undefined}
import 'node:util' as {inspect}
import '../../ast/ast.puck' as {TypeDeclaration, TypeParameter, TypePath}
import '../../ast/span.puck' as {ToSpan}
import '../../compiler/ast.ts' as {SyntaxKind}
import '../../entities.puck' as {Binding, Scope, Type}

export fn createScope(context, file, parent = false) -> Scope {
  let reportError: (ToSpan, String) -> {} = context.reportError.bind(context, file)
  let mut bindings = ObjectMap.new()
  let mut typeBindings = ObjectMap.new()

  {
    parent
    setSelfBinding: |self, selfType| typeBindings['Self'] = self.getTypeBinding(selfType)
    createChild: |self| createScope(context, file, self)
    clearBindings: || bindings = ObjectMap.new()
    setTypeBinding: |binding| typeBindings[binding.name] = binding

    getLocalBinding: |name| bindings[name]
    getBinding: |name| {
      let mut binding = bindings[name] or (parent and parent.getBinding(name))
      if binding.inherit {
        binding.type_ = binding.inherit.type_
        if not binding.type_ {
          context.runCheckerOnFile(binding.importedFrom.file)
          let externalBinding = binding.importedFrom.module.scope.getBinding(
            binding.token.property.name
          )

          binding.type_ = externalBinding.type_
        }
      }
      binding
    }
    getTypeBinding: |name| typeBindings[name] or (parent and parent.getTypeBinding(name))
    getTypePath: |self, typePath: TypePath| {
      match typePath {
        TypePath::Member({name}) => self.getTypeBinding(name)
        TypePath::Object({name}, path) => {
          let mut name_ = name
          let mut path_ = path
          let mut type_: Type = self.getTypeBinding(name).type_

          while true {
            // if not type_.members {
            //   print('type_.members', type_)
            // }
            match path_ {
              TypePath::Member({name}) => {
                name_ = name
                type_ = type_.getEnum().members[name]
                break
              }
              TypePath::Object({name}, path) => {
                name_ = name
                path_ = path
                type_ = type_.getEnum().members[name]
              }
            }
          }

          {
            name: name_
            type_
          }
        }
      }
    }

    define: |self, mut binding: Binding, allowRedeclare = false| {
      let name = binding.name
      if not name then throw Error('Missing name')
      binding.allowRedeclare = allowRedeclare
      binding.redefined = bindings[name] != undefined
      if binding.redefined {
        if not allowRedeclare or not bindings[name].allowRedeclare
          then reportError(binding.token, '$name has already been declared in the scope' + inspect(self))
        bindings[name].redefined = true
        binding.previous = bindings[name]
      }
      bindings[name] = binding
    }
    defineType: |self, type_: Type, token: ToSpan, allowRedeclare = false| {
      let name = type_.name.unwrap()
      if name == 'Self'
        then reportError(token, 'Self is a reserved name')
      if not allowRedeclare and typeBindings[name]
        then reportError(token, 'Type $name is already defined')

      if allowRedeclare and typeBindings[name] {
        Object.assign(typeBindings[name].type_, type_)
        typeBindings[name]
      }
      else typeBindings[name] = {
        name
        token
        type_
      }
    }
    inspect: |depth, opts| {
      '[Scope]'
      // let mut scope = {}
      // if parent then scope['[parent]'] = parent.inspect()
      // Object.assign(scope, bindings)

      // if not depth and not opts
      //   then scope
      //   else inspect(scope, Object.assign({}, opts, {depth}))
    }
  }
}
