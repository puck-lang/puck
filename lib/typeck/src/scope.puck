import 'puck:js' as {Error, Object, null, undefined}
import 'node:util' as {inspect}
import '../../ast/ast.puck' as {Module, Identifier, TypePath}
import '../../ast/span.puck' as {Span, ToSpan}
import '../../compiler/ast.ts' as {SyntaxKind}
import '../../entities.puck' as {Type}

export type Binding {
  name: String
  token: ToSpan
  mutable: Bool
  allowRedeclare: Bool
  type_: Type
  previous: Option<Binding>
  importedFrom: Option<Module>
}

export type Scope {
  context: {}
  parent: Option<Scope>
  bindings: ObjectMap<Binding>
}

impl Scope {
  fn new(context) -> Scope {{
    context
    parent: None
    bindings: ObjectMap.new()
  }}

  fn createChild(self) -> Scope {{
    context: self.context
    parent: Some(self)
    bindings: ObjectMap.new()
  }}

  fn getBinding(self, name: String, visitor = '') -> Option<Binding> {
    self.bindings
      .get(name)
      .orElse(|| self.parent.andThen(|p| p.getBinding(name, visitor)))
      .map(|mut binding| {
        if let Option::Some(module) = binding.importedFrom {
          if not (binding.type_ and binding.type_.completed) and visitor != 'TypeVisitor' {
            if visitor == 'TypeVisitor' {
              self.context.runTypeVisitorOnFile(module.file)
            } else {
              self.context.runCheckerOnFile(module.file)
            }
            let moduleScope: Scope = module.scope
            let externalBinding = moduleScope.getBinding(
              binding.token.property.name
              visitor
            )
            binding.type_ = externalBinding.unwrap().type_
          }
        }
        binding
      })
  }

  fn define(mut self, binding: Binding) -> Result<Binding, String> {
    if binding.name == 'Self'
      then return Err('Self is a reserved name')

    let previous =
      match self.bindings.get(binding.name) {
        Option::Some(previous) => {
          if previous.allowRedeclare
            then Some(previous)
            else return Err(binding.name + ' is already defined')
        }
        Option::None => None
      }

    let binding: Binding = {
      name: binding.name
      token: binding.token
      mutable: binding.mutable
      allowRedeclare: binding.allowRedeclare
      type_: binding.type_
      importedFrom: binding.importedFrom
      previous
    }

    self.bindings.set(binding.name, binding)
    Ok(binding)
  }

  fn setSelfType(mut self, mut selfType: Type) -> () {
    self.bindings.set('Self', {
      name: 'Self'
      token: Span.empty()
      mutable: false
      allowRedeclare: false
      type_: Type.provides(selfType)
      previous: None
      importedFrom: None
    })
  }

  fn getTypePath(self, typePath: TypePath, visitor = '') -> Result<Binding, String> {
    match typePath {
      TypePath::Member({name}) => {
        self.getBinding(name, visitor)
          .okOr('Use of undeclared type $name')
      }
      TypePath::Object(identifier, path) => {
        let mut token: ToSpan = identifier
        let mut name = identifier.name
        let mut path_ = path
        let binding =
          match self.getBinding(name, visitor) {
            Option::Some(binding) => binding
            Option::None => return Err('Use of undeclared type $name')
          }
        let mut type_: Type = binding.type_

        while true {
          let mut displayPath = '$name'
          match path_ {
            TypePath::Member(identifier) => {
              token = identifier
              name = identifier.name
              match type_.providesType.unwrap().getEnum().members.get(name) {
                Option::Some(memberType) => type_ = memberType
                Option::None => return Err('Use of undeclared type $displayPath::$name')
              }
              break
            }
            TypePath::Object(identifier, path) => {
              token = identifier
              name = identifier.name
              path_ = path
              type_ =
                match type_.getEnum().members.get(name) {
                  Option::Some(type_) => type_
                  Option::None => return Err('Use of undeclared type $displayPath::$name')
                }
              displayPath = '$displayPath::$name'
            }
          }
        }

        Ok(Binding({
          name
          token
          mutable: binding.mutable
          allowRedeclare: binding.allowRedeclare
          type_
          previous: binding.previous
          importedFrom: binding.importedFrom
        }))
      }
    }
  }
}
