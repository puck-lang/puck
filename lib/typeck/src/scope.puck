import 'puck:js' as {Error, Object, null, undefined}
import 'node:util' as {inspect}
import '../../ast/ast.puck' as {TypeDeclaration, TypeParameter}
import '../../compiler/ast.ts' as {SyntaxKind}
import '../../entities.puck' as {Binding, isTypeClass}
import 'range.puck' as {getRange}
import 'types.puck' as {getType}

fn any(a) then a

export fn createScope(context, file, parent = false) {
  let reportError = context.reportError.bind(context, file)
  let mut bindings = {}
  let mut typeBindings = {}

  {
    parent
    createChild: |self| createScope(context, file, self)
    clearBindings: || bindings = {}
    setTypeBinding: |binding| typeBindings[binding.name] = binding

    getLocalBinding: |name| bindings[name]
    getBinding: |name| bindings[name] or (parent and parent.getBinding(name))
    getTypeBinding: |name| typeBindings[name] or (parent and parent.getTypeBinding(name))

    define: |self, mut binding: Binding, allowRedeclare = false| {
      let name = binding.name
      if not name then throw Error('Missing name')
      binding.allowRedeclare = allowRedeclare
      binding.redefined = bindings[name] != undefined
      if binding.redefined {
        if not allowRedeclare or not bindings[name].allowRedeclare
          then reportError(binding.token, '$name has already been declared in the scope' + inspect(self))
        bindings[name].redefined = true
        binding.previous = bindings[name]
      }
      bindings[name] = binding
    }
    defineType: |self, t: TypeDeclaration, allowRedeclare = false| {
      let name = t.name.name
      if not allowRedeclare and typeBindings[name]
        then reportError(t, 'Type $name is already defined')

      let parameterRange = if t.typeParameters and t.typeParameters.length
        then getRange(t.typeParameters, |p: TypeParameter| p.defaultValue.isJust(), reportError, 'type parameter')

      let ty =
        if t.ty
          then t.ty
          else {
            let mut ty = {
              kind: name
              name
              parameterRange
            }

            if t.kind == SyntaxKind.EnumDeclaration {
              ty.implementations = []
              ty.members = {}
            }
            else if t.kind == SyntaxKind.TraitDeclaration {
              ty.functions = {}
            }
            else if t.kind == SyntaxKind.TypeDeclaration {
              ty.implementations = []
              if t.bound.isJust() {
                if t.bound.value[0].kind == SyntaxKind.ObjectTypeBound
                  then ty.properties = Object.create(null)
                else if t.bound.value[0].kind == SyntaxKind.TupleTypeBound
                  then ty.properties = []
              }
            }
            else if t.kind == SyntaxKind.TypeParameter {
              ty.isTypeParameter = true
              let p: TypeParameter = any(t)
              if p.defaultValue.isJust() {
                ty.defaultValue = getType(self, t.defaultValue.value[0])
              }
            }
            if isTypeClass(ty) {
              ty.instances = []
              ty.typeParameters = []
            }

            ty
          }

      if allowRedeclare and typeBindings[name] {
        Object.assign(typeBindings[name].ty, ty)
        typeBindings[name]
      }
      else typeBindings[name] = {
        name
        token: t
        ty
      }
    }
    inspect: |depth, opts| {
      let mut scope = {}
      if parent then scope['[parent]'] = parent.inspect()
      Object.assign(scope, bindings)

      if not depth and not opts
        then scope
        else inspect(scope, Object.assign({}, opts, {depth}))
    }
  }
}
