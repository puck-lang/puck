import 'puck:js' as {Object, undefined}
import '../ast/ast.puck' as {
  Expression

  Block
  FunctionDeclaration
  Identifier
  Module
  ObjectDestructure
  TypeBound
  FunctionTypeBound
  NamedTypeBound
  TraitDeclaration
  TypeDeclaration
  TypeParameter
  TypeProperty
  VariableDeclaration

  ExportDirective
  ImportDirective

  AssignmentExpression
  BinaryExpression
  CallExpression
  ForExpression
  IfExpression
  LoopExpression
  UnaryExpression
  WhileExpression

  IndexAccess
  MemberAccess

  Token
  ReturnStatement

  ListLiteral
  BooleanLiteral
  NumberLiteral
  ObjectLiteral
  StringLiteral
}
import '../ast/visit.puck' as visit
import '../compiler/ast.ts' as {SyntaxKind}

type Binding = {
  identifier: Identifier
  mutable: Bool
  redefined: Bool
  previous: Binding //?
}

type TypeBinding = {
  name: Identifier
  // parameters: {min: Num, max: Num}
}

type Scope = {
  getLocalBinding: (String) => Binding
  getBinding: (String) => Binding
  define: (String, Binding) => Binding
}

type ScopeAware = {
  scope: Scope
}

fn createScope(context, file, parent) {
  let reportError = context.reportError.bind(context, file)
  let bindings = {}
  let typeBindings = {}

  {
    parent
    getLocalBinding: |name| bindings[name]
    getBinding: |name| bindings[name] or (parent and parent.getBinding(name))
    getTypeBinding: |name| typeBindings[name] or (parent and parent.getTypeBinding(name))
    define: |mut binding: Binding| {
      let name = binding.identifier.name
      binding.redefined = bindings[name] != undefined
      if binding.redefined {
        bindings[name].redefined = true
        binding.previous = bindings[name]
      }
      bindings[name] = binding
    }
    defineType: |t: TypeDeclaration| {
      let name = t.name.name
      if typeBindings[name]
        then reportError(t, 'Type $name is already defined')

      let parameters =
        if t.parameters {
          let mut firstOptional = t.parameters.length
          let mut hasOptional = false

          t.parameters.forEach(|t, i|
            if t.defaultValue and not hasOptional {
              hasOptional = true
              firstOptional = i
            }
            else if not t.defaultValue and hasOptional then reportError(t
              "An optional type paramterer can't be followed by a required type parameter"
            )
          )

          {
            min: firstOptional
            max: t.parameters.length
          }
        }
        else {{min: 0, max: 0}}

      typeBindings[name] = {
        name: t.name
        parameters
      }
    }
  }
}

fn defineFunction(scope, f: FunctionDeclaration) {
  if f.name then
    scope.define({identifier: f.name, mutable: false})
}

fn definedHosted(scope, expressions: List<Expression>) {
  expressions.forEach(|e| {
    if e.scope then return undefined

    if e.kind == SyntaxKind.Function {
      defineFunction(scope, e)
      e.hoisted = true
    }
    if e.kind == SyntaxKind.ExportDirective and
        e.expression.kind == SyntaxKind.Function {
      defineFunction(scope, e.expression)
      e.expression.hoisted = true
    }
  })
}

export fn TopScopeVisitor(context, file) {
  let mut scope = createScope(context, file)
  let reportError = context.reportError.bind(context, file)

  Object.assign({}, visit.Visitor, {

    visitBlock: |self, b: Block| {}
    visitFunctionDeclaration: |self, f: FunctionDeclaration| {
      f.scope = scope
      if not f.hoisted then defineFunction(scope, f)
    }
    visitIdentifier: |self, i: Identifier| {}
    visitModule: |self, m: Module| {
      m.scope = scope
      definedHosted(scope, m.lines)
      visit.walkModule(self, m)
    }
    visitObjectDestructure: |self, i: ObjectDestructure| {
      i.scope = scope
      i.members.forEach(|m| scope.define({identifier: m.local, mutable: false}))
    }
    visitTraitDeclaration: |self, t: TraitDeclaration| {
      t.scope = scope
      scope.defineType(t)
    }
    visitTypeBound: |self, t: TypeBound| {}
    visitTypeDeclaration: |self, t: TypeDeclaration| {
      t.scope = scope
      scope.defineType(t)
    }
    visitVariableDeclaration: |self, d: VariableDeclaration| {
      d.scope = scope
      scope.define({identifier: d.identifier, mutable: d.mutable})
    }

    visitExportDirective: |self, e: ExportDirective| {
      e.scope = scope
      visit.walkExportDirective(self, e)
    }
    visitImportDirective: |self, i: ImportDirective| {
      if i.specifier.kind == SyntaxKind.Identifier
        then scope.define({identifier: i.specifier, mutable: false})
      else if i.specifier.kind == SyntaxKind.ObjectDestructure
        then visit.walkImportDirective(self, i)
    }

    visitAssignmentExpression: |self, e: AssignmentExpression| {}
    visitBinaryExpression: |self, e: BinaryExpression| {}
    visitCallExpression: |self, e: CallExpression| {}
    visitForExpression: |self, e: ForExpression| {}
    visitIfExpression: |self, e: IfExpression| {}
    visitLoopExpression: |self, e: LoopExpression| {}
    visitUnaryExpression: |self, e: UnaryExpression| {}
    visitWhileExpression: |self, e: WhileExpression| {}
    visitIndexAccess: |self, a: IndexAccess| {}
    visitMemberAccess: |self, a: MemberAccess| {}

    visitBreak: |self, b: Token| {}
    visitReturn: |self, r: ReturnStatement| {}

    visitListLiteral: |self, l: ListLiteral| {}
    visitBooleanLiteral: |self, l: BooleanLiteral| {}
    visitNumberLiteral: |self, l: NumberLiteral| {}
    visitObjectLiteral: |self, l: ObjectLiteral| {}
    visitStringLiteral: |self, l: StringLiteral| {}
  })
}

export fn ScopeVisitor(context, file) {
  let mut importDirective: ImportDirective
  let mut scope: Scope
  let reportError = context.reportError.bind(context, file)

  Object.assign({}, visit.Visitor, {

    visitBlock: |self, b: Block| {
      b.scope = scope
      definedHosted(scope, b.block)
      visit.walkBlock(self, b)
    }
    visitFunctionDeclaration: |self, f: FunctionDeclaration| {
      if not f.scope and not f.hoisted then defineFunction(scope, f)
      scope = createScope(context, file, scope)
      f.scope = scope
      visit.walkFunction(self, f)
      scope = scope.parent
    }
    visitIdentifier: |self, i: Identifier| {
      i.scope = scope
      let binding = i.scope.getBinding(i.name)
      if not binding then reportError(i, 'Use of undefined variable ' + i.name)
      visit.walkIdentifier(self, i)
    }
    visitModule: |self, m: Module| {
      scope = m.scope
      visit.walkModule(self, m)
    }
    visitObjectDestructure: |self, i: ObjectDestructure| {
      i.scope = scope
      i.members.forEach(|m| {
        if importDirective.module {
          let e = importDirective.module.exports[m.local.name]
          if e.expression.kind == SyntaxKind.TypeDeclaration
            then scope.defineType(e.expression)
            else scope.define({identifier: m.local, mutable: false})
        }
        else scope.define({identifier: m.local, mutable: false})
      })
    }
    visitTraitDeclaration: |self, t: TraitDeclaration| {
      scope = createScope(context, file, scope)
      t.scope = scope
      visit.walkTraitDeclaration(self, t)
      scope = scope.parent
    }
    visitFunctionTypeBound: |self, t: FunctionTypeBound| {
      scope = createScope(context, file, scope)
      t.scope = scope
      visit.walkFunctionTypeBound(self, t)
      scope = scope.parent
    }
    visitNamedTypeBound: |self, t: NamedTypeBound| {
      t.scope = scope

      let binding = t.scope.getTypeBinding(t.name.name)
      if not binding then reportError(t, 'Use of undeclared type ' + t.name.name)

      let parameterCount = t.parameters.length
      if parameterCount < binding.parameters.min
        then reportError(t
          'To few type parameters given to ' + t.name.name + ' min ' +
          binding.parameters.min + ' required, ' + parameterCount + ' given'
        )
      if parameterCount > binding.parameters.max
        then reportError(t
          if binding.parameters.max == 0
            then 'Type ' + t.name.name + ' is not generic'
            else 'To many type parameters given to ' + t.name.name + ' max ' +
              binding.parameters.max + ' required, ' + parameterCount + ' given'
        )

      visit.walkNamedTypeBound(self, t)
    }
    visitTypeDeclaration: |self, t: TypeDeclaration| {
      scope = createScope(context, file, scope)
      visit.walkTypeDeclaration(self, t)
      scope = scope.parent
    }
    visitTypeParameter: |self, t: TypeParameter| {
      t.scope = scope
      scope.defineType(t)
      visit.walkTypeParameter(self, t)
    }
    visitVariableDeclaration: |self, d: VariableDeclaration| {
      if d.typeBound then self.visitTypeBound(d.typeBound)
      if not d.scope {
        d.scope = scope
        scope.define({identifier: d.identifier, mutable: d.mutable})
      }
      if d.initializer then self.visitExpression(d.initializer)
    }

    // visitExportDirective: |self, e: ExportDirective| {
    //   visit.walkExportDirective(self, e)
    // }
    visitImportDirective: |self, i: ImportDirective| {
      i.scope = scope
      if i.specifier.kind == SyntaxKind.Identifier
        then scope.define({identifier: i.specifier, mutable: false})
      else if i.specifier.kind == SyntaxKind.ObjectDestructure {
        importDirective = i
        visit.walkImportDirective(self, i)
      }
    }

    visitAssignmentExpression: |self, e: AssignmentExpression| {
      e.scope = scope
      if e.lhs.kind == SyntaxKind.Identifier {
        let binding = e.scope.getBinding(e.lhs.name)
        if binding and not binding.mutable
          then reportError(e, "Can't assign to immutable variable " + e.lhs.name)
      }
      visit.walkAssignmentExpression(self, e)
    }
    visitBinaryExpression: |self, e: BinaryExpression| {
      e.scope = scope
      visit.walkBinaryExpression(self, e)
    }
    visitCallExpression: |self, e: CallExpression| {
      e.scope = scope
      visit.walkCallExpression(self, e)
    }
    visitForExpression: |self, e: ForExpression| {
      scope = createScope(context, file, scope)
      e.scope = scope
      visit.walkForExpression(self, e)
      scope = scope.parent
    }
    visitIfExpression: |self, e: IfExpression| {
      scope = createScope(context, file, scope)
      e.scope = scope
      visit.walkIfExpression(self, e)
      scope = scope.parent
    }
    visitLoopExpression: |self, e: LoopExpression| {
      scope = createScope(context, file, scope)
      e.scope = scope
      visit.walkLoopExpression(self, e)
      scope = scope.parent
    }
    visitUnaryExpression: |self, e: UnaryExpression| {
      e.scope = scope
      visit.walkUnaryExpression(self, e)
    }
    visitWhileExpression: |self, e: WhileExpression| {
      scope = createScope(context, file, scope)
      e.scope = scope
      visit.walkWhileExpression(self, e)
      scope = scope.parent
    }
    visitIndexAccess: |self, a: IndexAccess| {
      a.scope = scope
      visit.walkIndexAccess(self, a)
    }
    visitMemberAccess: |self, a: MemberAccess| {
      a.scope = scope
      visit.walkExpression(self, a.object)
    }

    visitBreak: |self, b: Token| {
      b.scope = scope
      visit.walkBreak(self, b)
    }
    visitReturn: |self, r: ReturnStatement| {
      r.scope = scope
      visit.walkReturn(self, r)
    }

    visitListLiteral: |self, l: ListLiteral| {
      l.scope = scope
      visit.walkListLiteral(self, l)
    }
    visitBooleanLiteral: |self, l: BooleanLiteral| {
      l.scope = scope
      visit.walkBooleanLiteral(self, l)
    }
    visitNumberLiteral: |self, l: NumberLiteral| {
      l.scope = scope
      visit.walkNumberLiteral(self, l)
    }
    visitObjectLiteral: |self, l: ObjectLiteral| {
      l.scope = scope
      l.members.forEach(|m| {
        self.visitExpression(m.value)
      })
    }
    visitStringLiteral: |self, l: StringLiteral| {
      l.scope = scope
      visit.walkStringLiteral(self, l)
    }
  })
}

