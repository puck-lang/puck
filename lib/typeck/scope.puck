import 'node:util' as {inspect}
import 'puck:js' as {Object, undefined}
import '../ast/ast.puck' as {
  Expression

  Block
  FunctionDeclaration
  Identifier
  ImplDeclaration
  Module
  ObjectDestructure
  TypeBound
  FunctionTypeBound
  NamedTypeBound
  TraitDeclaration
  TypeDeclaration
  TypeParameter
  TypeProperty
  VariableDeclaration

  ExportDirective
  ImportDirective

  AssignmentExpression
  BinaryExpression
  CallExpression
  ForExpression
  IfExpression
  LoopExpression
  UnaryExpression
  WhileExpression

  IndexAccess
  MemberAccess

  Token
  ReturnStatement

  ListLiteral
  BooleanLiteral
  NumberLiteral
  ObjectLiteral
  StringLiteral
}
import '../ast/visit.puck' as visit
import '../compiler/ast.ts' as {SyntaxKind}

type MinMax = {
  min: Num
  max: Num
}

/// Represents a simple type like String or Num
type Type = {
  kind: String
  name: String
}

type Struct = {
  implementations: List<Implementation>
  // properties: Object<Type>
}

type Trait = {
  // functions: Object<FunctionType>
}

type Implementation = {
  ty: Struct
  tra: Trait
}

/// Represents a generic type like List<T>
type TypeClass = { // + Type
  parameterRange: MinMax
  instances: List<TypeInstance>
}

/// Represents an instance of a generic type like List<String> or List<Num>
type TypeInstance = { // + Type
  class: TypeClass
  typeParameters: List<Type>
}

/// Represents a function type (Num, Num) => Bool
type FunctionType = { // + Type
  arguments: List<Binding>
  argumentRange: MinMax
  returnType: Type
  isAbstract: Bool
}

type GenericFunction = {}  // FunctionType + TypeClass
type GenericFunctionInstace = {}  // FunctionType + TypeInstance

type Binding = {
  identifier: Identifier
  token: Token
  mutable: Bool
  ty: Type //?
  redefined: Bool
  previous: Binding //?
}

type TypeBinding = {
  name: String
  ty: Type //?
}

type Scope = {
  getLocalBinding: (String) => Binding
  // getBinding: (String, allowRedeclare = true) => Binding
  getBinding: (String) => Binding
  getTypeBinding: (String) => Binding
  define: (String, Binding) => Binding
  defineType: (String, Binding) => Binding
}

type ScopeAware = {
  scope: Scope
}

fn isStruct(ty) {
  ty.implementations
}

fn isTrait(ty) {
  ty.isTrait
}

fn isTypeClass(ty: Type) {
  ty.parameterRange
}

fn isSameType(a, b) {
  a.kind == b.kind
}

fn createTypeInstance(class: TypeClass, typeParameters: List<Type>) {
  if let instance = class.instances.find(|i|
      i.typeParameters.length == typeParameters.length
  and i.typeParameters.every(|p, i| isSameType(p, typeParameters[i])))
    then instance
    else {
      let instance = {
        isTrait: class.isTrait
        functions: class.functions
        implementations: class.implementations and []
        kind: class.name + '<' + typeParameters.map(|p| p.name).join(', ') + '>'
        name: class.name + '<' + typeParameters.map(|p| p.name).join(', ') + '>'
        class
        typeParameters
      }
      class.instances.push(instance)
      instance
    }
}

fn getType(scope: Scope, t) { // t: TypeBound
  if not t then return undefined
  if t.name {
    let binding = scope.getTypeBinding(t.name.name)

    if not binding
      then binding
    else if isTypeClass(binding.ty)
      then createTypeInstance(binding.ty, t.typeParameters.map(|p| p.ty))
    else binding.ty
  }
  else {
    let arguments = t.arguments.map(|p| {{ty: getType(scope, p)}})
    let returnType = getType(scope, t.returnType)

    {
      kind: 'Function'
      name: getFunctionTypeName(arguments, returnType)
      arguments
      argumentRange: {min: arguments.length, max: arguments.length}
      returnType
    }
  }
}

fn getFunctionTypeName(arguments: List<TypeInstance>, returnType: TypeInstance)
  then '(' + arguments.map(|a| (a and a.name) or '??').join(', ') + ') => ' +
        (returnType and returnType.name or '??')

fn getMinMax<T>(parameters: List<T>, isOptional: (T) => Bool, reportError, name: String): MinMax {
  let mut firstOptional = parameters.length
  let mut hasOptional = false

  parameters.forEach(|parameter, i|
    if isOptional(parameter) and not hasOptional {
      hasOptional = true
      firstOptional = i
    }
    else if not isOptional(parameter) and hasOptional then reportError(parameter
      "An optional $name can't be followed by a required $name"
    )
  )

  {
    min: firstOptional
    max: parameters.length
  }
}

fn isAssignable(to: Type, subject: Type) {
  if not subject or not to then return true

  let sameKind = subject.kind == to.kind

  if not sameKind then return false

  if sameKind and to.kind == 'Function' {
    if to.argumentRange.min < subject.argumentRange.min
    or to.argumentRange.max > subject.argumentRange.max
      then return false

    to.arguments.every(fn (toArg, i) {
      let subjectArg = subject.arguments[i]

      isAssignable(toArg, subjectArg)
    })
  }
  else true
}

fn checkMinMax<T>(arguments: List<T>, minMax: MinMax, reportError, argumentName: String, subjectName: String, token) { // token: Token
  let argumentCount = arguments.length
  let max = minMax.max
  let min = minMax.min
  let error =
    if argumentCount < min
      then 'few'
    else if argumentCount > max
      then 'many'

  if error {
    let required =
      if min == max
        then min
        else '$min to $max'

    reportError(token
      'Too $error $argumentName given to $subjectName, $required required, $argumentCount given'
    )
  }
}

fn createFunctionType(scope: Scope, f: FunctionDeclaration, reportError) {
  let arguments = f.parameterList.map(|p| {{
    identifier: p.identifier
    mutable: p.mutable
    ty: p.ty
  }})
  let returnType = getType(scope, f.returnType)

  {
    kind: 'Function'
    name: if f.name then f.name.name else getFunctionTypeName(arguments, returnType)
    arguments
    argumentRange: if f.parameterList
      then getMinMax(f.parameterList, |p| p.initializer, reportError, 'parameter')
      else {{min: 0, max: 0}}
    returnType
    isAbstract: not f.body
  }
}

fn createScope(context, file, parent = undefined) {
  let reportError = context.reportError.bind(context, file)
  let mut bindings = {}
  let mut typeBindings = {}

  {
    parent
    getLocalBinding: |name| bindings[name]
    getBinding: |name| bindings[name] or (parent and parent.getBinding(name))
    getTypeBinding: |name| typeBindings[name] or (parent and parent.getTypeBinding(name))
    define: |mut binding: Binding, allowRedeclare = false| {
      let name = binding.name
      binding.redefined = bindings[name] != undefined
      if binding.redefined {
        if not allowRedeclare
          then reportError(binding.token, '$name has already been declared in the scope')
        bindings[name].redefined = true
        binding.previous = bindings[name]
      }
      bindings[name] = binding
    }
    defineType: |t: TypeDeclaration| {
      let name = t.name.name
      if typeBindings[name]
        then reportError(t, 'Type $name is already defined')

      let parameterRange = if t.typeParameters and t.typeParameters.length
        then getMinMax(t.typeParameters, |p| p.defaultValue, reportError, 'type parameter')

      let ty =
        if t.ty
          then t.ty
          else {
            let mut ty = {
              kind: name
              name
              parameterRange
            }

            if t.kind == SyntaxKind.TraitDeclaration {
              ty.isTrait = true
            }
            else if t.kind == SyntaxKind.TypeDeclaration {
              ty.implementations = []
            }
            if isTypeClass(ty) {
              ty.instances = []
            }

            ty
          }

      let binding = {
        name
        ty
      }

      typeBindings[name] = binding
    }
    inspect: |depth, opts| {
      let mut scope = {}
      if parent then scope['[parent]'] = parent.inspect()
      Object.assign(scope, bindings)

      if not depth and not opts
        then scope
        else inspect(scope, Object.assign({}, opts, {depth}))
    }
  }
}

fn defineFunction(scope: Scope, mut f: FunctionDeclaration) {
  if f.name then
    scope.define({
      name: f.name.name
      token: f
      mutable: false
      ty: f.ty
    })
}

fn definedHosted(visitor, scope: Scope, expressions: List<Expression>) {
  expressions.forEach(|mut e| {
    if e.kind == SyntaxKind.Function {
      e.hoisting = true
      visitor.visitFunctionDeclaration(e)
      e.hoisted = true
    }
    if e.kind == SyntaxKind.ExportDirective and
        e.expression.kind == SyntaxKind.Function {
      e.expression.hoisting = true
      visitor.visitFunctionDeclaration(e.expression)
      e.expression.hoisted = true
    }
  })
}

fn definedHostedTopLevel(visitor, scope: Scope, expressions: List<Expression>) {
  expressions.forEach(|mut e| {
    if e.kind == SyntaxKind.ImportDirective {
      visitor.visitImportDirective(e)
      e.hoisted = true
    }
    else if e.kind == SyntaxKind.TraitDeclaration
         or e.kind == SyntaxKind.TypeDeclaration {
      e.ty = scope.defineType(e).ty
      e.hoisted = true
    }
    else if e.kind == SyntaxKind.ExportDirective and (
      e.expression.kind == SyntaxKind.TraitDeclaration or
      e.expression.kind == SyntaxKind.TypeDeclaration
    ) {
      e.expression.ty = scope.defineType(e.expression).ty
      e.expression.hoisted = true
    }
  })
}

/// Visits and declares top level bindings
///
/// The result is used by the import visitor for import and exports but is then
/// throwed away becouse too little information is known about the imported bindings
export fn TopScopeVisitor(context, file) {
  let mut scope = createScope(context, file)

  Object.assign({}, visit.Visitor, {

    visitBlock: |self, b: Block| {}
    visitFunctionDeclaration: |self, mut f: FunctionDeclaration| {
      defineFunction(scope, f)
    }
    visitIdentifier: |self, i: Identifier| {}
    visitImplDeclaration: |self, i: ImplDeclaration| {}
    visitModule: |self, mut m: Module| {
      m.scope = scope
      visit.walkModule(self, m)
    }
    visitObjectDestructure: |self, i: ObjectDestructure| {
      // Allow redeclaration in this pass as we don't yet know if the type or variable scope
      // should be used for the imported identifiers.
      i.members.forEach(|m| scope.define({name: m.local.name, mutable: false, token: m}, true))
    }
    visitTraitDeclaration: |self, t: TraitDeclaration| {
      scope.defineType(t)
    }
    visitTypeBound: |self, t: TypeBound| {}
    visitTypeDeclaration: |self, t: TypeDeclaration| {
      scope.defineType(t)
    }
    visitVariableDeclaration: |self, d: VariableDeclaration| {
      scope.define({name: d.identifier.name, mutable: d.mutable, token: d}, true)
    }

    visitExportDirective: |self, e: ExportDirective| {
      visit.walkExportDirective(self, e)
    }
    visitImportDirective: |self, i: ImportDirective| {
      if i.specifier.kind == SyntaxKind.Identifier
        then scope.define({name: i.specifier.name, mutable: false, token: i})
      else if i.specifier.kind == SyntaxKind.ObjectDestructure
        then visit.walkImportDirective(self, i)
    }

    visitAssignmentExpression: |self, e: AssignmentExpression| {}
    visitBinaryExpression: |self, e: BinaryExpression| {}
    visitCallExpression: |self, e: CallExpression| {}
    visitForExpression: |self, e: ForExpression| {}
    visitIfExpression: |self, e: IfExpression| {}
    visitLoopExpression: |self, e: LoopExpression| {}
    visitUnaryExpression: |self, e: UnaryExpression| {}
    visitWhileExpression: |self, e: WhileExpression| {}
    visitIndexAccess: |self, a: IndexAccess| {}
    visitMemberAccess: |self, a: MemberAccess| {}

    visitBreak: |self, b: Token| {}
    visitReturn: |self, r: ReturnStatement| {}

    visitListLiteral: |self, l: ListLiteral| {}
    visitBooleanLiteral: |self, l: BooleanLiteral| {}
    visitNumberLiteral: |self, l: NumberLiteral| {}
    visitObjectLiteral: |self, l: ObjectLiteral| {}
    visitStringLiteral: |self, l: StringLiteral| {}
  })
}

fn visitFunctionDeclarationFrame(visitor, reportError, mut f: FunctionDeclaration) {
  if f.typeParameters
    then f.typeParameters.forEach(visitor.visitTypeParameter.bind(visitor))
  f.parameterList.forEach(visitor.visitVariableDeclaration.bind(visitor))
  if f.returnType then visitor.visitTypeBound(f.returnType)

  f.ty = createFunctionType(f.scope, f, reportError)
  defineFunction(f.scope.parent, f)
}

fn visitFunctionTypeBound(visitor, reportError, mut t: FunctionTypeBound) {
  visit.walkFunctionTypeBound(visitor, t)

  t.ty = getType(t.scope, t)
}

fn visitNamedTypeBound(visitor, reportError, mut t: NamedTypeBound) {
  let binding = t.scope.getTypeBinding(t.name.name)
  if not binding then reportError(t, 'Use of undeclared type ' + t.name.name)

  if isTypeClass(binding.ty)
    then checkMinMax(t.typeParameters, binding.ty.parameterRange, reportError, 'type parameters', binding.name, t)
  else if t.typeParameters.length > 0
    then reportError(t, 'Type ' + binding.name + ' is not generic')

  visit.walkNamedTypeBound(visitor, t)

  t.ty = getType(t.scope, t)
}

/// Visits and declares Traits, Types and toplevel function frames[1]
///
/// Traits and types are declared in this separate step so that we are sure
/// that complete type information is known during the checking step.
///
/// 1. function declaration withoud the body
export fn TypeVisitor(context, file) {
  let mut importDirective: ImportDirective
  let mut scope = createScope(context, file)
  let reportError = context.reportError.bind(context, file)

  Object.assign({}, visit.Visitor, {

    visitBlock: |self, b: Block| {}
    visitFunctionDeclaration: |self, mut f: FunctionDeclaration| {
      f.hoisting = true
      f.hoisted = true

      scope = createScope(context, file, scope)
      f.scope = scope

      visitFunctionDeclarationFrame(self, reportError, f)

      scope = scope.parent
    }
    visitIdentifier: |self, i: Identifier| {}
    visitImplDeclaration: |self, mut i: ImplDeclaration| {}
    visitModule: |self, mut m: Module| {
      m.scope = scope
      definedHostedTopLevel(self, scope, m.lines)
      visit.walkModule(self, m)
    }
    visitObjectDestructure: |self, mut i: ObjectDestructure| {
      i.scope = scope
      i.members.forEach(|m| {
        if importDirective.module {
          let e = importDirective.module.exports[m.local.name]
          if e.expression.kind == SyntaxKind.TraitDeclaration
          or e.expression.kind == SyntaxKind.TypeDeclaration
            then scope.defineType(e.expression)
            else scope.define({name: m.local.name, mutable: false, token: m})
        }
        else scope.define({name: m.local.name, mutable: false, token: m})
      })
    }
    visitTraitDeclaration: |self, mut t: TraitDeclaration| {
      scope = createScope(context, file, scope)
      t.scope = scope
      visit.walkTraitDeclaration(self, t)
      t.ty.functions = objectFromList(t.members.map(|m| [m.name.name, m.ty]))
      scope = scope.parent
    }
    visitFunctionTypeBound: |self, mut t: FunctionTypeBound| {
      scope = createScope(context, file, scope)
      t.scope = scope

      visitFunctionTypeBound(self, reportError, t)

      scope = scope.parent
    }
    visitNamedTypeBound: |self, mut t: NamedTypeBound| {
      t.scope = scope

      visitNamedTypeBound(self, reportError, t)
    }
    visitTypeDeclaration: |self, mut t: TypeDeclaration| {
      scope = createScope(context, file, scope)
      t.scope = scope
      visit.walkTypeDeclaration(self, t)

      t.ty.properties = objectFromList(t.properties.map(|p| [p.name.name, p.typeBound.ty]))

      scope = scope.parent
    }
    visitTypeParameter: |self, mut t: TypeParameter| {
      t.scope = scope
      scope.defineType(t)
      visit.walkTypeParameter(self, t)
    }
    visitVariableDeclaration: |self, mut d: VariableDeclaration| {
      d.scope = scope
      if d.typeBound then self.visitTypeBound(d.typeBound)
      d.ty = getType(d.scope, d.typeBound)
    }

    visitExportDirective: |self, mut e: ExportDirective| {
      e.scope = scope
      visit.walkExportDirective(self, e)
    }
    visitImportDirective: |self, mut i: ImportDirective| {
      if i.hoisted then return undefined

      i.scope = scope
      if i.specifier.kind == SyntaxKind.Identifier
        then scope.define({name: i.specifier.name, mutable: false, token: i})
      else if i.specifier.kind == SyntaxKind.ObjectDestructure {
        importDirective = i
        visit.walkImportDirective(self, i)
      }
    }

    visitAssignmentExpression: |self, e: AssignmentExpression| {}
    visitBinaryExpression: |self, e: BinaryExpression| {}
    visitCallExpression: |self, e: CallExpression| {}
    visitForExpression: |self, e: ForExpression| {}
    visitIfExpression: |self, e: IfExpression| {}
    visitLoopExpression: |self, e: LoopExpression| {}
    visitUnaryExpression: |self, e: UnaryExpression| {}
    visitWhileExpression: |self, e: WhileExpression| {}
    visitIndexAccess: |self, a: IndexAccess| {}
    visitMemberAccess: |self, a: MemberAccess| {}

    visitBreak: |self, b: Token| {}
    visitReturn: |self, r: ReturnStatement| {}

    visitListLiteral: |self, l: ListLiteral| {}
    visitBooleanLiteral: |self, l: BooleanLiteral| {}
    visitNumberLiteral: |self, l: NumberLiteral| {}
    visitObjectLiteral: |self, l: ObjectLiteral| {}
    visitStringLiteral: |self, l: StringLiteral| {}
  })
}

export fn ScopeVisitor(context, file) {
  let mut scope: Scope
  let mut importDirective: ImportDirective
  let reportError = context.reportError.bind(context, file)

  fn reportNotAssignableError(t, to: TypeInstance, subject: TypeInstance) { // t: Token
    reportError(t, subject.name + ' is not assignable to type ' + to.name)
  }

  fn checkFunctionType(binding: Binding, c: CallExpression) {
    if not binding.ty then return undefined
    let name = binding.ty.name

    if not binding.ty.arguments
      then reportError(c, '$name is not callable')

    checkMinMax(c.argumentList, binding.ty.argumentRange, reportError, 'arguments', binding.name, c)

    c.argumentList.forEach(|argument, i| {
      let parameter = binding.ty.arguments[i]

      if not isAssignable(parameter.ty, argument.ty)
        then reportNotAssignableError(argument, parameter.ty, argument.ty)

      if parameter.mutable and argument.kind == SyntaxKind.Identifier {
        let argumentName = argument.name
        let argumentBinding = scope.getBinding(argumentName)

        if not argumentBinding.mutable {
          let functionName =
            if c.func.kind == SyntaxKind.Identifier
              then c.func.name
              else 'function'
          let parameterName =
            if parameter.identifier
              then parameter.identifier.name
              else i
          reportError(argument
            'Parameter $parameterName of $functionName requires a mutable binding ' +
            'but $argumentName is declared as immutable.'
          )
        }
      }
    })
  }

  fn getBinding(token: Token)
    then if token.kind == SyntaxKind.Identifier
      then token.scope.getBinding(token.name)
    else if token.kind == SyntaxKind.MemberAccess
      then getBinding(token.object)
    else if token.kind == SyntaxKind.IndexAccess
      then getBinding(token.object)

  Object.assign({}, visit.Visitor, {

    visitBlock: |self, mut b: Block| {
      b.scope = scope
      definedHosted(self, scope, b.block)
      visit.walkBlock(self, b)
    }
    visitFunctionDeclaration: |self, mut f: FunctionDeclaration| {
      if not f.hoisting or not f.hoisted {
        scope = createScope(context, file, scope)
        f.scope = scope

        visitFunctionDeclarationFrame(self, reportError, f)
      }
      if not f.hoisting or f.hoisted {
        scope = f.scope

        f.parameterList.forEach(self.visitVariableDeclaration.bind(self))
        if f.body then self.visitBlock(f.body)
      }
      scope = scope.parent
    }
    visitIdentifier: |self, mut i: Identifier| {
      i.scope = scope
      let binding = i.scope.getBinding(i.name)
      if not binding
        then reportError(i, 'Use of undefined variable ' + i.name)
        else i.ty = binding.ty
      visit.walkIdentifier(self, i)
    }
    visitImplDeclaration: |self, mut i: ImplDeclaration| {
      scope = createScope(context, file, scope)
      i.scope = scope
      visit.walkImplDeclaration(self, i)

      if not isTrait(i.tra.ty)
        then reportError(i.tra, i.tra.ty.name + ' is not a trait')
      if not isStruct(i.ty.ty)
        then reportError(i.ty, i.ty.ty.name + ' is not a type')
      if i.ty.ty.implementations.some(|imp| isSameType(imp.tra.ty, i.tra.ty))
        then reportError(i, i.tra.ty.name + ' has already been implemented for ' + i.ty.ty.name)

      let functions = i.members.reduce(|mut functions, member| {
        functions[member.ty.name] = member.ty
        functions
      }, {})
      let traitFunctions = i.tra.ty.functions

      Object.keys(traitFunctions).forEach(|name| {
        if traitFunctions[name].isAbstract and not functions[name]
          then reportError(i, 'Function ' + i.tra.ty.name + '::' + name + ' is not implemented for ' + i.ty.ty.name)
      }, {})

      i.members.forEach(|function| {
        if not traitFunctions[function.ty.name]
          then reportError(i, 'Function ' + function.ty.name + ' is not defined by ' + i.tra.ty.name)
      })

      i.ty.ty.implementations.push({
        ty: i.ty
        tra: i.tra
      })

      scope = scope.parent
    }
    visitModule: |self, mut m: Module| {
      scope = m.scope
      visit.walkModule(self, m)
    }
    visitObjectDestructure: |self, mut i: ObjectDestructure| {
      i.members.forEach(|m| {
        if importDirective.module {
          let e = importDirective.module.exports[m.local.name]
          if e.expression.kind == SyntaxKind.TraitDeclaration
          or e.expression.kind == SyntaxKind.TypeDeclaration
            {
              // Get the from the imported module again as it may have been missing during the
              // TypeVisitor pass depending on file order
              let mut binding = scope.getTypeBinding(m.local.name)
              binding.ty = e.expression.ty
            }
        }
      })
    }
    visitTraitDeclaration: |self, mut t: TraitDeclaration| {
      scope = t.scope
      visit.walkTraitDeclaration(self, t)
      scope = scope.parent
    }
    visitFunctionTypeBound: |self, mut t: FunctionTypeBound| {
      if not t.scope {
        scope = createScope(context, file, scope)
        t.scope = scope
        visitFunctionTypeBound(self, reportError, t)
        scope = scope.parent
      }
    }
    visitNamedTypeBound: |self, mut t: NamedTypeBound| {
      if not t.scope {
        t.scope = scope
        visitNamedTypeBound(self, reportError, t)
      }
    }
    visitTypeDeclaration: |self, mut t: TypeDeclaration| {}
    visitTypeParameter: |self, mut t: TypeParameter| {
      if not t.scope {
        t.scope = scope
        scope.defineType(t)
        visit.walkTypeParameter(self, t)
      }
    }
    visitVariableDeclaration: |self, mut d: VariableDeclaration| {
      if d.binding then return undefined
      if not d.scope {
        d.scope = scope
        if d.typeBound then self.visitTypeBound(d.typeBound)
        d.ty = getType(d.scope, d.typeBound)
      }

      let mut binding = d.scope.define({
        name: d.identifier.name,
        mutable: d.mutable,
        token: d,
        ty: d.ty
      }, true)
      d.binding = binding

      if d.initializer {
        self.visitExpression(d.initializer)
        if not binding.ty
          then binding.ty = d.initializer.ty
        else if not isAssignable(binding.ty, d.initializer.ty)
          then reportNotAssignableError(d, binding.ty, d.initializer.ty)
      }
    }

    visitExportDirective: |self, mut e: ExportDirective| {
      visit.walkExportDirective(self, e)
    }
    visitImportDirective: |self, mut i: ImportDirective| {
      if i.specifier.kind == SyntaxKind.ObjectDestructure {
        importDirective = i
        visit.walkImportDirective(self, i)
      }
    }

    visitAssignmentExpression: |self, mut e: AssignmentExpression| {
      e.scope = scope
      visit.walkAssignmentExpression(self, e)
      if let binding = getBinding(e.lhs) {
        if not binding.mutable
          then reportError(e, "Can't assign to immutable variable " + binding.name)

        if not isAssignable(e.lhs.ty, e.rhs.ty)
          then reportNotAssignableError(e, e.lhs.ty, e.rhs.ty)
      }
    }
    visitBinaryExpression: |self, mut e: BinaryExpression| {
      e.scope = scope
      visit.walkBinaryExpression(self, e)
    }
    visitCallExpression: |self, mut e: CallExpression| {
      e.scope = scope
      visit.walkCallExpression(self, e)

      if e.func.ty {
        checkFunctionType(e.func, e)
        e.ty = e.func.ty.returnType
      }
    }
    visitForExpression: |self, mut e: ForExpression| {
      scope = createScope(context, file, scope)
      e.scope = scope
      visit.walkForExpression(self, e)
      scope = scope.parent
    }
    visitIfExpression: |self, mut e: IfExpression| {
      scope = createScope(context, file, scope)
      e.scope = scope
      visit.walkIfExpression(self, e)
      scope = scope.parent
    }
    visitLoopExpression: |self, mut e: LoopExpression| {
      scope = createScope(context, file, scope)
      e.scope = scope
      visit.walkLoopExpression(self, e)
      scope = scope.parent
    }
    visitUnaryExpression: |self, mut e: UnaryExpression| {
      e.scope = scope
      visit.walkUnaryExpression(self, e)

      e.ty =
        if e.operator.kind == SyntaxKind.NotKeyword
          then {kind: 'Bool', name: 'Bool'}
        else if e.operator.kind == SyntaxKind.MinusToken
             or e.operator.kind == SyntaxKind.PlusToken
          then {kind: 'Num', name: 'Num'}
    }
    visitWhileExpression: |self, mut e: WhileExpression| {
      scope = createScope(context, file, scope)
      e.scope = scope
      visit.walkWhileExpression(self, e)
      scope = scope.parent
    }
    visitIndexAccess: |self, mut a: IndexAccess| {
      a.scope = scope
      visit.walkIndexAccess(self, a)
    }
    visitMemberAccess: |self, mut a: MemberAccess| {
      a.scope = scope
      visit.walkExpression(self, a.object)
    }

    visitBreak: |self, mut b: Token| {
      b.scope = scope
      visit.walkBreak(self, b)
    }
    visitReturn: |self, mut r: ReturnStatement| {
      r.scope = scope
      visit.walkReturn(self, r)
    }

    visitListLiteral: |self, mut l: ListLiteral| {
      l.scope = scope
      visit.walkListLiteral(self, l)
    }
    visitBooleanLiteral: |self, mut l: BooleanLiteral| {
      l.scope = scope
      l.ty = {kind: 'Bool', name: 'Bool'}
      visit.walkBooleanLiteral(self, l)
    }
    visitNumberLiteral: |self, mut l: NumberLiteral| {
      l.scope = scope
      l.ty = {kind: 'Num', name: 'Num'}
      visit.walkNumberLiteral(self, l)
    }
    visitObjectLiteral: |self, mut l: ObjectLiteral| {
      l.scope = scope
      l.members.forEach(|m| {
        self.visitExpression(m.value)
      })
    }
    visitStringLiteral: |self, mut l: StringLiteral| {
      l.scope = scope
      l.ty = {kind: 'String', name: 'String'}
      visit.walkStringLiteral(self, l)
    }
  })
}

