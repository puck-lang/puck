import 'node:util' as {inspect}
import 'puck:js' as {Object, undefined}
import '../ast/ast.puck' as {
  Expression

  Block
  FunctionDeclaration
  Identifier
  Module
  ObjectDestructure
  TypeBound
  FunctionTypeBound
  NamedTypeBound
  TraitDeclaration
  TypeDeclaration
  TypeParameter
  TypeProperty
  VariableDeclaration

  ExportDirective
  ImportDirective

  AssignmentExpression
  BinaryExpression
  CallExpression
  ForExpression
  IfExpression
  LoopExpression
  UnaryExpression
  WhileExpression

  IndexAccess
  MemberAccess

  Token
  ReturnStatement

  ListLiteral
  BooleanLiteral
  NumberLiteral
  ObjectLiteral
  StringLiteral
}
import '../ast/visit.puck' as visit
import '../compiler/ast.ts' as {SyntaxKind}

type MinMax = {
  min: Num
  max: Num
}

type TypeInstance = {
  kind: String
  name: String
  // binding: TypeBinding
  // parameters: List<TypeBinding|TypeInstance>
  // parameters: List<TypeInstance>
}

type FunctionTypeInstance = {
  name: String
  // typeParameters: List<TypeInstance>
  arguments: List<Binding>
  argumentRange: MinMax
  returnType: TypeInstance
}

type Binding = {
  identifier: Identifier
  token: Token
  mutable: Bool
  ty: TypeInstance //?
  redefined: Bool
  previous: Binding //?
}

type TypeBinding = {
  name: String
  ty: TypeInstance //?
  parameterRange: MinMax
}

type Scope = {
  getLocalBinding: (String) => Binding
  // getBinding: (String, allowRedeclare = true) => Binding
  getBinding: (String) => Binding
  getTypeBinding: (String) => Binding
  define: (String, Binding) => Binding
  defineType: (String, Binding) => Binding
}

type ScopeAware = {
  scope: Scope
}

fn getType(scope: Scope, t: TypeBound, name: String = undefined) {
  if not t then return undefined
  if t.name {
    let binding = scope.getTypeBinding(t.name.name)

    binding and binding.ty
  }
  else {
    let arguments = t.parameters.map(|p| {{ty: getType(scope, p)}})
    let returnType = getType(scope, t.returnType)

    {
      kind: 'Function'
      name: getFunctionTypeName(arguments, returnType)
      arguments
      argumentRange: {min: arguments.length, max: arguments.length}
      returnType
    }
  }
}

fn getFunctionTypeName(arguments: List<TypeInstance>, returnType: TypeInstance)
  then '(' + arguments.map(|a| (a and a.name) or '??').join(', ') + ') => ' +
        (returnType and returnType.name or '??')

fn getMinMax<T>(parameters: List<T>, isOptional: (T) => Bool, reportError, name: String): MinMax {
  let mut firstOptional = parameters.length
  let mut hasOptional = false

  parameters.forEach(|parameter, i|
    if isOptional(parameter) and not hasOptional {
      hasOptional = true
      firstOptional = i
    }
    else if not isOptional(parameter) and hasOptional then reportError(parameter
      "An optional $name can't be followed by a required $name"
    )
  )

  {
    min: firstOptional
    max: parameters.length
  }
}

fn isAssignable(to: TypeInstance, subject: TypeInstance) {
  if not subject or not to then return true

  let sameKind = subject.kind == to.kind

  if not sameKind then return false

  if sameKind and to.kind == 'Function' {
    if to.argumentRange.min < subject.argumentRange.min
    or to.argumentRange.max > subject.argumentRange.max
      then return false

    to.arguments.every(fn (toArg, i) {
      let subjectArg = subject.arguments[i]

      isAssignable(toArg, subjectArg)
    })
  }
  else true
}

fn checkMinMax<T>(arguments: List<T>, minMax: MinMax, reportError, argumentName: String, subjectName: String, token: Token) {
  let argumentCount = arguments.length
  let max = minMax.max
  let min = minMax.min
  let error =
    if argumentCount < min
      then 'few'
    else if argumentCount > max
      then 'many'

  if error {
    let required =
      if min == max
        then min
        else '$min to $max'

    reportError(token
      'Too $error $argumentName given to $subjectName, $required required, $argumentCount given'
    )
  }
}

fn createFunctionType(scope: Scope, f: FunctionDeclaration, reportError) {
  let arguments = f.parameterList.map(|p| {{
    identifier: p.identifier
    mutable: p.mutable
    ty: getType(scope, p.typeBound, p.identifier.name)
  }})
  let returnType = getType(scope, f.returnType)

  {
    kind: 'Function'
    name: f.name or getFunctionTypeName(arguments, returnType)
    arguments
    argumentRange: if f.parameterList
      then getMinMax(f.parameterList, |p| p.initializer, reportError, 'parameter')
      else {{min: 0, max: 0}}
    returnType
  }
}

fn createScope(context, file, parent = undefined) {
  let reportError = context.reportError.bind(context, file)
  let mut bindings = {}
  let mut typeBindings = {}

  {
    parent
    getLocalBinding: |name| bindings[name]
    getBinding: |name| bindings[name] or (parent and parent.getBinding(name))
    getTypeBinding: |name| typeBindings[name] or (parent and parent.getTypeBinding(name))
    define: |mut binding: Binding, allowRedeclare = false| {
      let name = binding.identifier.name
      binding.redefined = bindings[name] != undefined
      if binding.redefined {
        if not allowRedeclare
          then reportError(binding.token, '$name has already been declared in the scope')
        bindings[name].redefined = true
        binding.previous = bindings[name]
      }
      bindings[name] = binding
    }
    defineType: |t: TypeDeclaration| {
      let name = t.name.name
      if typeBindings[name]
        then reportError(t, 'Type $name is already defined')

      let parameterRange = if t.parameters and t.parameters.length
        then getMinMax(t.parameters, |p| p.defaultValue, reportError, 'type parameter')

      let mut binding = {
        kind: name
        name
        parameterRange
      }

      // Not generic types doesn't need instances so the binding can be used directly
      if not parameterRange
        then binding.ty = binding

      typeBindings[name] = binding
    }
    inspect: |depth, opts| {
      let mut scope = {}
      if parent then scope['[parent]'] = parent.inspect()
      Object.assign(scope, bindings)

      if not depth and not opts
        then scope
        else inspect(scope, Object.assign({}, opts, {depth}))
    }
  }
}

fn defineFunction(scope: Scope, mut f: FunctionDeclaration, reportError = undefined) {
  if reportError
    then f.ty = createFunctionType(scope, f, reportError)
  if f.name then
    scope.define({
      identifier: f.name
      token: f
      mutable: false
      ty: f.ty
    })
}

fn definedHosted(scope: Scope, expressions: List<Expression>, reportError) {
  expressions.forEach(|mut e| {
    if e.kind == SyntaxKind.Function {
      defineFunction(scope, e, reportError)
      e.hoisted = true
    }
    if e.kind == SyntaxKind.ExportDirective and
        e.expression.kind == SyntaxKind.Function {
      defineFunction(scope, e.expression, reportError)
      e.expression.hoisted = true
    }
  })
}

fn definedHostedTopLevel(visitor, scope: Scope, expressions: List<Expression>) {
  expressions.forEach(|mut e| {
    if e.kind == SyntaxKind.ImportDirective {
      visitor.visitImportDirective(e)
      e.hoisted = true
    }
    else if e.kind == SyntaxKind.TraitDeclaration
         or e.kind == SyntaxKind.TypeDeclaration {
      scope.defineType(e)
      e.hoisted = true
    }
    else if e.kind == SyntaxKind.ExportDirective and (
      e.expression.kind == SyntaxKind.TraitDeclaration or
      e.expression.kind == SyntaxKind.TypeDeclaration
    ) {
      scope.defineType(e.expression)
      e.expression.hoisted = true
    }
  })
}

export fn TopScopeVisitor(context, file) {
  let mut scope = createScope(context, file)

  Object.assign({}, visit.Visitor, {

    visitBlock: |self, b: Block| {}
    visitFunctionDeclaration: |self, mut f: FunctionDeclaration| {
      defineFunction(scope, f)
    }
    visitIdentifier: |self, i: Identifier| {}
    visitModule: |self, mut m: Module| {
      m.scope = scope
      visit.walkModule(self, m)
    }
    visitObjectDestructure: |self, i: ObjectDestructure| {
      // Allow redeclaration in this pass as we don't yet know if the type or variable scope
      // should be used for the imported identifiers.
      i.members.forEach(|m| scope.define({identifier: m.local, mutable: false, token: m}, true))
    }
    visitTraitDeclaration: |self, t: TraitDeclaration| {
      scope.defineType(t)
    }
    visitTypeBound: |self, t: TypeBound| {}
    visitTypeDeclaration: |self, t: TypeDeclaration| {
      scope.defineType(t)
    }
    visitVariableDeclaration: |self, d: VariableDeclaration| {
      scope.define({identifier: d.identifier, mutable: d.mutable, token: d}, true)
    }

    visitExportDirective: |self, e: ExportDirective| {
      visit.walkExportDirective(self, e)
    }
    visitImportDirective: |self, i: ImportDirective| {
      if i.specifier.kind == SyntaxKind.Identifier
        then scope.define({identifier: i.specifier, mutable: false, token: i})
      else if i.specifier.kind == SyntaxKind.ObjectDestructure
        then visit.walkImportDirective(self, i)
    }

    visitAssignmentExpression: |self, e: AssignmentExpression| {}
    visitBinaryExpression: |self, e: BinaryExpression| {}
    visitCallExpression: |self, e: CallExpression| {}
    visitForExpression: |self, e: ForExpression| {}
    visitIfExpression: |self, e: IfExpression| {}
    visitLoopExpression: |self, e: LoopExpression| {}
    visitUnaryExpression: |self, e: UnaryExpression| {}
    visitWhileExpression: |self, e: WhileExpression| {}
    visitIndexAccess: |self, a: IndexAccess| {}
    visitMemberAccess: |self, a: MemberAccess| {}

    visitBreak: |self, b: Token| {}
    visitReturn: |self, r: ReturnStatement| {}

    visitListLiteral: |self, l: ListLiteral| {}
    visitBooleanLiteral: |self, l: BooleanLiteral| {}
    visitNumberLiteral: |self, l: NumberLiteral| {}
    visitObjectLiteral: |self, l: ObjectLiteral| {}
    visitStringLiteral: |self, l: StringLiteral| {}
  })
}

export fn ScopeVisitor(context, file) {
  let mut importDirective: ImportDirective
  let mut scope = createScope(context, file)
  let reportError = context.reportError.bind(context, file)

  fn reportNotAssignableError(t: Token, to: TypeInstance, subject: TypeInstance) {
    reportError(t, subject.name + ' is not assignable to type ' + to.name)
  }

  fn checkFunctionType(binding: Binding, c: CallExpression) {
    if not binding.ty then return undefined
    let name = binding.identifier.name

    if not binding.ty.arguments
      then reportError(c, '$name is not callable')

    checkMinMax(c.argumentList, binding.ty.argumentRange, reportError, 'arguments', name, c)

    c.argumentList.forEach(|argument, i| {
      let parameter = binding.ty.arguments[i]

      if not isAssignable(parameter.ty, argument.ty)
        then reportNotAssignableError(argument, parameter.ty, argument.ty)

      if parameter.mutable and argument.kind == SyntaxKind.Identifier {
        let argumentName = argument.name
        let argumentBinding = scope.getBinding(argumentName)

        if not argumentBinding.mutable {
          let functionName =
            if c.func.kind == SyntaxKind.Identifier
              then c.func.name
              else 'function'
          let parameterName =
            if parameter.identifier
              then parameter.identifier.name
              else i
          reportError(argument
            'Parameter $parameterName of $functionName requires a mutable binding ' +
            'but $argumentName is declared as immutable.'
          )
        }
      }
    })
  }

  fn getBinding(token: Token)
    then if token.kind == SyntaxKind.Identifier
      then token.scope.getBinding(token.name)
    else if token.kind == SyntaxKind.MemberAccess
      then getBinding(token.object)
    else if token.kind == SyntaxKind.IndexAccess
      then getBinding(token.object)

  Object.assign({}, visit.Visitor, {

    visitBlock: |self, mut b: Block| {
      b.scope = scope
      definedHosted(scope, b.block, reportError)
      visit.walkBlock(self, b)
    }
    visitFunctionDeclaration: |self, mut f: FunctionDeclaration| {
      if not f.hoisted then defineFunction(scope, f, reportError)
      scope = createScope(context, file, scope)
      f.scope = scope
      visit.walkFunction(self, f)
      scope = scope.parent
    }
    visitIdentifier: |self, mut i: Identifier| {
      i.scope = scope
      let binding = i.scope.getBinding(i.name)
      if not binding then reportError(i, 'Use of undefined variable ' + i.name)
      visit.walkIdentifier(self, i)
    }
    visitModule: |self, mut m: Module| {
      m.scope = scope
      definedHostedTopLevel(self, scope, m.lines)
      definedHosted(scope, m.lines, reportError)
      visit.walkModule(self, m)
    }
    visitObjectDestructure: |self, mut i: ObjectDestructure| {
      i.scope = scope
      i.members.forEach(|m| {
        if importDirective.module {
          let e = importDirective.module.exports[m.local.name]
          if e.expression.kind == SyntaxKind.TypeDeclaration
            then scope.defineType(e.expression)
            else scope.define({identifier: m.local, mutable: false, token: m})
        }
        else scope.define({identifier: m.local, mutable: false, token: m})
      })
    }
    visitTraitDeclaration: |self, mut t: TraitDeclaration| {
      scope = createScope(context, file, scope)
      t.scope = scope
      visit.walkTraitDeclaration(self, t)
      scope = scope.parent
    }
    visitFunctionTypeBound: |self, mut t: FunctionTypeBound| {
      scope = createScope(context, file, scope)
      t.scope = scope
      visit.walkFunctionTypeBound(self, t)
      scope = scope.parent
    }
    visitNamedTypeBound: |self, mut t: NamedTypeBound| {
      t.scope = scope

      let binding = t.scope.getTypeBinding(t.name.name)
      if not binding then reportError(t, 'Use of undeclared type ' + t.name.name)

      if binding.parameterRange
        then checkMinMax(t.parameters, binding.parameterRange, reportError, 'type parameters', t.name.name, t)
      else if t.parameters.length > 0
        then reportError(t, 'Type ' + t.name.name + ' is not generic')

      visit.walkNamedTypeBound(self, t)
    }
    visitTypeDeclaration: |self, t: TypeDeclaration| {
      scope = createScope(context, file, scope)
      visit.walkTypeDeclaration(self, t)
      scope = scope.parent
    }
    visitTypeParameter: |self, mut t: TypeParameter| {
      t.scope = scope
      scope.defineType(t)
      visit.walkTypeParameter(self, t)
    }
    visitVariableDeclaration: |self, mut d: VariableDeclaration| {
      d.scope = scope
      if d.typeBound then self.visitTypeBound(d.typeBound)
      let mut binding = scope.define({
        identifier: d.identifier,
        mutable: d.mutable,
        token: d,
        ty: getType(scope, d.typeBound)
      }, true)

      if d.initializer {
        self.visitExpression(d.initializer)
        if not binding.ty
          then binding.ty = d.initializer.ty
        else if not isAssignable(binding.ty, d.initializer.ty)
          then reportNotAssignableError(d, binding.ty, d.initializer.ty)
      }
    }

    visitExportDirective: |self, mut e: ExportDirective| {
      e.scope = scope
      visit.walkExportDirective(self, e)
    }
    visitImportDirective: |self, mut i: ImportDirective| {
      if i.hoisted then return undefined

      i.scope = scope
      if i.specifier.kind == SyntaxKind.Identifier
        then scope.define({identifier: i.specifier, mutable: false, token: i})
      else if i.specifier.kind == SyntaxKind.ObjectDestructure {
        importDirective = i
        visit.walkImportDirective(self, i)
      }
    }

    visitAssignmentExpression: |self, mut e: AssignmentExpression| {
      e.scope = scope
      visit.walkAssignmentExpression(self, e)
      let binding = getBinding(e.lhs)
      if binding {
        if not binding.mutable
          then reportError(e, "Can't assign to immutable variable " + binding.identifier.name)

        if not isAssignable(binding.ty, e.rhs.ty)
          then reportNotAssignableError(e, binding.ty, e.rhs.ty)
      }
    }
    visitBinaryExpression: |self, mut e: BinaryExpression| {
      e.scope = scope
      visit.walkBinaryExpression(self, e)
    }
    visitCallExpression: |self, mut e: CallExpression| {
      e.scope = scope
      visit.walkCallExpression(self, e)
      if e.func.kind == SyntaxKind.Identifier {
        let binding = scope.getBinding(e.func.name)

        checkFunctionType(binding, e)
      }
    }
    visitForExpression: |self, mut e: ForExpression| {
      scope = createScope(context, file, scope)
      e.scope = scope
      visit.walkForExpression(self, e)
      scope = scope.parent
    }
    visitIfExpression: |self, mut e: IfExpression| {
      scope = createScope(context, file, scope)
      e.scope = scope
      visit.walkIfExpression(self, e)
      scope = scope.parent
    }
    visitLoopExpression: |self, mut e: LoopExpression| {
      scope = createScope(context, file, scope)
      e.scope = scope
      visit.walkLoopExpression(self, e)
      scope = scope.parent
    }
    visitUnaryExpression: |self, mut e: UnaryExpression| {
      e.scope = scope
      visit.walkUnaryExpression(self, e)
    }
    visitWhileExpression: |self, mut e: WhileExpression| {
      scope = createScope(context, file, scope)
      e.scope = scope
      visit.walkWhileExpression(self, e)
      scope = scope.parent
    }
    visitIndexAccess: |self, mut a: IndexAccess| {
      a.scope = scope
      visit.walkIndexAccess(self, a)
    }
    visitMemberAccess: |self, mut a: MemberAccess| {
      a.scope = scope
      visit.walkExpression(self, a.object)
    }

    visitBreak: |self, mut b: Token| {
      b.scope = scope
      visit.walkBreak(self, b)
    }
    visitReturn: |self, mut r: ReturnStatement| {
      r.scope = scope
      visit.walkReturn(self, r)
    }

    visitListLiteral: |self, mut l: ListLiteral| {
      l.scope = scope
      visit.walkListLiteral(self, l)
    }
    visitBooleanLiteral: |self, mut l: BooleanLiteral| {
      l.scope = scope
      l.ty = {kind: 'Bool', name: 'Bool'}
      visit.walkBooleanLiteral(self, l)
    }
    visitNumberLiteral: |self, mut l: NumberLiteral| {
      l.scope = scope
      l.ty = {kind: 'Num', name: 'Num'}
      visit.walkNumberLiteral(self, l)
    }
    visitObjectLiteral: |self, mut l: ObjectLiteral| {
      l.scope = scope
      l.members.forEach(|m| {
        self.visitExpression(m.value)
      })
    }
    visitStringLiteral: |self, mut l: StringLiteral| {
      l.scope = scope
      l.ty = {kind: 'String', name: 'String'}
      visit.walkStringLiteral(self, l)
    }
  })
}

