import 'puck:js' as {Object, undefined}
import '../ast/visit.puck' as visit
import '../compiler/ast.ts' as {SyntaxKind}

// type Binding = {
//   identifier: Identifier
//   mutable: boolean
//   redefined: boolean
//   previous: Binding?
// }

// type Scope = {
//   getLocalBinding: (String) => Binding
//   getBinding: (String) => Binding
//   define: (String, Binding) => Binding
// }

// type ScopeAware = {
//   scope: Scope
// }

fn createScope(parent) {
  let bindings = {}

  {
    parent
    getLocalBinding: |name| bindings[name]
    getBinding: |name| bindings[name] or (parent and parent.getBinding(name))
    define: |mut binding: Binding| {
      let name = binding.identifier.name
      binding.redefined = bindings[name] != undefined
      if binding.redefined {
        bindings[name].redefined = true
        binding.previous = bindings[name]
      }
      bindings[name] = binding
    }
  }
}

export fn ScopeVisitor(context, file) {
  let mut scope = createScope()
  let reportError = context.reportError.bind(context, file)

  fn defineFunction(f: FunctionNode) {
    if f.name then
      scope.define({identifier: f.name, mutable: false})
  }

  fn definedHosted(expressions: Array<Expression>) {
    expressions.forEach(|e| {
      if e.kind == SyntaxKind.Function {
        defineFunction(e)
        e.hoisted = true
      }
      if e.kind == SyntaxKind.ExportDirective and
          e.expression.kind == SyntaxKind.Function {
        defineFunction(e.expression)
        e.expression.hoisted = true
      }
    })
  }

  Object.assign({}, visit.Visitor, {

    visitBlock: |self, b: Block| {
      b.scope = scope
      definedHosted(b.block)
      visit.walkBlock(self, b)
    }
    visitFunction: |self, f: FunctionNode| {
      if not f.hoisted then defineFunction(f)
      scope = createScope(scope)
      f.scope = scope
      visit.walkFunction(self, f)
      scope = scope.parent
    }
    visitIdentifier: |self, i: Identifier| {
      i.scope = scope
      let binding = i.scope.getBinding(i.name)
      if not binding then reportError(i, 'Use of undefined variable ' + i.name)
      visit.walkIdentifier(self, i)
    }
    visitModule: |self, m: Module| {
      m.scope = scope
      definedHosted(m.lines)
      visit.walkModule(self, m)
    }
    visitObjectDestructure: |self, i: ObjectDestructure| {
      i.scope = scope
      i.members.forEach(|m| scope.define({identifier: m.local, mutable: false}))
    }
    visitTypeBound: |self, t: TypeBound| {
      t.scope = scope
      visit.walkTypeBound(self, t)
    }
    visitVariableDeclaration: |self, d: VariableDeclaration| {
      d.scope = scope
      if d.typeBound then self.visitTypeBound(d.typeBound)
      scope.define({identifier: d.identifier, mutable: d.mutable})
      if d.initializer then self.visitExpression(d.initializer)
    }

    visitExportDirective: |self, e: ExportDirective| {
      e.scope = scope
      visit.walkExportDirective(self, e)
    }
    visitImportDirective: |self, i: ImportDirective| {
      i.scope = scope
      if i.specifier.kind == SyntaxKind.Identifier
        then scope.define({identifier: i.specifier, mutable: false})
        else visit.walkImportDirective(self, i)
    }

    visitAssignmentExpression: |self, e: AssignmentExpression| {
      e.scope = scope
      if e.lhs.kind == SyntaxKind.Identifier {
        let binding = e.scope.getBinding(e.lhs.name)
        if binding and not binding.mutable
          then reportError(e, "Can't assign to immutable variable " + e.lhs.name)
      }
      visit.walkAssignmentExpression(self, e)
    }
    visitBinaryExpression: |self, e: BinaryExpression| {
      e.scope = scope
      visit.walkBinaryExpression(self, e)
    }
    visitCallExpression: |self, e: CallExpression| {
      e.scope = scope
      visit.walkCallExpression(self, e)
    }
    visitForExpression: |self, e: ForExpression| {
      scope = createScope(scope)
      e.scope = scope
      visit.walkForExpression(self, e)
      scope = scope.parent
    }
    visitIfExpression: |self, e: IfExpression| {
      scope = createScope(scope)
      e.scope = scope
      visit.walkIfExpression(self, e)
      scope = scope.parent
    }
    visitLoopExpression: |self, e: LoopExpression| {
      scope = createScope(scope)
      e.scope = scope
      visit.walkLoopExpression(self, e)
      scope = scope.parent
    }
    visitUnaryExpression: |self, e: UnaryExpression| {
      e.scope = scope
      visit.walkUnaryExpression(self, e)
    }
    visitWhileExpression: |self, e: WhileExpression| {
      scope = createScope(scope)
      e.scope = scope
      visit.walkWhileExpression(self, e)
      scope = scope.parent
    }
    visitIndexAccess: |self, a: IndexAccess| {
      a.scope = scope
      visit.walkIndexAccess(self, a)
    }
    visitMemberAccess: |self, a: MemberAccess| {
      a.scope = scope
      visit.walkExpression(self, a.object)
    }

    visitBreak: |self, b: Token| {
      b.scope = scope
      visit.walkBreak(self, b)
    }
    visitReturn: |self, r: ReturnStatement| {
      r.scope = scope
      visit.walkReturn(self, r)
    }

    visitArrayLiteral: |self, l: ArrayLiteral| {
      l.scope = scope
      visit.walkArrayLiteral(self, l)
    }
    visitBooleanLiteral: |self, l: BooleanLiteral| {
      l.scope = scope
      visit.walkBooleanLiteral(self, l)
    }
    visitNumberLiteral: |self, l: NumberLiteral| {
      l.scope = scope
      visit.walkNumberLiteral(self, l)
    }
    visitObjectLiteral: |self, l: ObjectLiteral| {
      l.scope = scope
      l.members.forEach(|m| {
        self.visitExpression(m.value)
      })
    }
    visitStringLiteral: |self, l: StringLiteral| {
      l.scope = scope
      visit.walkStringLiteral(self, l)
    }
  })
}

