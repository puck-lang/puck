import 'node:util' as {inspect}
import 'puck:js' as {Object, undefined}
import '../ast/ast.puck' as {
  Expression

  Block
  FunctionDeclaration
  Identifier
  Module
  ObjectDestructure
  TypeBound
  FunctionTypeBound
  NamedTypeBound
  TraitDeclaration
  TypeDeclaration
  TypeParameter
  TypeProperty
  VariableDeclaration

  ExportDirective
  ImportDirective

  AssignmentExpression
  BinaryExpression
  CallExpression
  ForExpression
  IfExpression
  LoopExpression
  UnaryExpression
  WhileExpression

  IndexAccess
  MemberAccess

  Token
  ReturnStatement

  ListLiteral
  BooleanLiteral
  NumberLiteral
  ObjectLiteral
  StringLiteral
}
import '../ast/visit.puck' as visit
import '../compiler/ast.ts' as {SyntaxKind}

type Binding = {
  identifier: Identifier
  token: Token
  mutable: Bool
  redefined: Bool
  previous: Binding //?
}

type TypeBinding = {
  name: String
  // parameters: {min: Num, max: Num}
}

type Scope = {
  getLocalBinding: (String) => Binding
  // getBinding: (String, allowRedeclare = true) => Binding
  getBinding: (String) => Binding
  getTypeBinding: (String) => Binding
  define: (String, Binding) => Binding
  defineType: (String, Binding) => Binding
}

type ScopeAware = {
  scope: Scope
}

type MinMax = {
  min: Num
  max: Num
}

fn getMinMax<T>(parameters: List<T>, isOptional: (T) => Bool, reportError, name: String): MinMax {
  let mut firstOptional = parameters.length
  let mut hasOptional = false

  parameters.forEach(|parameter, i|
    if isOptional(parameter) and not hasOptional {
      hasOptional = true
      firstOptional = i
    }
    else if not isOptional(parameter) and hasOptional then reportError(parameter
      "An optional $name can't be followed by a required $name"
    )
  )

  {
    min: firstOptional
    max: parameters.length
  }
}

fn checkMinMax<T>(arguments: List<T>, minMax: MinMax, reportError, argumentName: String, subjectName: String, token: Token) {
  let argumentCount = arguments.length
  let max = minMax.max
  let min = minMax.min
  let error =
    if argumentCount < min
      then 'few'
    else if argumentCount > max
      then 'many'

  if error {
    let required =
      if min == max
        then min
        else '$min to $max'

    reportError(token
      'Too $error $argumentName given to $subjectName, $required required, $argumentCount given'
    )
  }
}

fn createFunctionType(f: FunctionDeclaration, reportError) then {
  kind: 'function'
  parameters: if f.parameterList
    then getMinMax(f.parameterList, |p| p.initializer, reportError, 'parameter')
    else {{min: 0, max: 0}}
}

fn checkFunctionType(binding: Binding, c: CallExpression, reportError) {
  if not binding.ty then return undefined
  let name = binding.identifier.name

  if binding.ty.kind != 'function'
    then reportError(c, '$name is not callable')

  checkMinMax(c.argumentList, binding.ty.parameters, reportError, 'arguments', name, c)
}

fn createScope(context, file, parent = undefined) {
  let reportError = context.reportError.bind(context, file)
  let bindings = {}
  let typeBindings = {}

  {
    parent
    getLocalBinding: |name| bindings[name]
    getBinding: |name| bindings[name] or (parent and parent.getBinding(name))
    getTypeBinding: |name| typeBindings[name] or (parent and parent.getTypeBinding(name))
    define: |mut binding: Binding, allowRedeclare = false| {
      let name = binding.identifier.name
      binding.redefined = bindings[name] != undefined
      if binding.redefined {
        if not allowRedeclare
          then reportError(binding.token, '$name has already been declared in the scope')
        bindings[name].redefined = true
        binding.previous = bindings[name]
      }
      bindings[name] = binding
    }
    defineType: |t: TypeDeclaration| {
      let name = t.name.name
      if typeBindings[name]
        then reportError(t, 'Type $name is already defined')

      typeBindings[name] = {
        name
        parameters: if t.parameters
          then getMinMax(t.parameters, |p| p.defaultValue, reportError, 'type parameter')
      }
    }
    inspect: |depth, opts| {
      let scope = {}
      if parent then scope['[parent]'] = parent.inspect()
      Object.assign(scope, bindings)

      if not depth and not opts
        then scope
        else inspect(scope, Object.assign({}, opts, {depth}))
    }
  }
}

fn defineFunction(scope, f: FunctionDeclaration, reportError) {
  if f.name then
    scope.define({
      identifier: f.name
      token: f
      mutable: false
      ty: createFunctionType(f, reportError)
    })
}

fn definedHosted(scope, expressions: List<Expression>, reportError) {
  expressions.forEach(|e| {
    if e.kind == SyntaxKind.Function {
      defineFunction(scope, e, reportError)
      e.hoisted = true
    }
    if e.kind == SyntaxKind.ExportDirective and
        e.expression.kind == SyntaxKind.Function {
      defineFunction(scope, e.expression, reportError)
      e.expression.hoisted = true
    }
  })
}

fn definedHostedTopLevel(scope, expressions: List<Expression>) {
  expressions.forEach(|e| {
    if e.kind == SyntaxKind.TraitDeclaration
    or e.kind == SyntaxKind.TypeDeclaration {
      scope.defineType(e)
      e.hoisted = true
    }
    if e.kind == SyntaxKind.ExportDirective and (
      e.expression.kind == SyntaxKind.TraitDeclaration or
      e.expression.kind == SyntaxKind.TypeDeclaration
    ) {
      scope.defineType(e.expression)
      e.expression.hoisted = true
    }
  })
}

export fn TopScopeVisitor(context, file) {
  let mut scope = createScope(context, file)
  let reportError = context.reportError.bind(context, file)

  Object.assign({}, visit.Visitor, {

    visitBlock: |self, b: Block| {}
    visitFunctionDeclaration: |self, f: FunctionDeclaration| {
      defineFunction(scope, f, reportError)
    }
    visitIdentifier: |self, i: Identifier| {}
    visitModule: |self, m: Module| {
      m.scope = scope
      visit.walkModule(self, m)
    }
    visitObjectDestructure: |self, i: ObjectDestructure| {
      // Allow redeclaration in this pass as we don't yet know if the type or variable scope
      // should be used for the imported identifiers.
      i.members.forEach(|m| scope.define({identifier: m.local, mutable: false, token: m}, true))
    }
    visitTraitDeclaration: |self, t: TraitDeclaration| {
      scope.defineType(t)
    }
    visitTypeBound: |self, t: TypeBound| {}
    visitTypeDeclaration: |self, t: TypeDeclaration| {
      scope.defineType(t)
    }
    visitVariableDeclaration: |self, d: VariableDeclaration| {
      scope.define({identifier: d.identifier, mutable: d.mutable, token: d}, true)
    }

    visitExportDirective: |self, e: ExportDirective| {
      visit.walkExportDirective(self, e)
    }
    visitImportDirective: |self, i: ImportDirective| {
      if i.specifier.kind == SyntaxKind.Identifier
        then scope.define({identifier: i.specifier, mutable: false, token: i})
      else if i.specifier.kind == SyntaxKind.ObjectDestructure
        then visit.walkImportDirective(self, i)
    }

    visitAssignmentExpression: |self, e: AssignmentExpression| {}
    visitBinaryExpression: |self, e: BinaryExpression| {}
    visitCallExpression: |self, e: CallExpression| {}
    visitForExpression: |self, e: ForExpression| {}
    visitIfExpression: |self, e: IfExpression| {}
    visitLoopExpression: |self, e: LoopExpression| {}
    visitUnaryExpression: |self, e: UnaryExpression| {}
    visitWhileExpression: |self, e: WhileExpression| {}
    visitIndexAccess: |self, a: IndexAccess| {}
    visitMemberAccess: |self, a: MemberAccess| {}

    visitBreak: |self, b: Token| {}
    visitReturn: |self, r: ReturnStatement| {}

    visitListLiteral: |self, l: ListLiteral| {}
    visitBooleanLiteral: |self, l: BooleanLiteral| {}
    visitNumberLiteral: |self, l: NumberLiteral| {}
    visitObjectLiteral: |self, l: ObjectLiteral| {}
    visitStringLiteral: |self, l: StringLiteral| {}
  })
}

export fn ScopeVisitor(context, file) {
  let mut importDirective: ImportDirective
  let mut scope = createScope(context, file)
  let reportError = context.reportError.bind(context, file)

  Object.assign({}, visit.Visitor, {

    visitBlock: |self, b: Block| {
      b.scope = scope
      definedHosted(scope, b.block, reportError)
      visit.walkBlock(self, b)
    }
    visitFunctionDeclaration: |self, f: FunctionDeclaration| {
      if not f.hoisted then defineFunction(scope, f, reportError)
      scope = createScope(context, file, scope)
      f.scope = scope
      visit.walkFunction(self, f)
      scope = scope.parent
    }
    visitIdentifier: |self, i: Identifier| {
      i.scope = scope
      let binding = i.scope.getBinding(i.name)
      if not binding then reportError(i, 'Use of undefined variable ' + i.name)
      visit.walkIdentifier(self, i)
    }
    visitModule: |self, m: Module| {
      m.scope = scope
      definedHostedTopLevel(scope, m.lines)
      definedHosted(scope, m.lines, reportError)
      visit.walkModule(self, m)
    }
    visitObjectDestructure: |self, i: ObjectDestructure| {
      i.scope = scope
      i.members.forEach(|m| {
        if importDirective.module {
          let e = importDirective.module.exports[m.local.name]
          if e.expression.kind == SyntaxKind.TypeDeclaration
            then scope.defineType(e.expression)
            else scope.define({identifier: m.local, mutable: false, token: m})
        }
        else scope.define({identifier: m.local, mutable: false, token: m})
      })
    }
    visitTraitDeclaration: |self, t: TraitDeclaration| {
      scope = createScope(context, file, scope)
      t.scope = scope
      visit.walkTraitDeclaration(self, t)
      scope = scope.parent
    }
    visitFunctionTypeBound: |self, t: FunctionTypeBound| {
      scope = createScope(context, file, scope)
      t.scope = scope
      visit.walkFunctionTypeBound(self, t)
      scope = scope.parent
    }
    visitNamedTypeBound: |self, t: NamedTypeBound| {
      t.scope = scope

      let binding = t.scope.getTypeBinding(t.name.name)
      if not binding then reportError(t, 'Use of undeclared type ' + t.name.name)


      if binding.parameters
        then checkMinMax(t.parameters, binding.parameters, reportError, 'type parameters', t.name.name, t)
      else if t.parameters.length > 0
        then reportError(t, 'Type ' + t.name.name + ' is not generic')

      visit.walkNamedTypeBound(self, t)
    }
    visitTypeDeclaration: |self, t: TypeDeclaration| {
      scope = createScope(context, file, scope)
      visit.walkTypeDeclaration(self, t)
      scope = scope.parent
    }
    visitTypeParameter: |self, t: TypeParameter| {
      t.scope = scope
      scope.defineType(t)
      visit.walkTypeParameter(self, t)
    }
    visitVariableDeclaration: |self, d: VariableDeclaration| {
      d.scope = scope
      if d.typeBound then self.visitTypeBound(d.typeBound)
      scope.define({identifier: d.identifier, mutable: d.mutable, token: d}, true)
      if d.initializer then self.visitExpression(d.initializer)
    }

    visitExportDirective: |self, e: ExportDirective| {
      e.scope = scope
      visit.walkExportDirective(self, e)
    }
    visitImportDirective: |self, i: ImportDirective| {
      i.scope = scope
      if i.specifier.kind == SyntaxKind.Identifier
        then scope.define({identifier: i.specifier, mutable: false, token: i})
      else if i.specifier.kind == SyntaxKind.ObjectDestructure {
        importDirective = i
        visit.walkImportDirective(self, i)
      }
    }

    visitAssignmentExpression: |self, e: AssignmentExpression| {
      e.scope = scope
      if e.lhs.kind == SyntaxKind.Identifier {
        let binding = e.scope.getBinding(e.lhs.name)
        if binding and not binding.mutable
          then reportError(e, "Can't assign to immutable variable " + e.lhs.name)
      }
      visit.walkAssignmentExpression(self, e)
    }
    visitBinaryExpression: |self, e: BinaryExpression| {
      e.scope = scope
      visit.walkBinaryExpression(self, e)
    }
    visitCallExpression: |self, e: CallExpression| {
      e.scope = scope
      visit.walkCallExpression(self, e)
      if e.func.kind == SyntaxKind.Identifier {
        let binding = scope.getBinding(e.func.name)

        checkFunctionType(binding, e, reportError)
      }
    }
    visitForExpression: |self, e: ForExpression| {
      scope = createScope(context, file, scope)
      e.scope = scope
      visit.walkForExpression(self, e)
      scope = scope.parent
    }
    visitIfExpression: |self, e: IfExpression| {
      scope = createScope(context, file, scope)
      e.scope = scope
      visit.walkIfExpression(self, e)
      scope = scope.parent
    }
    visitLoopExpression: |self, e: LoopExpression| {
      scope = createScope(context, file, scope)
      e.scope = scope
      visit.walkLoopExpression(self, e)
      scope = scope.parent
    }
    visitUnaryExpression: |self, e: UnaryExpression| {
      e.scope = scope
      visit.walkUnaryExpression(self, e)
    }
    visitWhileExpression: |self, e: WhileExpression| {
      scope = createScope(context, file, scope)
      e.scope = scope
      visit.walkWhileExpression(self, e)
      scope = scope.parent
    }
    visitIndexAccess: |self, a: IndexAccess| {
      a.scope = scope
      visit.walkIndexAccess(self, a)
    }
    visitMemberAccess: |self, a: MemberAccess| {
      a.scope = scope
      visit.walkExpression(self, a.object)
    }

    visitBreak: |self, b: Token| {
      b.scope = scope
      visit.walkBreak(self, b)
    }
    visitReturn: |self, r: ReturnStatement| {
      r.scope = scope
      visit.walkReturn(self, r)
    }

    visitListLiteral: |self, l: ListLiteral| {
      l.scope = scope
      visit.walkListLiteral(self, l)
    }
    visitBooleanLiteral: |self, l: BooleanLiteral| {
      l.scope = scope
      visit.walkBooleanLiteral(self, l)
    }
    visitNumberLiteral: |self, l: NumberLiteral| {
      l.scope = scope
      visit.walkNumberLiteral(self, l)
    }
    visitObjectLiteral: |self, l: ObjectLiteral| {
      l.scope = scope
      l.members.forEach(|m| {
        self.visitExpression(m.value)
      })
    }
    visitStringLiteral: |self, l: StringLiteral| {
      l.scope = scope
      visit.walkStringLiteral(self, l)
    }
  })
}

