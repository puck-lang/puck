import 'node:util' as {inspect}
import 'puck:js' as {Object, undefined}
import '../ast/ast.puck' as {
  Expression

  Block
  FunctionDeclaration
  Identifier
  Module
  ObjectDestructure
  TypeBound
  FunctionTypeBound
  NamedTypeBound
  TraitDeclaration
  TypeDeclaration
  TypeParameter
  TypeProperty
  VariableDeclaration

  ExportDirective
  ImportDirective

  AssignmentExpression
  BinaryExpression
  CallExpression
  ForExpression
  IfExpression
  LoopExpression
  UnaryExpression
  WhileExpression

  IndexAccess
  MemberAccess

  Token
  ReturnStatement

  ListLiteral
  BooleanLiteral
  NumberLiteral
  ObjectLiteral
  StringLiteral
}
import '../ast/visit.puck' as visit
import '../compiler/ast.ts' as {SyntaxKind}

type MinMax = {
  min: Num
  max: Num
}

/// Represents a simple type like String or Num
type Type = {
  kind: String
  name: String
  // properties: Object<Type>
}

/// Represents a generic type like List<T>
type TypeClass = { // + Type
  parameterRange: MinMax
}

/// Represents an instance of a generic type like List<String> or List<Num>
type TypeInstance = { // + Type
  class: TypeClass
  parameters: List<Type>
}

/// Represents a function type (Num, Num) => Bool
type FunctionType = { // + Type
  arguments: List<Binding>
  argumentRange: MinMax
  returnType: Type
}

type GenericFunction = {}  // FunctionType + TypeClass
type GenericFunctionInstace = {}  // FunctionType + TypeInstance

type Binding = {
  identifier: Identifier
  token: Token
  mutable: Bool
  ty: Type //?
  redefined: Bool
  previous: Binding //?
}

type TypeBinding = {
  name: String
  ty: Type //?
}

type Scope = {
  getLocalBinding: (String) => Binding
  // getBinding: (String, allowRedeclare = true) => Binding
  getBinding: (String) => Binding
  getTypeBinding: (String) => Binding
  define: (String, Binding) => Binding
  defineType: (String, Binding) => Binding
}

type ScopeAware = {
  scope: Scope
}

fn isTypeClass(ty: Type) {
  ty.parameterRange
}

fn createTypeInstance(class: TypeClass, parameters: List<Type>) then {
  kind: class.name + '<' + parameters.map(|p| p.name).join(', ') + '>'
  name: class.name + '<' + parameters.map(|p| p.name).join(', ') + '>'
  class
  parameters
}

fn getType(scope: Scope, t, name: String = undefined) { // t: TypeBound
  if not t then return undefined
  if t.name {
    let binding = scope.getTypeBinding(t.name.name)

    if isTypeClass(binding.ty)
      then createTypeInstance(binding.ty, t.parameters)
    else binding.ty
  }
  else {
    let arguments = t.arguments.map(|p| {{ty: getType(scope, p)}})
    let returnType = getType(scope, t.returnType)

    {
      kind: 'Function'
      name: getFunctionTypeName(arguments, returnType)
      arguments
      argumentRange: {min: arguments.length, max: arguments.length}
      returnType
    }
  }
}

fn getFunctionTypeName(arguments: List<TypeInstance>, returnType: TypeInstance)
  then '(' + arguments.map(|a| (a and a.name) or '??').join(', ') + ') => ' +
        (returnType and returnType.name or '??')

fn getMinMax<T>(parameters: List<T>, isOptional: (T) => Bool, reportError, name: String): MinMax {
  let mut firstOptional = parameters.length
  let mut hasOptional = false

  parameters.forEach(|parameter, i|
    if isOptional(parameter) and not hasOptional {
      hasOptional = true
      firstOptional = i
    }
    else if not isOptional(parameter) and hasOptional then reportError(parameter
      "An optional $name can't be followed by a required $name"
    )
  )

  {
    min: firstOptional
    max: parameters.length
  }
}

fn isAssignable(to: Type, subject: Type) {
  if not subject or not to then return true

  let sameKind = subject.kind == to.kind

  if not sameKind then return false

  if sameKind and to.kind == 'Function' {
    if to.argumentRange.min < subject.argumentRange.min
    or to.argumentRange.max > subject.argumentRange.max
      then return false

    to.arguments.every(fn (toArg, i) {
      let subjectArg = subject.arguments[i]

      isAssignable(toArg, subjectArg)
    })
  }
  else true
}

fn checkMinMax<T>(arguments: List<T>, minMax: MinMax, reportError, argumentName: String, subjectName: String, token) { // token: Token
  let argumentCount = arguments.length
  let max = minMax.max
  let min = minMax.min
  let error =
    if argumentCount < min
      then 'few'
    else if argumentCount > max
      then 'many'

  if error {
    let required =
      if min == max
        then min
        else '$min to $max'

    reportError(token
      'Too $error $argumentName given to $subjectName, $required required, $argumentCount given'
    )
  }
}

fn createFunctionType(scope: Scope, f: FunctionDeclaration, reportError) {
  let arguments = f.parameterList.map(|p| {{
    identifier: p.identifier
    mutable: p.mutable
    ty: getType(scope, p.typeBound, p.identifier.name)
  }})
  let returnType = getType(scope, f.returnType)

  {
    kind: 'Function'
    name: if f.name then f.name.name else getFunctionTypeName(arguments, returnType)
    arguments
    argumentRange: if f.parameterList
      then getMinMax(f.parameterList, |p| p.initializer, reportError, 'parameter')
      else {{min: 0, max: 0}}
    returnType
  }
}

fn createScope(context, file, parent = undefined) {
  let reportError = context.reportError.bind(context, file)
  let mut bindings = {}
  let mut typeBindings = {}

  {
    parent
    getLocalBinding: |name| bindings[name]
    getBinding: |name| bindings[name] or (parent and parent.getBinding(name))
    getTypeBinding: |name| typeBindings[name] or (parent and parent.getTypeBinding(name))
    define: |mut binding: Binding, allowRedeclare = false| {
      let name = binding.name
      binding.redefined = bindings[name] != undefined
      if binding.redefined {
        if not allowRedeclare
          then reportError(binding.token, '$name has already been declared in the scope')
        bindings[name].redefined = true
        binding.previous = bindings[name]
      }
      bindings[name] = binding
    }
    defineType: |t: TypeDeclaration| {
      let name = t.name.name
      if typeBindings[name]
        then reportError(t, 'Type $name is already defined')

      let parameterRange = if t.parameters and t.parameters.length
        then getMinMax(t.parameters, |p| p.defaultValue, reportError, 'type parameter')

      let ty = {
        kind: name
        name
        parameterRange
      }

      let binding = {
        name
        ty
      }

      typeBindings[name] = binding
    }
    inspect: |depth, opts| {
      let mut scope = {}
      if parent then scope['[parent]'] = parent.inspect()
      Object.assign(scope, bindings)

      if not depth and not opts
        then scope
        else inspect(scope, Object.assign({}, opts, {depth}))
    }
  }
}

fn defineFunction(scope: Scope, mut f: FunctionDeclaration) {
  if f.name then
    scope.define({
      name: f.name.name
      token: f
      mutable: false
      ty: f.ty
    })
}

fn definedHosted(visitor, scope: Scope, expressions: List<Expression>) {
  expressions.forEach(|mut e| {
    if e.kind == SyntaxKind.Function {
      e.hoisting = true
      visitor.visitFunctionDeclaration(e)
      e.hoisted = true
    }
    if e.kind == SyntaxKind.ExportDirective and
        e.expression.kind == SyntaxKind.Function {
      e.expression.hoisting = true
      visitor.visitFunctionDeclaration(e.expression)
      e.expression.hoisted = true
    }
  })
}

fn definedHostedTopLevel(visitor, scope: Scope, expressions: List<Expression>) {
  expressions.forEach(|mut e| {
    if e.kind == SyntaxKind.ImportDirective {
      visitor.visitImportDirective(e)
      e.hoisted = true
    }
    else if e.kind == SyntaxKind.TraitDeclaration
         or e.kind == SyntaxKind.TypeDeclaration {
      e.ty = scope.defineType(e).ty
      e.hoisted = true
    }
    else if e.kind == SyntaxKind.ExportDirective and (
      e.expression.kind == SyntaxKind.TraitDeclaration or
      e.expression.kind == SyntaxKind.TypeDeclaration
    ) {
      e.expression.ty = scope.defineType(e.expression).ty
      e.expression.hoisted = true
    }
  })
}

export fn TopScopeVisitor(context, file) {
  let mut scope = createScope(context, file)

  Object.assign({}, visit.Visitor, {

    visitBlock: |self, b: Block| {}
    visitFunctionDeclaration: |self, mut f: FunctionDeclaration| {
      defineFunction(scope, f)
    }
    visitIdentifier: |self, i: Identifier| {}
    visitModule: |self, mut m: Module| {
      m.scope = scope
      visit.walkModule(self, m)
    }
    visitObjectDestructure: |self, i: ObjectDestructure| {
      // Allow redeclaration in this pass as we don't yet know if the type or variable scope
      // should be used for the imported identifiers.
      i.members.forEach(|m| scope.define({name: m.local.name, mutable: false, token: m}, true))
    }
    visitTraitDeclaration: |self, t: TraitDeclaration| {
      scope.defineType(t)
    }
    visitTypeBound: |self, t: TypeBound| {}
    visitTypeDeclaration: |self, t: TypeDeclaration| {
      scope.defineType(t)
    }
    visitVariableDeclaration: |self, d: VariableDeclaration| {
      scope.define({name: d.identifier.name, mutable: d.mutable, token: d}, true)
    }

    visitExportDirective: |self, e: ExportDirective| {
      visit.walkExportDirective(self, e)
    }
    visitImportDirective: |self, i: ImportDirective| {
      if i.specifier.kind == SyntaxKind.Identifier
        then scope.define({name: i.specifier.name, mutable: false, token: i})
      else if i.specifier.kind == SyntaxKind.ObjectDestructure
        then visit.walkImportDirective(self, i)
    }

    visitAssignmentExpression: |self, e: AssignmentExpression| {}
    visitBinaryExpression: |self, e: BinaryExpression| {}
    visitCallExpression: |self, e: CallExpression| {}
    visitForExpression: |self, e: ForExpression| {}
    visitIfExpression: |self, e: IfExpression| {}
    visitLoopExpression: |self, e: LoopExpression| {}
    visitUnaryExpression: |self, e: UnaryExpression| {}
    visitWhileExpression: |self, e: WhileExpression| {}
    visitIndexAccess: |self, a: IndexAccess| {}
    visitMemberAccess: |self, a: MemberAccess| {}

    visitBreak: |self, b: Token| {}
    visitReturn: |self, r: ReturnStatement| {}

    visitListLiteral: |self, l: ListLiteral| {}
    visitBooleanLiteral: |self, l: BooleanLiteral| {}
    visitNumberLiteral: |self, l: NumberLiteral| {}
    visitObjectLiteral: |self, l: ObjectLiteral| {}
    visitStringLiteral: |self, l: StringLiteral| {}
  })
}

export fn ScopeVisitor(context, file) {
  let mut importDirective: ImportDirective
  let mut scope = createScope(context, file)
  let reportError = context.reportError.bind(context, file)

  fn reportNotAssignableError(t, to: TypeInstance, subject: TypeInstance) { // t: Token
    reportError(t, subject.name + ' is not assignable to type ' + to.name)
  }

  fn checkFunctionType(binding: Binding, c: CallExpression) {
    if not binding.ty then return undefined
    let name = binding.ty.name

    if not binding.ty.arguments
      then reportError(c, '$name is not callable')

    checkMinMax(c.argumentList, binding.ty.argumentRange, reportError, 'arguments', binding.name, c)

    c.argumentList.forEach(|argument, i| {
      let parameter = binding.ty.arguments[i]

      if not isAssignable(parameter.ty, argument.ty)
        then reportNotAssignableError(argument, parameter.ty, argument.ty)

      if parameter.mutable and argument.kind == SyntaxKind.Identifier {
        let argumentName = argument.name
        let argumentBinding = scope.getBinding(argumentName)

        if not argumentBinding.mutable {
          let functionName =
            if c.func.kind == SyntaxKind.Identifier
              then c.func.name
              else 'function'
          let parameterName =
            if parameter.identifier
              then parameter.identifier.name
              else i
          reportError(argument
            'Parameter $parameterName of $functionName requires a mutable binding ' +
            'but $argumentName is declared as immutable.'
          )
        }
      }
    })
  }

  fn getBinding(token: Token)
    then if token.kind == SyntaxKind.Identifier
      then token.scope.getBinding(token.name)
    else if token.kind == SyntaxKind.MemberAccess
      then getBinding(token.object)
    else if token.kind == SyntaxKind.IndexAccess
      then getBinding(token.object)

  Object.assign({}, visit.Visitor, {

    visitBlock: |self, mut b: Block| {
      b.scope = scope
      definedHosted(self, scope, b.block)
      visit.walkBlock(self, b)
    }
    visitFunctionDeclaration: |self, mut f: FunctionDeclaration| {
      if not f.hoisting or not f.hoisted {
        scope = createScope(context, file, scope)
        f.scope = scope
        if f.typeParameters
          then f.typeParameters.forEach(self.visitTypeParameter.bind(self))
        f.ty = createFunctionType(scope, f, reportError)
        defineFunction(scope.parent, f)
      }
      if not f.hoisting or f.hoisted {
        scope = f.scope

        f.parameterList.forEach(self.visitVariableDeclaration.bind(self))
        if f.returnType then self.visitTypeBound(f.returnType)
        if f.body then self.visitBlock(f.body)
      }
      scope = scope.parent
    }
    visitIdentifier: |self, mut i: Identifier| {
      i.scope = scope
      let binding = i.scope.getBinding(i.name)
      if not binding
        then reportError(i, 'Use of undefined variable ' + i.name + inspect(i))
        else i.ty = binding.ty
      visit.walkIdentifier(self, i)
    }
    visitModule: |self, mut m: Module| {
      m.scope = scope
      definedHostedTopLevel(self, scope, m.lines)
      definedHosted(self, scope, m.lines)
      visit.walkModule(self, m)
    }
    visitObjectDestructure: |self, mut i: ObjectDestructure| {
      i.scope = scope
      i.members.forEach(|m| {
        if importDirective.module {
          let e = importDirective.module.exports[m.local.name]
          if e.expression.kind == SyntaxKind.TypeDeclaration
            then scope.defineType(e.expression)
            else scope.define({name: m.local.name, mutable: false, token: m})
        }
        else scope.define({name: m.local.name, mutable: false, token: m})
      })
    }
    visitTraitDeclaration: |self, mut t: TraitDeclaration| {
      scope = createScope(context, file, scope)
      t.scope = scope
      visit.walkTraitDeclaration(self, t)
      scope = scope.parent
    }
    visitFunctionTypeBound: |self, mut t: FunctionTypeBound| {
      scope = createScope(context, file, scope)
      t.scope = scope

      visit.walkFunctionTypeBound(self, t)

      t.ty = getType(scope, t)

      scope = scope.parent
    }
    visitNamedTypeBound: |self, mut t: NamedTypeBound| {
      t.scope = scope

      let binding = t.scope.getTypeBinding(t.name.name)
      if not binding then reportError(t, 'Use of undeclared type ' + t.name.name)

      if isTypeClass(binding.ty)
        then checkMinMax(t.parameters, binding.ty.parameterRange, reportError, 'type parameters', binding.name, t)
      else if t.parameters.length > 0
        then reportError(t, 'Type ' + binding.name + ' is not generic')

      visit.walkNamedTypeBound(self, t)

      t.ty = getType(scope, t, t.name.name)
    }
    visitTypeDeclaration: |self, mut t: TypeDeclaration| {
      scope = createScope(context, file, scope)
      visit.walkTypeDeclaration(self, t)

      t.ty.properties = objectFromList(t.properties.map(|p| [p.name.name, p.typeBound.ty]))

      scope = scope.parent
    }
    visitTypeParameter: |self, mut t: TypeParameter| {
      t.scope = scope
      scope.defineType(t)
      visit.walkTypeParameter(self, t)
    }
    visitVariableDeclaration: |self, mut d: VariableDeclaration| {
      d.scope = scope
      if d.typeBound then self.visitTypeBound(d.typeBound)

      let mut binding = scope.define({
        name: d.identifier.name,
        mutable: d.mutable,
        token: d,
        ty: getType(scope, d.typeBound)
      }, true)

      if d.initializer {
        self.visitExpression(d.initializer)
        if not binding.ty
          then binding.ty = d.initializer.ty
        else if not isAssignable(binding.ty, d.initializer.ty)
          then reportNotAssignableError(d, binding.ty, d.initializer.ty)
      }
    }

    visitExportDirective: |self, mut e: ExportDirective| {
      e.scope = scope
      visit.walkExportDirective(self, e)
    }
    visitImportDirective: |self, mut i: ImportDirective| {
      if i.hoisted then return undefined

      i.scope = scope
      if i.specifier.kind == SyntaxKind.Identifier
        then scope.define({name: i.specifier.name, mutable: false, token: i})
      else if i.specifier.kind == SyntaxKind.ObjectDestructure {
        importDirective = i
        visit.walkImportDirective(self, i)
      }
    }

    visitAssignmentExpression: |self, mut e: AssignmentExpression| {
      e.scope = scope
      visit.walkAssignmentExpression(self, e)
      if let binding = getBinding(e.lhs) {
        if not binding.mutable
          then reportError(e, "Can't assign to immutable variable " + binding.name)

        if not isAssignable(e.lhs.ty, e.rhs.ty)
          then reportNotAssignableError(e, e.lhs.ty, e.rhs.ty)
      }
    }
    visitBinaryExpression: |self, mut e: BinaryExpression| {
      e.scope = scope
      visit.walkBinaryExpression(self, e)
    }
    visitCallExpression: |self, mut e: CallExpression| {
      e.scope = scope
      visit.walkCallExpression(self, e)

      if e.func.ty {
        checkFunctionType(e.func, e)
        e.ty = e.func.ty.returnType
      }
    }
    visitForExpression: |self, mut e: ForExpression| {
      scope = createScope(context, file, scope)
      e.scope = scope
      visit.walkForExpression(self, e)
      scope = scope.parent
    }
    visitIfExpression: |self, mut e: IfExpression| {
      scope = createScope(context, file, scope)
      e.scope = scope
      visit.walkIfExpression(self, e)
      scope = scope.parent
    }
    visitLoopExpression: |self, mut e: LoopExpression| {
      scope = createScope(context, file, scope)
      e.scope = scope
      visit.walkLoopExpression(self, e)
      scope = scope.parent
    }
    visitUnaryExpression: |self, mut e: UnaryExpression| {
      e.scope = scope
      visit.walkUnaryExpression(self, e)

      e.ty =
        if e.operator.kind == SyntaxKind.NotKeyword
          then {kind: 'Bool', name: 'Bool'}
        else if e.operator.kind == SyntaxKind.MinusToken
             or e.operator.kind == SyntaxKind.PlusToken
          then {kind: 'Num', name: 'Num'}
    }
    visitWhileExpression: |self, mut e: WhileExpression| {
      scope = createScope(context, file, scope)
      e.scope = scope
      visit.walkWhileExpression(self, e)
      scope = scope.parent
    }
    visitIndexAccess: |self, mut a: IndexAccess| {
      a.scope = scope
      visit.walkIndexAccess(self, a)
    }
    visitMemberAccess: |self, mut a: MemberAccess| {
      a.scope = scope
      visit.walkExpression(self, a.object)
    }

    visitBreak: |self, mut b: Token| {
      b.scope = scope
      visit.walkBreak(self, b)
    }
    visitReturn: |self, mut r: ReturnStatement| {
      r.scope = scope
      visit.walkReturn(self, r)
    }

    visitListLiteral: |self, mut l: ListLiteral| {
      l.scope = scope
      visit.walkListLiteral(self, l)
    }
    visitBooleanLiteral: |self, mut l: BooleanLiteral| {
      l.scope = scope
      l.ty = {kind: 'Bool', name: 'Bool'}
      visit.walkBooleanLiteral(self, l)
    }
    visitNumberLiteral: |self, mut l: NumberLiteral| {
      l.scope = scope
      l.ty = {kind: 'Num', name: 'Num'}
      visit.walkNumberLiteral(self, l)
    }
    visitObjectLiteral: |self, mut l: ObjectLiteral| {
      l.scope = scope
      l.members.forEach(|m| {
        self.visitExpression(m.value)
      })
    }
    visitStringLiteral: |self, mut l: StringLiteral| {
      l.scope = scope
      l.ty = {kind: 'String', name: 'String'}
      visit.walkStringLiteral(self, l)
    }
  })
}

