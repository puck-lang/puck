import 'puck:js' as {Object, undefined}
import '../ast/ast.puck' as {
  Module
  TopLevelStatement
  Expression

  ImplDeclaration
  ImplShorthandDeclaration
  TraitDeclaration
  TypeDeclaration

  ImportDirective
  ImportSpecifier
  ObjectDestructure
  ExportDirective
  ExportedStatement

  TypeBound
}
import '../ast/span.puck' as {ToSpan}
import '../ast/visit.puck' as visit
import '../compiler/ast.ts' as {SyntaxKind}
import 'src/functions.puck' as {checkFunctionAssignability}
import 'src/range.puck' as {checkRange}
import 'src/scope.puck' as {Binding, Scope}
import 'src/structure_visitor.puck' as {structureVisitor}
import 'src/types.puck' as {
  isAssignable
  isSameType
}
import '../entities.puck' as {
  Implementation
  Trait
  Type
  TypeInstance
  TypeKind
}

fn implementTrait(traitType: Type, trait_: Trait, type_: Type, implementable: {implementations: List<Implementation>}, mut i: ImplDeclaration, reportError: (ToSpan, String) -> (), id: String) {
  let traitName = traitType.displayName()

  if implementable.implementations.any(|imp| imp.trait_ == traitType)
    then reportError(i, '$traitName has already been implemented for ' + type_.displayName())

  let functions = ObjectMap.fromIter(
    i.members.map(|functionDeclaration| {
      (functionDeclaration.type_.name.unwrap(), functionDeclaration.type_)
    })
  )

  let traitFunctions = trait_.functions

  traitFunctions.keys().forEach(|name| {
    let traitFunctionType: Type = traitFunctions[name]
    let traitFunction = traitFunctionType.getFunction()
    if traitFunction.isAbstract and not functions[name]
      then reportError(i, 'Function $traitName::$name is not implemented for ' + type_.displayName())
  })

  i.members.forEach(|functionDeclaration| {
    let functionName = functionDeclaration.type_.displayName()
    let function = functionDeclaration.type_.getFunction()
    let traitFunctionType: Type = traitFunctions[functionDeclaration.type_.name.unwrap()]
    if not traitFunctionType
      then reportError(i, 'Function $functionName is not defined by $traitName')
    let traitFunctionName = traitFunctionType.displayName()
    let traitFunction = traitFunctionType.getFunction()

    if let Option::Some(implSelf) = function.selfBinding {
      if let Option::Some(traitSelf) = traitFunction.selfBinding {
        if implSelf.mutable and not traitSelf.mutable
          then reportError(functionDeclaration, 'Function $traitName::$traitFunctionName requires an immutable self parameter')
      }
      else reportError(functionDeclaration, 'Function $traitName::$traitFunctionName is static')
      ()
    }
    else if let Option::Some(_) = traitFunction.selfBinding
      then reportError(functionDeclaration, 'Function $traitName::$traitFunctionName requires a self parameter')
  })

  let implementation = Implementation({
    id
    type_: type_
    trait_: traitType
  })

  i.implementation = implementation
  implementable.implementations.push(implementation)

  i.members.forEach(|mut functionDeclaration| {
    let functionName = functionDeclaration.type_.displayName()
    let traitFunctionType: Type = traitFunctions[functionDeclaration.type_.name.unwrap()]
    let traitFunction = traitFunctionType.getFunction()
    let function = functionDeclaration.type_.getFunction()
    functionDeclaration.traitFunctionType = traitFunctionType

    if let Result::Err(error) = checkFunctionAssignability(functionName, traitFunction, function)
      then reportError(functionDeclaration, error)
  })
}

fn implementShorthand(type_: Type, mut implementable: {implementations: List<Implementation>}, i: ImplShorthandDeclaration, reportError: (ToSpan, String) -> ()) {
  let typeName = type_.displayName()

  if implementable.implementations.any(|imp| imp.trait_.getTrait().isShorthand)
    then reportError(i, '$typeName has already been implemented')

  let functions = ObjectMap.fromIter(
    i.members.map(|functionDeclaration|
      (functionDeclaration.type_.name.unwrap(), functionDeclaration.type_)
    )
  )

  implementable.implementations.add({
    type_: type_
    trait_: {
      id: type_.id
      displayName: type_.displayName
      name: type_.name
      kind: TypeKind::Trait({
        isShorthand: true
        functions
      })
      class: None
      instance: None
      providesType: None
      enumMember: None
      complete: true
    }
  })
}

export fn ImplVisitor(mut context, file) {
  let mut importDirective: ImportDirective
  let reportError: (ToSpan, String) -> () = context.reportError.bind(context, file)

  fn getImplId(type_: Type, trait_: Type) {
    let mut id = '\$impl_' + type_.id.unwrap() + '\$' + trait_.id.unwrap()
    if context.impls[id] {
      id = '$id\$' + context.impls[id]
      context.impls[id] += 1
    }
    else {
      context.impls[id] = 1
    }
    id
  }

  Object.assign({}, visit.emptyVisitor, structureVisitor(reportError, 'ImplVisitor'), {
    visitModule: |mut self, mut m: Module| {
      self.scope = m.scope
      m.statements
        .filter(|e| match e {
          TopLevelStatement::ImplDeclaration(_) => true
          TopLevelStatement::ImplShorthandDeclaration(_) => true
          _ => false
        })
        .forEach(|s| self.visitTopLevelStatement(s))
    }

    visitImplDeclaration: |mut self, mut i: ImplDeclaration| {
      let parentScope: Scope = self.scope
      let mut scope = parentScope.createChild()
      self.scope = scope
      i.scope = scope
      i.typeParameters.forEach(self.visitTypeParameter.bind(self))
      self.visitTypeBound(i.trait_)
      self.visitTypeBound(i.type_)

      let traitType = i.trait_.getType()
      let mut structType = i.type_.getType()
      scope.setSelfType(structType)
      i.members.forEach(|m| self.visitMethodDeclaration(m, structType))
      let id = getImplId(traitType, structType)

      if let TypeKind::Trait(trait_) = traitType.kind {
        match structType.kind {
          TypeKind::Enum(enum_) => implementTrait(traitType, trait_, structType, enum_, i, reportError, id)
          TypeKind::Struct(struct) => implementTrait(traitType, trait_, structType, struct, i, reportError, id)
          _ => reportError(i.type_, structType.displayName() + ' is not a struct or an enum')
        }
      }
      else reportError(i.trait_, traitType.displayName() + ' is not a trait')

      self.scope = parentScope
    }
    visitImplShorthandDeclaration: |mut self, mut i: ImplShorthandDeclaration| {
      let parentScope: Scope = self.scope
      let mut scope = parentScope.createChild()
      self.scope = scope
      i.scope = self.scope
      i.typeParameters.forEach(self.visitTypeParameter.bind(self))
      self.visitTypeBound(i.type_)

      let mut structType = i.type_.getType()
      scope.setSelfType(structType)
      i.members.forEach(|m| self.visitMethodDeclaration(m, structType))

      match structType.kind {
        TypeKind::Enum(enum_) => {
          let mut e = enum_
          implementShorthand(structType, e, i, reportError)
        }
        TypeKind::Struct(struct) => {
          let mut s = struct
          implementShorthand(structType, s, i, reportError)
        }
        _ => reportError(i.type_, structType.displayName() + ' is not a struct or an enum')
      }

      self.scope = parentScope
    }
  })
}

