import 'puck:js' as {Object, undefined}
import '../ast/ast.puck' as {
  Module
  TopLevelStatement
  Expression

  ImplDeclaration
  ImplShorthandDeclaration
  TraitDeclaration
  TypeDeclaration

  ImportDirective
  ImportSpecifier
  ObjectDestructure
  ExportDirective
  ExportedStatement

  TypeBound
}
import '../ast/visit.puck' as visit
import '../compiler/ast.ts' as {SyntaxKind}
import 'src/functions.puck' as {checkFunctionAssignability}
import 'src/range.puck' as {checkRange}
import 'src/scope.puck' as {createScope}
import 'src/structure_visitor.puck' as {structureVisitor}
import 'src/types.puck' as {
  isAssignable
  isSameType
}
import '../entities.puck' as {
  Binding
  Implementation
  Trait
  Type
  TypeInstance
  TypeKind
}

fn implementTrait(traitType: Type, trait_: Trait, type_: Type, implementable: {implementations: List<Implementation>}, i: ImplDeclaration, reportError) {
  let traitName = traitType.displayName()

  if implementable.implementations.any(|imp| imp.trait_ == traitType)
    then reportError(i, '$traitName has already been implemented for ' + type_.displayName())

  let functions = ObjectMap.fromIter(
    i.members.map(|functionDeclaration| {
      (functionDeclaration.type_.name.unwrap(), functionDeclaration.type_)
    })
  )

  let traitFunctions = trait_.functions

  traitFunctions.keys().forEach(|name| {
    let traitFunctionType: Type = traitFunctions[name]
    let traitFunction = traitFunctionType.getFunction()
    if traitFunction.isAbstract and not functions[name]
      then reportError(i, 'Function $traitName::$name is not implemented for ' + type_.displayName())
  })

  i.members.forEach(|functionDeclaration| {
    let functionName = functionDeclaration.type_.displayName()
    let function = functionDeclaration.type_.getFunction()
    let traitFunctionType: Type = traitFunctions[functionDeclaration.type_.name.unwrap()]
    if not traitFunctionType
      then reportError(i, 'Function $functionName is not defined by $traitName')
    let traitFunctionName = traitFunctionType.displayName()
    let traitFunction = traitFunctionType.getFunction()

    if let Option::Some(implSelf) = function.selfBinding {
      if let Option::Some(traitSelf) = traitFunction.selfBinding {
        if implSelf.mutable and not traitSelf.mutable
          then reportError(functionDeclaration, 'Function $traitName::$traitFunctionName requires an immutable self parameter')
      }
      else reportError(function, 'Function $traitName::$traitFunctionName is static')
    }
    else if let Option::Some(_) = traitFunction.selfBinding
      then reportError(function, 'Function $traitName::$traitFunctionName requires a self parameter')
  })

  let implementation = {
    type_: type_
    trait_: traitType
  }

  implementable.implementations.push(implementation)

  i.members.forEach(|mut functionDeclaration| {
    let functionName = functionDeclaration.type_.displayName()
    let traitFunctionType: Type = traitFunctions[functionDeclaration.type_.name.unwrap()]
    let traitFunction = traitFunctionType.getFunction()
    let function = functionDeclaration.type_.getFunction()
    functionDeclaration.traitFunctionType = traitFunctionType

    if let Result::Err(error) = checkFunctionAssignability(functionName, traitFunction, function)
      then reportError(function, error)
  })
}

fn implementShorthand(type_: Type, implementable: {implementations: List<Implementation>}, i: ImplShorthandDeclaration, reportError) {
  let typeName = type_.displayName()

  if implementable.implementations.any(|imp| imp.trait_.getTrait().isShorthand)
    then reportError(i, '$typeName has already been implemented')

  let functions = ObjectMap.fromIter(
    i.members.map(|functionDeclaration|
      (functionDeclaration.type_.name.unwrap(), functionDeclaration.type_)
    )
  )

  implementable.implementations.push({
    type_: type_
    trait_: {
      displayName: type_.displayName
      name: type_.name
      kind: TypeKind::Trait({
        isShorthand: true
        functions
      })
      class: None
      instance: None
    }
  })
}

export fn ImplVisitor(context, file) {
  let mut importDirective: ImportDirective
  let reportError = context.reportError.bind(context, file)

  Object.assign({}, visit.emptyVisitor, structureVisitor, {
    reportError

    visitModule: |mut self, mut m: Module| {
      self.scope = m.scope
      // visit.walkModule(self, m)
      m.statements
        .filter(|e: TopLevelStatement| match e {
          // TopLevelStatement::ImportDirective(_) => true
          TopLevelStatement::ImplDeclaration(_) => true
          TopLevelStatement::ImplShorthandDeclaration(_) => true
          _ => false
        })
        .forEach(|s| self.visitTopLevelStatement(s))
    }

    visitImplDeclaration: |mut self, mut i: ImplDeclaration| {
      self.scope = self.scope.createChild()
      i.scope = self.scope
      i.typeParameters.forEach(self.visitTypeParameter.bind(self))
      self.visitTypeBound(i.trait_)
      self.visitTypeBound(i.type_)

      let traitType = i.trait_.getType()
      let structType = i.type_.getType()
      self.scope.setSelfBinding(structType.name.unwrap())
      i.members.forEach(|m| self.visitMethodDeclaration(m, structType))

      if let TypeKind::Trait(trait_) = traitType.kind {
        match structType.kind {
          TypeKind::Enum(enum_) => implementTrait(traitType, trait_, structType, enum_, i, reportError)
          TypeKind::Struct(struct) => implementTrait(traitType, trait_, structType, struct, i, reportError)
          _ => reportError(i.type_, structType.displayName() + ' is not a struct or an enum')
        }
      }
      else reportError(i.trait_, traitType.displayName() + ' is not a trait')

      self.scope = self.scope.parent
    }
    visitImplShorthandDeclaration: |mut self, mut i: ImplShorthandDeclaration| {
      self.scope = self.scope.createChild()
      i.scope = self.scope
      i.typeParameters.forEach(self.visitTypeParameter.bind(self))
      self.visitTypeBound(i.type_)

      let structType = i.type_.getType()
      self.scope.setSelfBinding(structType.name.unwrap())
      i.members.forEach(|m| self.visitMethodDeclaration(m, structType))

      match structType.kind {
        TypeKind::Enum(enum_) => implementShorthand(structType, enum_, i, reportError)
        TypeKind::Struct(struct) => implementShorthand(structType, struct, i, reportError)
        _ => reportError(i.type_, structType.displayName() + ' is not a struct or an enum')
      }

      self.scope = self.scope.parent
    }
  })
}

