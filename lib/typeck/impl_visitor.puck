import 'puck:js' as {Object, undefined}
import '../ast/ast.puck' as {
  Expression

  Block
  FunctionDeclaration
  Identifier
  ImplDeclaration
  ImplShorthandDeclaration
  Module
  ObjectDestructure
  TypeBound
  FunctionTypeBound
  NamedTypeBound
  TraitDeclaration
  TypeDeclaration
  TypeParameter
  VariableDeclaration

  ExportDirective
  ImportDirective

  AssignmentExpression
  BinaryExpression
  CallExpression
  ForExpression
  IfExpression
  UnaryExpression
  WhileLoop

  IndexAccess
  MemberAccess

  Token
  ReturnStatement

  ListLiteral
  BooleanLiteral
  NumberLiteral
  ObjectLiteral
  StringLiteral
}
import '../ast/visit.puck' as visit
import '../compiler/ast.ts' as {SyntaxKind}
import 'src/functions.puck' as {checkFunctionAssignability}
import 'src/range.puck' as {checkRange}
import 'src/scope.puck' as {createScope}
import 'src/structure_visitor.puck' as {structureVisitor}
import 'src/types.puck' as {
  getType
  isAssignable
  isSameType
}
import '../entities.puck' as {
  Binding
  Implementation
  Trait
  Type
  TypeInstance
  TypeKind
}

fn implementTrait(traitType: Type, trait_: Trait, type_: Type, implementable: {implementations: List<Implementation>}, i: ImplDeclaration, reportError) {
  let traitName = traitType.displayName()

  if implementable.implementations.any(|imp| imp.trait_ == traitType)
    then reportError(i, '$traitName has already been implemented for ' + type_.displayName())

  let functions = ObjectMap.fromList(
    i.members.map(|functionDeclaration| {
      (functionDeclaration.type_.name.unwrap(), functionDeclaration.type_)
    })
  )

  let traitFunctions = trait_.functions

  traitFunctions.keys().forEach(|name| {
    let traitFunctionType: Type = traitFunctions[name]
    let traitFunction = traitFunctionType.getFunction()
    if traitFunction.isAbstract and not functions[name]
      then reportError(i, 'Function $traitName::$name is not implemented for ' + type_.displayName())
  })

  i.members.forEach(|functionDeclaration| {
    let functionName = functionDeclaration.type_.displayName()
    let function = functionDeclaration.type_.getFunction()
    let traitFunctionType: Type = traitFunctions[functionDeclaration.type_.name.unwrap()]
    if not traitFunctionType
      then reportError(i, 'Function $functionName is not defined by $traitName')
    let traitFunctionName = traitFunctionType.displayName()
    let traitFunction = traitFunctionType.getFunction()

    if let Option::Some(implSelf) = function.selfBinding {
      if let Option::Some(traitSelf) = traitFunction.selfBinding {
        if implSelf.mutable and not traitSelf.mutable
          then reportError(functionDeclaration, 'Function $traitName::$traitFunctionName requires an immutable self parameter')
      }
      else reportError(function, 'Function $traitName::$traitFunctionName is static')
    }
    else if let Option::Some(_) = traitFunction.selfBinding
      then reportError(function, 'Function $traitName::$traitFunctionName requires a self parameter')

    if let Result::Err(error) = checkFunctionAssignability(functionName, traitFunction, function)
      then reportError(function, error)
  })

  implementable.implementations.push({
    type_: type_
    trait_: traitType
  })
}

fn implementShorthand(type_: Type, implementable: {implementations: List<Implementation>}, i: ImplShorthandDeclaration, reportError) {
  let typeName = type_.displayName()

  if implementable.implementations.any(|imp| imp.trait_.getTrait().isShorthand)
    then reportError(i, '$typeName has already been implemented')

  let functions = ObjectMap.fromList(
    i.members.map(|functionDeclaration|
      (functionDeclaration.type_.name.unwrap(), functionDeclaration.type_)
    )
  )

  implementable.implementations.push({
    type_: type_
    trait_: {
      displayName: type_.displayName
      name: type_.name
      kind: TypeKind::Trait({
        isShorthand: true
        functions
      })
      class: None
      instance: None
    }
  })
}

export fn ImplVisitor(context, file) {
  let mut importDirective: ImportDirective
  let reportError = context.reportError.bind(context, file)

  Object.assign({}, visit.emptyVisitor, structureVisitor, {
    reportError

    visitImplDeclaration: |mut self, mut i: ImplDeclaration| {
      self.scope = self.scope.createChild()
      i.scope = self.scope
      i.typeParameters.forEach(self.visitTypeParameter.bind(self))
      self.visitTypeBound(i.trait_)
      self.visitTypeBound(i.type_)

      let traitType: Type = i.trait_.type_
      let structType: Type = i.type_.type_
      self.scope.setSelfBinding(structType.name.unwrap())
      i.members.forEach(|m| self.visitMethodDeclaration(m))

      if let TypeKind::Trait(trait_) = traitType.kind {
        match structType.kind {
          TypeKind::Enum(enum_) => implementTrait(traitType, trait_, structType, enum_, i, reportError)
          TypeKind::Struct(struct) => implementTrait(traitType, trait_, structType, struct, i, reportError)
          _ => reportError(i.type_, structType.displayName() + ' is not a struct or an enum')
        }
      }
      else reportError(i.trait_, traitType.displayName() + ' is not a trait')

      self.scope = self.scope.parent
    }
    visitImplShorthandDeclaration: |mut self, mut i: ImplShorthandDeclaration| {
      self.scope = self.scope.createChild()
      i.scope = self.scope
      i.typeParameters.forEach(self.visitTypeParameter.bind(self))
      self.visitTypeBound(i.type_)

      let structType: Type = i.type_.type_
      self.scope.setSelfBinding(structType.name.unwrap())
      i.members.forEach(|m| self.visitMethodDeclaration(m))

      match structType.kind {
        TypeKind::Enum(enum_) => implementShorthand(structType, enum_, i, reportError)
        TypeKind::Struct(struct) => implementShorthand(structType, struct, i, reportError)
        _ => reportError(i.type_, structType.displayName() + ' is not a struct or an enum')
      }

      self.scope = self.scope.parent
    }
    visitModule: |mut self, mut m: Module| {
      self.scope = m.scope
      m.expressions
        .filter(|e|
          e.kind == SyntaxKind.ImportDirective or
          e.kind == SyntaxKind.ImplDeclaration or
          e.kind == SyntaxKind.ImplShorthandDeclaration
        )
        .forEach(self.visitExpression.bind(self))
    }
    visitObjectDestructure: |self, mut i: ObjectDestructure| {
      i.members.forEach(|m| {
        if importDirective.module {
          let e = importDirective.module.exports[m.local.name]
          if e.expression.kind == SyntaxKind.TraitDeclaration
            {
              // Get the from the imported module again as it may have been missing during the
              // TypeVisitor pass depending on file order
              let mut binding = self.scope.getTypeBinding(m.local.name)
              binding.type_ = e.expression.type_
              let mut binding = self.scope.getBinding(m.local.name)
              binding.type_ = e.expression.type_
            }
          if e.expression.kind == SyntaxKind.TypeDeclaration
            {
              // Get the from the imported module again as it may have been missing during the
              // TypeVisitor pass depending on file order
              let mut binding = self.scope.getTypeBinding(m.local.name)
              binding.type_ = e.expression.type_
            }
        }
      })
    }

    visitImportDirective: |self, mut i: ImportDirective| {
      if i.specifier.kind == SyntaxKind.ObjectDestructure {
        importDirective = i
        visit.walkImportDirective(self, i)
      }
    }
  })
}

