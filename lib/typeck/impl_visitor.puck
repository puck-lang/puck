import 'puck:js' as {Object, undefined}
import '../ast/ast.puck' as {
  Module
  TopLevelStatement
  Expression

  ImplDeclaration
  ImplShorthandDeclaration
  TraitDeclaration
  TypeDeclaration

  ImportDirective
  ImportSpecifier
  ObjectDestructure
  ExportDirective
  ExportedStatement

  TypeBound
  NamedTypeBound
}
import '../ast/span.puck' as {ToSpan}
import '../ast/visit.puck' as visit
import '../compiler/ast.ts' as {SyntaxKind}
import 'src/functions.puck' as {checkFunctionAssignability}
import 'src/range.puck' as {checkRange}
import 'src/scope.puck' as {Binding, Scope}
import 'src/structure_visitor.puck' as {structureVisitor}
import 'src/types.puck' as {
  isAssignable
  isSameType
}
import '../entities.puck' as {
  Implementation
  Trait
  Type
  TypeInstance
  TypeKind
}

fn implementTrait(traitType: Type, trait_: Trait, type_: Type, mut implementable: {implementations: List<Implementation>}, mut i: ImplDeclaration, reportError: (ToSpan, String) -> (), id: String) {
  let traitName = traitType.displayName()

  if implementable.implementations.any(|imp| imp.trait_ == traitType)
    then reportError(i, '$traitName has already been implemented for ' + type_.displayName())

  let functions = ObjectMap.fromIter(
    i.members.map(|functionDeclaration| {
      (functionDeclaration.type_.name.unwrap(), functionDeclaration.type_)
    })
  )

  let traitFunctions = trait_.functions

  traitFunctions.forEach(|(name, traitFunctionType)| {
    let traitFunction = traitFunctionType.getFunction()
    if traitFunction.isAbstract and not functions.has(name)
      then reportError(i, 'Function $traitName::$name is not implemented for ' + type_.displayName())
  })

  i.members.forEach(|functionDeclaration| {
    let functionName = functionDeclaration.type_.displayName()
    let function = functionDeclaration.type_.getFunction()
    if let Some(traitFunctionType) = traitFunctions.get(functionDeclaration.type_.name.unwrap()) {
      let traitFunctionName = traitFunctionType.displayName()
      let traitFunction = traitFunctionType.getFunction()

      match (function.selfBinding, traitFunction.selfBinding) {
        (Some(implSelf), Some(traitSelf)) => {
          if implSelf.mutable and not traitSelf.mutable
            then reportError(functionDeclaration, 'Function $traitName::$traitFunctionName requires an immutable self parameter')
        }
        (Option::None, Some(_)) => {
          reportError(functionDeclaration, 'Function $traitName::$traitFunctionName requires a self parameter')
        }
        (_, Option::None) => {
          reportError(functionDeclaration, 'Static trait functions can not be implemented')
        }
      }
    }
    else reportError(i, 'Function $functionName is not defined by $traitName')
  })

  let implementation = Implementation({
    id
    type_: type_
    trait_: traitType
    typeParameters: i.typeParameters.map(|p| p->type_.transmute()).toList()
  })

  i->implementation = implementation
  implementable.implementations.push(implementation)

  i.members.forEach(|mut functionDeclaration| {
    let functionName = functionDeclaration.type_.displayName()
    if let Some(traitFunctionType) = traitFunctions.get(functionDeclaration.type_.name.unwrap()) {
      let traitFunction = traitFunctionType.getFunction()
      let function = functionDeclaration.type_.getFunction()
      functionDeclaration->traitFunctionType = traitFunctionType

      if let Result::Err(error) = checkFunctionAssignability(functionName, traitFunction, function)
        then reportError(functionDeclaration, error)
    }
  })
}

fn implementShorthand(type_: Type, mut implementable: {implementations: List<Implementation>}, i: ImplShorthandDeclaration, reportError: (ToSpan, String) -> ()) {
  let typeName = type_.displayName()

  if implementable.implementations.any(|imp| imp.trait_.getTrait().isShorthand)
    then reportError(i, '$typeName has already been implemented')

  let functions = ObjectMap.fromIter(
    i.members.map(|functionDeclaration|
      (functionDeclaration.type_.name.unwrap(), functionDeclaration.type_)
    )
  )

  implementable.implementations.push({
    type_: type_
    trait_: {
      id: type_.id
      displayName: type_.displayName
      name: type_.name
      kind: TypeKind::Trait({
        isShorthand: true
        functions
      })
      class: None
      instance: None
      providesType: None
      enumMember: None
    }
    typeParameters: i.typeParameters.map(|p| p->type_.transmute()).toList()
  })
}

export fn ImplVisitor(mut context, file) {
  let mut importDirective: ImportDirective
  let reportError: (ToSpan, String) -> () = context.reportError.bind(context, file)

  fn getImplId(type_: Type, trait_: Type) {
    let mut id = '\$impl_' + type_.id.unwrap() + '\$' + trait_.id.unwrap()
    if context.impls->[id] {
      id = '$id\$' + context.impls->[id]
      context.impls->[id] += 1
    }
    else {
      context.impls->[id] = 1
    }
    id
  }

  Object->assign({}, visit.emptyVisitor, structureVisitor(reportError, 'ImplVisitor'), {
    visitModule: |mut self, mut m: Module| {
      self.scope = m->scope
      m.statements
        .filter(|e| match e {
          TopLevelStatement::ImplDeclaration(_) => true
          TopLevelStatement::ImplShorthandDeclaration(_) => true
          _ => false
        })
        .forEach(|s| self.visitTopLevelStatement(s))
    }

    visitImplDeclaration: |mut self, mut i: ImplDeclaration| {
      let parentScope: Scope = self.scope
      let mut scope = parentScope.createChild()
      self.scope = scope
      i.typeParameters.forEach(self.visitTypeParameter.bind(self))
      self.visitNamedTypeBound(i.trait_)
      self.visitNamedTypeBound(i.type_)

      let traitType = i.trait_.getType()
      let mut structType = i.type_.getType()
      scope.setSelfType(structType)
      i.members.forEach(|m| self.visitMethodDeclaration(m, structType))
      let id = getImplId(traitType, structType)

      if let TypeKind::Trait(trait_) = traitType.kind {
        match structType.kind {
          TypeKind::Enum(enum_) => {
            let mut e = enum_
            implementTrait(traitType, trait_, structType, e, i, reportError, id)
          }
          TypeKind::Struct(struct) => {
            let mut s = struct
            implementTrait(traitType, trait_, structType, s, i, reportError, id)
          }
          _ => reportError(i.type_, structType.displayName() + ' is not a struct or an enum')
        }
      }
      else reportError(i.trait_, traitType.displayName() + ' is not a trait')

      self.scope = parentScope
    }
    visitImplShorthandDeclaration: |mut self, mut i: ImplShorthandDeclaration| {
      let parentScope: Scope = self.scope
      let mut scope = parentScope.createChild()
      self.scope = scope
      i.typeParameters.forEach(self.visitTypeParameter.bind(self))
      self.visitNamedTypeBound(i.type_)

      let mut structType = i.type_.getType()
      scope.setSelfType(structType)
      i.members.forEach(|m| self.visitMethodDeclaration(m, structType))

      match structType.kind {
        TypeKind::Enum(enum_) => {
          let mut e = enum_
          implementShorthand(structType, e, i, reportError)
        }
        TypeKind::Struct(struct) => {
          let mut s = struct
          implementShorthand(structType, s, i, reportError)
        }
        _ => reportError(i.type_, structType.displayName() + ' is not a struct or an enum')
      }

      self.scope = parentScope
    }
  })
}

