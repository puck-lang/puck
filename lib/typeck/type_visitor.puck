import 'puck:js' as {Object, undefined}
import 'node:path' as {relative}
import '../ast/ast.puck' as {
  Module
  TopLevelStatement
  Attribute
  AttributeData
  SimpleLiteral

  EnumDeclaration
  EnumMember
  TraitDeclaration
  TypeDeclaration

  ExportDirective
  ExportedStatement
  ImportDirective
  ImportSpecifier
  ObjectDestructure

  Block

  Identifier
  FunctionDeclaration
  VariableDeclaration

  TypeBound
  FunctionTypeBound
  NamedTypeBound
  TypeParameter
  TypePath
}
import '../ast/span.puck' as {ToSpan}
import '../ast/visit.puck' as visit
import '../entities.puck' as {File, StructKind, Type, TypeClass, TypeKind}
import 'src/scope.puck' as {Binding, Scope}
import 'src/structure_visitor.puck' as {structureVisitor}

fn isTypeScope(e: ExportDirective) {
  match e.statement {
    ExportedStatement::EnumDeclaration(_) => true
    ExportedStatement::TraitDeclaration(_) => true
    ExportedStatement::TypeDeclaration(_) => true
    _ => false
  }
}

fn generateTypeId(context, file: File, name: String) {
  let path = relative(context.projectPath, file.absolutePath)
  Some(path + ':$name')
}

fn getTypeId(declaration: {attributes: List<Attribute>, name: Identifier}, context, file: File) {
  let reportError: (ToSpan, String) -> () = context.reportError.bind(context, file)

  if let Some(attribute) = declaration.attributes.find(|a| a.name.name == 'type_id')
      then match attribute.data {
      AttributeData::Value(literal) => match literal {
        SimpleLiteral::StringLiteral({value}) => Some(value)
        _ => {
          reportError(attribute, 'type_id must be a string')
          generateTypeId(context, file, declaration.name.name)
        }
      }
      _ => {
        reportError(attribute, 'type_id must have a value')
        generateTypeId(context, file, declaration.name.name)
      }
    }
    else generateTypeId(context, file, declaration.name.name)
}

/// Visits and declares Enums, Traits and Types
///
/// Enum, traits and types are declared in this separate step so that we are sure
/// that complete type information is known during the impl and checking steps.
///
/// The declarations are visited in three passes, first will all type names be
/// defined. Then will all type parameters be defined and after that is finally the
/// bodies visited and properties or functions are defined.
/// This assures that the hoisting rules is followed and all required information is known.
export fn TypeVisitor(context, file) {
  let reportError: (ToSpan, String) -> () = context.reportError.bind(context, file)
  let mut imports: ObjectMap<File> = ObjectMap.new()

  let structureVisitorInstance = structureVisitor(reportError, 'TypeVisitor')
  Object->assign({}, visit.emptyVisitor, structureVisitorInstance, {
    scope: Scope.new(context)

    visitModule: |mut self, mut m: Module| {
      m->scope = self.scope
      let mut imports = []
      let mut declarations = []

      m.statements.forEach(|s: TopLevelStatement|
        match s {
          TopLevelStatement::EnumDeclaration(_) => declarations.push(s)
          TopLevelStatement::ImportDirective(i) => imports.push(i)
          TopLevelStatement::TraitDeclaration(_) => declarations.push(s)
          TopLevelStatement::TypeDeclaration(_) => declarations.push(s)
          TopLevelStatement::ExportDirective(e) => match e.statement {
            ExportedStatement::EnumDeclaration(_) => declarations.push(s)
            ExportedStatement::TraitDeclaration(_) => declarations.push(s)
            ExportedStatement::TypeDeclaration(_) => declarations.push(s)
            _ => {}
          }
          _ => {}
        }
      )

      declarations.forEach(|mut e| self.visitTopLevelStatement(e))
      imports.forEach(|mut i| self.visitImportDirective(i))
      declarations.forEach(|mut e| self.visitTopLevelStatement(e))
      declarations.forEach(|mut e| self.visitTopLevelStatement(e))
    }

    visitEnumDeclaration: |mut self, mut t: EnumDeclaration| {
      let mut parentScope: Scope = self.scope
      let mut type_: Type = t->type_.transmute()
      if not t->type_ {
        t->type_ = Type.provides({
          id: generateTypeId(context, file, t.name.name)
          displayName: None
          name: Some(t.name.name)
          kind: TypeKind::Enum({
            implementations: []
            members: ObjectMap.new()
          })
          class: TypeClass.fromAstNode(t, reportError)
          instance: None
          providesType: None
          enumMember: None
        })
        let token: ToSpan = t
        if let Result::Err(error) = parentScope.define({
          name: t.name.name
          token
          mutable: false
          allowRedeclare: false
          type_: t->type_.transmute()
          previous: None
          completeType: None
        })
          then reportError(t.name, error)
      }
      else if not t->scope {
        let mut scope = parentScope.createChild()
        t->scope = scope
        self.scope = scope
        if let Option::Some(class) = type_.providesType.unwrap().class {
          let mut c = class
          t.typeParameters.forEach(|p| {
            self.visitTypeParameter(p)
            c.typeParameters.push(p->type_.transmute())
          })
        }
        scope.setSelfType(type_.providesType.unwrap())
        self.scope = parentScope
      }
      else {
        self.scope = t->scope
        t.members.forEach(|m| self.visitEnumMember(m))

        let memberMap = ObjectMap.fromIter(
          t.members.map(|p: EnumMember| (
            p.name.name
            p.bound.mapOr(
              Type({
                id: generateTypeId(context, file, t.name.name + '::' + p.name.name)
                displayName: None
                name: Some(t.name.name + '::' + p.name.name)
                kind: TypeKind::Struct({
                  implementations: []
                  kind: StructKind::Unit
                })
                class: None
                instance: None
                providesType: None
                enumMember: Some((p.name.name, type_.providesType.unwrap()))
              })
              |bound| Type({
                id: generateTypeId(context, file, t.name.name + '::' + p.name.name)
                displayName: None
                name: None
                kind: bound.getType().kind
                class: None
                instance: None
                providesType: None
                enumMember: Some((p.name.name, type_.providesType.unwrap()))
              })
            )
          ))
        )

        if t.members.size() != memberMap.size() {
          let mut members = ObjectMap.new()
          t.members.forEach(|p| {
            if members.has(p.name.name) then reportError(p, 'Duplicate member ' + p.name.name)
            members[p.name.name] = p
          })
        }

        if let TypeKind::Enum(enum_) = type_.providesType.unwrap().kind {
          Object->assign(enum_.members, memberMap)
        }
        else throw 'is not an enum'

        self.scope = parentScope
      }
      ()
    }
    visitTraitDeclaration: |mut self, mut t: TraitDeclaration| {
      let mut parentScope: Scope = self.scope
      let type_: Type = t->type_.transmute()
      if not t->type_ {
        t->type_ = Type.provides({
          id: getTypeId(t, context, file)
          displayName: None
          name: Some(t.name.name)
          kind: TypeKind::Trait({
            isShorthand: false
            functions: ObjectMap.new()
          })
          class: TypeClass.fromAstNode(t, reportError)
          instance: None
          providesType: None
          enumMember: None
        })
        let token: ToSpan = t
        if let Result::Err(error) = parentScope.define({
          name: t.name.name
          token
          mutable: false
          allowRedeclare: false
          type_: t->type_.transmute()
          previous: None
          completeType: None
        })
          then reportError(t.name, error)
      }
      else if not t->scope {
        let mut scope = parentScope.createChild()
        t->scope = scope
        self.scope = scope
        if let Option::Some(class) = type_.providesType.unwrap().class {
          let mut c = class
          t.typeParameters.forEach(|p| {
            self.visitTypeParameter(p)
            c.typeParameters.push(p->type_.transmute())
          })
        }
        scope.setSelfType(type_.providesType.unwrap())
        self.scope = parentScope
      }
      else {
        self.scope = t->scope
        t.members.forEach(|m| self.visitMethodDeclaration(m, type_.providesType.unwrap()))

        if let TypeKind::Trait(trait_) = type_.providesType.unwrap().kind {
          Object->assign(trait_.functions, ObjectMap.fromIter(
            t.members.map(|m| {
              if let TypeKind::Function(function) = m.type_.kind {
                if function.isAbstract and function.selfBinding.isNone() {
                  reportError(m, 'Static trait functions can not be abstract')
                }
              }
              (m.name.unwrap().name, m.type_)
            })
          ))

          if let Option::Some(class) = type_.providesType.unwrap().class {
            class.instances.forEach(|mut instance| {
              if let TypeKind::Trait(instanceTrait) = instance.kind {
                Object->assign(instanceTrait, {
                  functions: trait_.functions
                })
              }
              else throw 'instance is not a trait'
            })
          }
        }
        else throw 'is not a trait'

        self.scope = parentScope
      }
      ()
    }
    visitTypeDeclaration: |mut self, mut t: TypeDeclaration| {
      let mut parentScope: Scope = self.scope
      let type_: Type = t->type_.transmute()
      if not t->type_ {
        let structKind =
          if let Option::Some(typeBound) = t.bound {
            match typeBound {
              TypeBound::RecordTypeBound(record) => StructKind::Record({properties: ObjectMap.new()})
              TypeBound::TupleTypeBound(tuple) => StructKind::Tuple({properties: []})
              _ => throw 'Unreachable'
            }
          }
          else StructKind::Unit

        t->type_ = Type.provides({
          id: getTypeId(t, context, file)
          displayName: None
          name: Some(t.name.name)
          kind: TypeKind::Struct({
            implementations: []
            kind: structKind
          })
          class: TypeClass.fromAstNode(t, reportError)
          instance: None
          providesType: None
          enumMember: None
        })
        let token: ToSpan = t
        if let Result::Err(error) = parentScope.define({
          name: t.name.name
          token
          mutable: false
          allowRedeclare: false
          type_: t->type_.transmute()
          previous: None
          completeType: None
        })
          then reportError(t.name, error)
      }
      else if not t->scope {
        let mut scope = parentScope.createChild()
        t->scope = scope
        self.scope = scope
        if let Option::Some(class) = type_.providesType.unwrap().class {
          let mut c = class
          t.typeParameters.forEach(|p| {
            self.visitTypeParameter(p)
            c.typeParameters.push(p->type_.transmute())
          })
        }
        scope.setSelfType(type_.providesType.unwrap())
        self.scope = parentScope
      }
      else {
        self.scope = t->scope
        if let Option::Some(typeBound) = t.bound {
          self.visitTypeBound(typeBound)

          match type_.providesType.unwrap().kind {
            TypeKind::Struct({kind: StructKind::Record({properties})}) => {
              Object->assign(properties, ObjectMap.fromIter(
                typeBound.getRecordTypeBound().properties.map(|p| {
                  (p.name.name, p.typeBound.getType())
                })
              ))
            }
            TypeKind::Struct({kind: StructKind::Tuple(tuple)}) => {
              Object->assign(tuple, {
                properties: typeBound.getTupleTypeBound().properties.map(|p| p.getType()).toList()
              })
            }
            _ => {}
          }
        }

        self.scope = parentScope
      }
      ()
    }

    visitExportDirective: |self, mut e: ExportDirective| {
      visit.walkExportDirective(self, e)
    }
    visitImportDirective: |mut self, mut importDirective: ImportDirective| {
      let mut scope: Scope = self.scope
      if let Option::Some(module) = importDirective.module {
        if not module->scope {
          context.runTypeVisitorOnFile(module.file)
        }
      }

      match importDirective.specifier {
        ImportSpecifier::Identifier(identifier) => {
          let token: ToSpan = identifier
          let typeProperties: ObjectMap<Type> =
            if let Option::Some(module) = importDirective.module {
              module.exports.map(|exportDirective| exportDirective.getType())
            }
            else ObjectMap.new()
          let mut type_ = Type({
            id: None
            displayName: Some(identifier.name)
            name: None
            kind: TypeKind::Struct({
              implementations: []
              kind: StructKind::Record({
                properties: typeProperties
              })
            })
            instance: None
            class: None
            providesType: None
            enumMember: None
          })
          if let Result::Err(error) = scope.define({
            name: identifier.name
            token
            mutable: false
            allowRedeclare: false
            type_
            previous: None
            completeType: importDirective.module.map(|module| |visitor: String| {
              if visitor == 'TypeVisitor' then return None
              if visitor == 'ImplVisitor' {
                context.runTypeVisitorOnFile(module.file)
              } else {
                context.runCheckerOnFile(module.file)
              }
              let moduleScope: Scope = module->scope.transmute()
              let mut typeProperties = module.exports.map(|exportDirective| exportDirective.getType())
              match type_.kind {
                TypeKind::Struct({kind: StructKind::Record(record)}) => {
                  let mut r = record
                  r.properties = typeProperties
                }
                _ => throw 'Unreachable'
              }
              Some(type_)
            })
          })
            then reportError(identifier, error)
        }
        ImportSpecifier::ObjectDestructure(d) => {
          d.members.forEach(|mut m| {
            let token: ToSpan = m
            if let Option::Some(module) = importDirective.module {
              let moduleScope: Scope = module->scope.transmute()
              let importedBinding = moduleScope.getBinding(m.property.name, 'TypeVisitor').unwrapOr(Object->assign({}).transmute())
              if let Result::Err(error) = scope.define({
                name: m.local.name
                token
                mutable: false
                allowRedeclare: false
                type_: importedBinding.type_
                previous: None
                completeType: Some(|visitor| {
                  if visitor == 'TypeVisitor' then return None
                  if visitor == 'ImplVisitor' {
                    context.runTypeVisitorOnFile(module.file)
                  } else {
                    context.runCheckerOnFile(module.file)
                  }
                  let externalBinding = moduleScope.getBinding(m.property.name, visitor)
                  externalBinding.map(|binding| binding.type_)
                })
              })
                then reportError(m.local, error)
              m.local->type_ = importedBinding.type_
              imports[m.local.name] = importDirective->file
              ()
            }
            else {
              if let Result::Err(error) = scope.define({
                name: m.local.name
                token
                mutable: false
                allowRedeclare: false
                type_: undefined
                providesType: None
                previous: None
                completeType: None
              })
                then reportError(m.local, error)
            }
          })
        }
        ImportSpecifier::Asterisk(_) => {}
      }
    }

    visitTypeBound: |self, mut t: TypeBound| {
      visit.walkTypeBound(self, t)
    }
    visitNamedTypeBound: |self, mut t: NamedTypeBound| {
      let scope: Scope = self.scope
      let result = scope.getTypePath(t.path, 'TypeVisitor')

      match result {
        Ok(binding) => {}
        Err(err) => reportError(t, err)
      }

      structureVisitorInstance.visitNamedTypeBound->call(self, t)
    }
    visitTypeProperty: visit.walkingVisitor->visitTypeProperty
  })
}
