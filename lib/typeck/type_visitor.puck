import 'puck:js' as {Object, undefined}
import '../ast/ast.puck' as {
  Module
  TopLevelStatement

  EnumDeclaration
  EnumMember
  TraitDeclaration
  TypeDeclaration

  ExportDirective
  ExportedStatement
  ImportDirective
  ImportSpecifier
  ObjectDestructure

  Block

  Identifier
  FunctionDeclaration
  VariableDeclaration

  TypeBound
  FunctionTypeBound
  NamedTypeBound
  TypeParameter
  TypePath
}
import '../ast/span.puck' as {ToSpan}
import '../ast/visit.puck' as visit
import '../entities.puck' as {StructKind, Type, TypeBinding, TypeClass, TypeKind}
import 'src/scope.puck' as {createScope}
import 'src/structure_visitor.puck' as {structureVisitor}

fn isTypeScope(e: ExportDirective) {
  match e.statement {
    ExportedStatement::EnumDeclaration(_) => true
    ExportedStatement::TraitDeclaration(_) => true
    ExportedStatement::TypeDeclaration(_) => true
    _ => false
  }
}

/// Visits and declares Enums, Traits and Types
///
/// Enum, traits and types are declared in this separate step so that we are sure
/// that complete type information is known during the impl and checking steps.
///
/// The declarations are visited in three passes, first will all type names be
/// defined. Then will all type parameters be defined and after that is finally the
/// bodies visited and properties or functions are defined.
/// This assures that the hoisting rules is followed and all required information is known.
export fn TypeVisitor(context, file) {
  let reportError: (ToSpan, String) -> {} = context.reportError.bind(context, file)

  let structureVisitorInstance = structureVisitor(reportError)
  Object.assign({}, visit.emptyVisitor, structureVisitorInstance, {
    scope: createScope(context, file)
    reportError
    imports: {}

    visitModule: |mut self, mut m: Module| {
      self.scope = m.scope
      self.scope.clearBindings()
      let mut imports = []
      let mut declarations = []

      m.statements.forEach(|s: TopLevelStatement|
        match s {
          TopLevelStatement::EnumDeclaration(_) => declarations.add(s)
          TopLevelStatement::ImportDirective(i) => imports.add(i)
          TopLevelStatement::TraitDeclaration(_) => declarations.add(s)
          TopLevelStatement::TypeDeclaration(_) => declarations.add(s)
          TopLevelStatement::ExportDirective(e) => match e.statement {
            ExportedStatement::EnumDeclaration(_) => declarations.add(s)
            ExportedStatement::TraitDeclaration(_) => declarations.add(s)
            ExportedStatement::TypeDeclaration(_) => declarations.add(s)
            _ => {}
          }
          _ => {}
        }
      )

      imports.forEach(|mut i| self.visitImportDirective(i))
      declarations.forEach(|mut e| self.visitTopLevelStatement(e))
      declarations.forEach(|mut e| self.visitTopLevelStatement(e))
      declarations.forEach(|mut e| self.visitTopLevelStatement(e))
    }

    visitEnumDeclaration: |mut self, mut t: EnumDeclaration| {
      if not t.type_ {
        t.type_ = {
          displayName: None
          name: Some(t.name.name)
          kind: TypeKind::Enum({
            implementations: []
            members: ObjectMap.new()
          })
          class: TypeClass.fromAstNode(t, reportError)
          instance: None
        }
        let token: ToSpan = t
        self.scope.defineType(t.type_, token, true)
        self.scope.define({name: t.name.name, mutable: false, token, type_: t.type_})
      }
      else if not t.scope {
        t.scope = self.scope.createChild()
        self.scope = t.scope
        if let Option::Some(class) = t.type_.class {
          t.typeParameters.forEach(|p| {
            self.visitTypeParameter(p)
            class.typeParameters.push(p.type_)
          })
        }
        t.scope.setSelfBinding(t.name.name)
        self.scope = self.scope.parent
      }
      else {
        self.scope = t.scope
        t.members.forEach(|m| self.visitEnumMember(m))

        let memberMap = ObjectMap.fromIter(
          t.members.map(|p: EnumMember| (
            p.name.name
            p.bound.mapOrElse(
              || {{
                displayName: None
                name: Some(p.name.name)
                kind: TypeKind::Struct({
                  implementations: []
                  kind: StructKind::Unit
                })
                class: None
                instance: None
              }}
              |bound| bound.getType()
            )
          ))
        )

        if t.members.size() != memberMap.size() {
          let mut members = ObjectMap.new()
          t.members.forEach(|p| {
            if members[p.name.name] then reportError(p, 'Duplicate member ' + p.name.name)
            members[p.name.name] = p
          })
        }

        if let TypeKind::Enum(enum_) = t.type_.kind {
          Object.assign(enum_.members, memberMap)
        }
        else throw 'is not an enum'

        self.scope = self.scope.parent
      }
    }
    visitTraitDeclaration: |mut self, mut t: TraitDeclaration| {
      if not t.type_ {
        t.type_ = {
          displayName: None
          name: Some(t.name.name)
          kind: TypeKind::Trait({
            isShorthand: false
            functions: ObjectMap.new()
          })
          class: TypeClass.fromAstNode(t, reportError)
          instance: None
        }
        let token: ToSpan = t
        self.scope.defineType(t.type_, token, true)
        t.binding = self.scope.define({
          name: t.name.name
          mutable: false
          token
          type_: t.type_
        })
      }
      else if not t.scope {
        self.scope = self.scope.createChild()
        t.scope = self.scope
        if let Option::Some(class) = t.type_.class {
          t.typeParameters.forEach(|p| {
            self.visitTypeParameter(p)
            class.typeParameters.push(p.type_)
          })
        }
        t.scope.setSelfBinding(t.name.name)
        self.scope = self.scope.parent
      }
      else {
        self.scope = t.scope
        t.members.forEach(|m| self.visitMethodDeclaration(m, t.type_))

        if let TypeKind::Trait(trait_) = t.type_.kind {
          Object.assign(trait_.functions, ObjectMap.fromIter(
            t.members.map(|m| (m.name.value[0].name, m.type_))
          ))

          if let Option::Some(class) = t.type_.class {
            class.instances.forEach(|mut instance| {
              if let TypeKind::Trait(instanceTrait) = instance.kind {
                Object.assign(instanceTrait, {
                  functions: trait_.functions
                })
              }
              else throw 'instance is not a trait'
            })
          }
        }
        else throw 'is not a trait'

        self.scope = self.scope.parent
      }
    }
    visitTypeDeclaration: |mut self, mut t: TypeDeclaration| {
      if not t.type_ {
        let structKind =
          if let Option::Some(typeBound) = t.bound {
            match typeBound {
              TypeBound::RecordTypeBound(record) => StructKind::Record({properties: ObjectMap.new()})
              TypeBound::TupleTypeBound(tuple) => StructKind::Tuple({properties: []})
              _ => throw 'Unreachable'
            }
          }
          else StructKind::Unit

        t.type_ = {
          displayName: None
          name: Some(t.name.name)
          kind: TypeKind::Struct({
            implementations: []
            kind: structKind
          })
          class: TypeClass.fromAstNode(t, reportError)
          instance: None
        }
        let token: ToSpan = t
        self.scope.defineType(t.type_, token, true)
        t.binding = self.scope.define({
          name: t.name.name
          mutable: false
          token
          type_: t.type_
        })
      }
      else if not t.scope {
        t.scope = self.scope.createChild()
        self.scope = t.scope
        if let Option::Some(class) = t.type_.class {
          t.typeParameters.forEach(|p| {
            self.visitTypeParameter(p)
            class.typeParameters.push(p.type_)
          })
        }
        t.scope.setSelfBinding(t.name.name)
        self.scope = self.scope.parent
      }
      else {
        self.scope = t.scope
        if let Option::Some(typeBound) = t.bound {
          self.visitTypeBound(typeBound)

          match t.type_.kind {
            TypeKind::Struct({kind: StructKind::Record({properties})}) => {
              Object.assign(properties, ObjectMap.fromIter(
                typeBound.getRecordTypeBound().properties.map(|p| {
                  // print('(p.name.name, p.typeBound.type_)', (p.name.name, p.typeBound, p.typeBound.getType()))
                  (p.name.name, p.typeBound.getType())
                })
              ))
            }
            TypeKind::Struct({kind: StructKind::Tuple(tuple)}) => {
              Object.assign(tuple, {
                properties: typeBound.getTupleTypeBound().properties.map(|p| p.getType()).toList()
              })
            }
            _ => {}
          }
        }

        self.scope = self.scope.parent
      }
    }

    visitExportDirective: |self, mut e: ExportDirective| {
      e.scope = self.scope
      visit.walkExportDirective(self, e)
    }
    visitImportDirective: |mut self, mut importDirective: ImportDirective| {
      importDirective.scope = self.scope
      match importDirective.specifier {
        ImportSpecifier::Identifier(identifier) => {
          let token: ToSpan = identifier
          self.scope.define({name: identifier.name, mutable: false, token})
        }
        ImportSpecifier::ObjectDestructure(d) => {
          d.members.forEach(|m| {
            let token: ToSpan = m
            if importDirective.module {
              let e = importDirective.module.exports[m.local.name]
              if not e then return undefined
              if isTypeScope(e) {
                let typeBinding = importDirective.module.scope.getTypeBinding(m.property.name)
                self.scope.setTypeBinding(typeBinding)
                self.scope.define({name: m.local.name, mutable: false, token, type_: typeBinding.type_})
                self.imports[m.local.name] = importDirective.file
              }
              else {
                let binding = importDirective.module.scope.getBinding(m.property.name)
                self.scope.define({
                  name: m.local.name
                  mutable: false
                  token
                  inherit: binding
                  importedFrom: importDirective
                })
              }
            }
            else self.scope.define({name: m.local.name, mutable: false, token})
          })
        }
        ImportSpecifier::Asterisk(_) => {}
      }
    }

    visitTypeBound: |self, mut t: TypeBound| {
      visit.walkTypeBound(self, t)
    }
    visitNamedTypeBound: |self, mut t: NamedTypeBound| {
      let result: Result<TypeBinding, String> = self.scope.getTypePath(t.path)

      match result {
        Result::Ok(binding) => {
          if not binding.token.scope {
            let name =
              match t.path {
                TypePath::Member({name}) => name
                TypePath::Object({name}, _) => name
              }

            if self.imports[name]
              then context.runTypeVisitorOnFile(self.imports[name])
              else reportError(t, 'Scope not set for binding $name but not found in imports either')
          }
        }
        Result::Err(err) => reportError(t, err)
      }

      structureVisitorInstance.visitNamedTypeBound.call(self, t)
    }
    visitTypeProperty: visit.walkingVisitor.visitTypeProperty
  })
}
