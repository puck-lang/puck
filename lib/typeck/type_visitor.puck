import 'puck:js' as {Object, undefined}
import 'node:path' as {relative}
import '../ast/ast.puck' as {
  Module
  TopLevelStatement

  EnumDeclaration
  EnumMember
  TraitDeclaration
  TypeDeclaration

  ExportDirective
  ExportedStatement
  ImportDirective
  ImportSpecifier
  ObjectDestructure

  Block

  Identifier
  FunctionDeclaration
  VariableDeclaration

  TypeBound
  FunctionTypeBound
  NamedTypeBound
  TypeParameter
  TypePath
}
import '../ast/span.puck' as {ToSpan}
import '../ast/visit.puck' as visit
import '../entities.puck' as {File, StructKind, Type, TypeClass, TypeKind}
import 'src/scope.puck' as {Binding, Scope}
import 'src/structure_visitor.puck' as {structureVisitor}

fn isTypeScope(e: ExportDirective) {
  match e.statement {
    ExportedStatement::EnumDeclaration(_) => true
    ExportedStatement::TraitDeclaration(_) => true
    ExportedStatement::TypeDeclaration(_) => true
    _ => false
  }
}

fn generateTypeId(context, file: File, name: String) {
  let path = relative(context.projectPath, file.absolutePath)
  Some(path + ':$name')
}

/// Visits and declares Enums, Traits and Types
///
/// Enum, traits and types are declared in this separate step so that we are sure
/// that complete type information is known during the impl and checking steps.
///
/// The declarations are visited in three passes, first will all type names be
/// defined. Then will all type parameters be defined and after that is finally the
/// bodies visited and properties or functions are defined.
/// This assures that the hoisting rules is followed and all required information is known.
export fn TypeVisitor(context, file) {
  let reportError: (ToSpan, String) -> {} = context.reportError.bind(context, file)
  let mut imports: ObjectMap<File> = ObjectMap.new()

  let structureVisitorInstance = structureVisitor(reportError, 'TypeVisitor')
  Object.assign({}, visit.emptyVisitor, structureVisitorInstance, {
    scope: Scope.new(context)

    visitModule: |mut self, mut m: Module| {
      m.scope = self.scope
      let mut imports = []
      let mut declarations = []

      m.statements.forEach(|s: TopLevelStatement|
        match s {
          TopLevelStatement::EnumDeclaration(_) => declarations.add(s)
          TopLevelStatement::ImportDirective(i) => imports.add(i)
          TopLevelStatement::TraitDeclaration(_) => declarations.add(s)
          TopLevelStatement::TypeDeclaration(_) => declarations.add(s)
          TopLevelStatement::ExportDirective(e) => match e.statement {
            ExportedStatement::EnumDeclaration(_) => declarations.add(s)
            ExportedStatement::TraitDeclaration(_) => declarations.add(s)
            ExportedStatement::TypeDeclaration(_) => declarations.add(s)
            _ => {}
          }
          _ => {}
        }
      )

      declarations.forEach(|mut e| self.visitTopLevelStatement(e))
      imports.forEach(|mut i| self.visitImportDirective(i))
      declarations.forEach(|mut e| self.visitTopLevelStatement(e))
      declarations.forEach(|mut e| self.visitTopLevelStatement(e))
    }

    visitEnumDeclaration: |mut self, mut t: EnumDeclaration| {
      let mut parentScope: Scope = self.scope
      let type_: Type = t.type_
      if not t.type_ {
        t.type_ = Type.provides({
          id: generateTypeId(context, file, t.name.name)
          displayName: None
          name: Some(t.name.name)
          kind: TypeKind::Enum({
            implementations: []
            members: ObjectMap.new()
          })
          class: TypeClass.fromAstNode(t, reportError)
          instance: None
          providesType: None
          enumMember: None
        })
        let token: ToSpan = t
        if let Result::Err(error) = parentScope.define({
          name: t.name.name
          token
          mutable: false
          allowRedeclare: false
          type_: t.type_
          previous: None
          importedFrom: None
        })
          then reportError(t.name, error)
      }
      else if not t.scope {
        let mut scope = parentScope.createChild()
        t.scope = scope
        self.scope = scope
        if let Option::Some(class) = type_.providesType.unwrap().class {
          t.typeParameters.forEach(|p| {
            self.visitTypeParameter(p)
            class.typeParameters.push(p.type_)
          })
        }
        scope.setSelfType(type_.providesType.unwrap())
        self.scope = parentScope
      }
      else {
        self.scope = t.scope
        t.members.forEach(|m| self.visitEnumMember(m))

        let memberMap = ObjectMap.fromIter(
          t.members.map(|p: EnumMember| (
            p.name.name
            p.bound.mapOr(
              Type({
                id: generateTypeId(context, file, t.name.name + '::' + p.name.name)
                displayName: None
                name: Some(t.name.name + '::' + p.name.name)
                kind: TypeKind::Struct({
                  implementations: []
                  kind: StructKind::Unit
                })
                class: None
                instance: None
                providesType: None
                enumMember: Some((p.name.name, type_.providesType.unwrap()))
              })
              |bound| Type({
                id: generateTypeId(context, file, t.name.name + '::' + p.name.name)
                displayName: None
                name: None
                kind: bound.getType().kind
                class: None
                instance: None
                providesType: None
                enumMember: Some((p.name.name, type_.providesType.unwrap()))
              })
            )
          ))
        )

        if t.members.size() != memberMap.size() {
          let mut members = ObjectMap.new()
          t.members.forEach(|p| {
            if members[p.name.name] then reportError(p, 'Duplicate member ' + p.name.name)
            members[p.name.name] = p
          })
        }

        if let TypeKind::Enum(enum_) = type_.providesType.unwrap().kind {
          Object.assign(enum_.members, memberMap)
        }
        else throw 'is not an enum'

        self.scope = parentScope
        type_.providesType.unwrap().completed = true
      }
      ()
    }
    visitTraitDeclaration: |mut self, mut t: TraitDeclaration| {
      let mut parentScope: Scope = self.scope
      let type_: Type = t.type_
      if not t.type_ {
        let mut type_: Type = {
          id: generateTypeId(context, file, t.name.name)
          displayName: None
          name: Some(t.name.name)
          kind: TypeKind::Trait({
            isShorthand: false
            functions: ObjectMap.new()
          })
          class: TypeClass.fromAstNode(t, reportError)
          instance: None
          providesType: None
          enumMember: None
        }
        t.type_ = Type.provides(type_)
        let token: ToSpan = t
        if let Result::Err(error) = parentScope.define({
          name: t.name.name
          token
          mutable: false
          allowRedeclare: false
          type_: t.type_
          previous: None
          importedFrom: None
        })
          then reportError(t.name, error)
      }
      else if not t.scope {
        let mut scope = parentScope.createChild()
        t.scope = scope
        self.scope = scope
        if let Option::Some(class) = type_.providesType.unwrap().class {
          t.typeParameters.forEach(|p| {
            self.visitTypeParameter(p)
            class.typeParameters.push(p.type_)
          })
        }
        scope.setSelfType(type_.providesType.unwrap())
        self.scope = parentScope
      }
      else {
        self.scope = t.scope
        t.members.forEach(|m| self.visitMethodDeclaration(m, type_.providesType.unwrap()))

        if let TypeKind::Trait(trait_) = type_.providesType.unwrap().kind {
          Object.assign(trait_.functions, ObjectMap.fromIter(
            t.members.map(|m| (m.name.value[0].name, m.type_))
          ))

          if let Option::Some(class) = type_.providesType.unwrap().class {
            class.instances.forEach(|mut instance| {
              if let TypeKind::Trait(instanceTrait) = instance.kind {
                Object.assign(instanceTrait, {
                  functions: trait_.functions
                })
              }
              else throw 'instance is not a trait'
            })
          }
        }
        else throw 'is not a trait'

        self.scope = parentScope
        type_.providesType.unwrap().completed = true
      }
      ()
    }
    visitTypeDeclaration: |mut self, mut t: TypeDeclaration| {
      let mut parentScope: Scope = self.scope
      let type_: Type = t.type_
      if not t.type_ {
        let structKind =
          if let Option::Some(typeBound) = t.bound {
            match typeBound {
              TypeBound::RecordTypeBound(record) => StructKind::Record({properties: ObjectMap.new()})
              TypeBound::TupleTypeBound(tuple) => StructKind::Tuple({properties: []})
              _ => throw 'Unreachable'
            }
          }
          else StructKind::Unit

        t.type_ = Type.provides({
          id: generateTypeId(context, file, t.name.name)
          displayName: None
          name: Some(t.name.name)
          kind: TypeKind::Struct({
            implementations: []
            kind: structKind
          })
          class: TypeClass.fromAstNode(t, reportError)
          instance: None
          providesType: None
          enumMember: None
        })
        let token: ToSpan = t
        if let Result::Err(error) = parentScope.define({
          name: t.name.name
          token
          mutable: false
          allowRedeclare: false
          type_: t.type_
          previous: None
          importedFrom: None
        })
          then reportError(t.name, error)
      }
      else if not t.scope {
        let mut scope = parentScope.createChild()
        t.scope = scope
        self.scope = scope
        if let Option::Some(class) = type_.providesType.unwrap().class {
          t.typeParameters.forEach(|p| {
            self.visitTypeParameter(p)
            class.typeParameters.push(p.type_)
          })
        }
        scope.setSelfType(type_.providesType.unwrap())
        self.scope = parentScope
      }
      else {
        self.scope = t.scope
        if let Option::Some(typeBound) = t.bound {
          self.visitTypeBound(typeBound)

          match type_.providesType.unwrap().kind {
            TypeKind::Struct({kind: StructKind::Record({properties})}) => {
              Object.assign(properties, ObjectMap.fromIter(
                typeBound.getRecordTypeBound().properties.map(|p| {
                  (p.name.name, p.typeBound.getType())
                })
              ))
            }
            TypeKind::Struct({kind: StructKind::Tuple(tuple)}) => {
              Object.assign(tuple, {
                properties: typeBound.getTupleTypeBound().properties.map(|p| p.getType()).toList()
              })
            }
            _ => {}
          }
        }

        self.scope = parentScope
        type_.providesType.unwrap().completed = true
      }
      ()
    }

    visitExportDirective: |self, mut e: ExportDirective| {
      e.scope = self.scope
      visit.walkExportDirective(self, e)
    }
    visitImportDirective: |mut self, mut importDirective: ImportDirective| {
      let mut scope: Scope = self.scope
      importDirective.scope = self.scope
      if let Option::Some(module) = importDirective.module {
        if not module.scope {
          context.runTypeVisitorOnFile(module.file)
        }
      }

      match importDirective.specifier {
        ImportSpecifier::Identifier(identifier) => {
          let token: ToSpan = identifier
          if let Result::Err(error) = scope.define({
            name: identifier.name
            token
            mutable: false
            allowRedeclare: false
            type_: {
              id: None
              displayName: Some(identifier.name)
              name: None
              kind: TypeKind::Struct({
                implementations: []
                kind: StructKind::Record({
                  properties: ObjectMap.new()
                })
              })
              instance: None
              class: None
              providesType: None
              enumMember: None
            }
            previous: None
            importedFrom: None
          })
            then reportError(identifier, error)
        }
        ImportSpecifier::ObjectDestructure(d) => {
          d.members.forEach(|m| {
            let token: ToSpan = m
            if let Option::Some(module) = importDirective.module {
              let moduleScope: Scope = module.scope
              let importedBinding = moduleScope.getBinding(m.property.name, 'TypeVisitor').unwrapOr(Object.assign({}))
              if let Result::Err(error) = scope.define({
                name: m.local.name
                token
                mutable: false
                allowRedeclare: false
                type_: importedBinding.type_
                providesType: importedBinding.providesType
                previous: None
                importedFrom: importDirective.module
              })
                then reportError(m.local, error)
              imports[m.local.name] = importDirective.file
            }
            else {
              if let Result::Err(error) = scope.define({
                name: m.local.name
                token
                mutable: false
                allowRedeclare: false
                type_: undefined
                providesType: None
                previous: None
                importedFrom: None
              })
                then reportError(m.local, error)
            }
          })
        }
        ImportSpecifier::Asterisk(_) => {}
      }
    }

    visitTypeBound: |self, mut t: TypeBound| {
      visit.walkTypeBound(self, t)
    }
    visitNamedTypeBound: |self, mut t: NamedTypeBound| {
      let scope: Scope = self.scope
      let result = scope.getTypePath(t.path, 'TypeVisitor')

      match result {
        Ok(binding) => {}
        Err(err) => reportError(t, err)
      }

      structureVisitorInstance.visitNamedTypeBound.call(self, t)
    }
    visitTypeProperty: visit.walkingVisitor.visitTypeProperty
  })
}
