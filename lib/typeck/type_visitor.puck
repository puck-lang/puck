import 'puck:js' as {Object, undefined}
import 'node:path' as {relative}
import '../ast/ast.puck' as {
  Module
  RecordTypeBoundMember
  TopLevelStatement
  Attribute
  AttributeData
  SimpleLiteral

  EnumDeclaration
  EnumMember
  TraitDeclaration
  TypeDeclaration

  ExportDirective
  ExportedStatement
  ImportDirective
  ImportSpecifier
  ObjectDestructure

  Block

  Identifier
  FunctionDeclaration
  VariableDeclaration

  TypeBound
  FunctionTypeBound
  NamedTypeBound
  TypeParameter
  TypePath
}
import '../ast/span.puck' as {ToSpan}
import '../compiler.puck' as {CompilerContext}
import '../ast/visit.puck' as visit
import '../entities.puck' as {Definition, File, StructKind, Type, TypeClass, TypeKind, CompilationError}
import 'src/scope.puck' as {Binding, Scope, ScopeError}
import 'src/structure_visitor.puck' as {structureVisitor}
import 'src/types.puck' as {isSameId}

fn isTypeScope(e: ExportDirective) {
  match e.statement {
    ExportedStatement::EnumDeclaration(_) => true
    ExportedStatement::TraitDeclaration(_) => true
    ExportedStatement::TypeDeclaration(_) => true
    _ => false
  }
}

fn generateTypeId(context: CompilerContext, file: File, name: String) {
  let path: String = relative(context.projectPath, file.absolutePath)
  Some(path ++ ':$name')
}

fn getTypeId(declaration: {attributes: List<Attribute>, name: Identifier}, context: CompilerContext, file: File) {
  if let Some(attribute) = declaration.attributes.find(|a| a.name.name == 'type_id')
      then match attribute.data {
      AttributeData::Value(literal) => match literal {
        SimpleLiteral::StringLiteral({value}) => Some(value)
        _ => {
          context.reportError(file, attribute, CompilationError::Other('type_id must be a string'))
          generateTypeId(context, file, declaration.name.name)
        }
      }
      _ => {
        context.reportError(file, attribute, CompilationError::Other('type_id must have a value'))
        generateTypeId(context, file, declaration.name.name)
      }
    }
    else generateTypeId(context, file, declaration.name.name)
}

fn getTraits(type_: Type) -> Result<List<Type>, (ToSpan, String)> {
  let type_ = type_.providesType.unwrapOr(type_)
  match type_.kind {
    TypeKind::Trait(trait_) => Ok([type_])
    // TODO: This did not error?
    // TypeKind::Trait(trait_) => Ok([trait_])
    TypeKind::Intersection(intersection) => {
      getTraits(intersection.baseType).map(|mut types| {
        types.push(intersection.intersectedTrait)
        types
      })
    }
    _ => Err((type_.definition.token, 'Can only extend other traits'))
  }
}

/// Visits and declares Enums, Traits and Types
///
/// Enum, traits and types are declared in this separate step so that we are sure
/// that complete type information is known during the impl and checking steps.
///
/// The declarations are visited in three passes, first will all type names be
/// defined. Then will all type parameters be defined and after that is finally the
/// bodies visited and properties or functions are defined.
/// This assures that the hoisting rules is followed and all required information is known.
export fn TypeVisitor(mut context: CompilerContext, file: File) {
  let mut imports = ObjectMap.new::<File>()

  fn reportError(token: ToSpan, message: String) {
    context.reportError(file, token, CompilationError::Other(message))
  }

  let structureVisitorInstance = structureVisitor(context, file, 'TypeVisitor')
  Object->assign({}, visit.emptyVisitor, structureVisitorInstance, {
    scope: Scope.new(context)

    visitModule: |mut self, mut m: Module| {
      m->scope = self.scope
      let mut imports = []
      let mut reexports = []
      let mut declarations = []

      m.statements.forEach(|s: TopLevelStatement|
        match s {
          TopLevelStatement::EnumDeclaration(_) => declarations.push(s)
          TopLevelStatement::ImportDirective(i) => imports.push(i)
          TopLevelStatement::TraitDeclaration(_) => declarations.push(s)
          TopLevelStatement::TypeDeclaration(_) => declarations.push(s)
          TopLevelStatement::ExportDirective(e) => match e.statement {
            ExportedStatement::EnumDeclaration(_) => declarations.push(s)
            ExportedStatement::TraitDeclaration(_) => declarations.push(s)
            ExportedStatement::TypeDeclaration(_) => declarations.push(s)
            ExportedStatement::Identifier(_) => reexports.push(s)
            _ => {}
          }
          _ => {}
        }
      )

      declarations.forEach(|mut e| self.visitTopLevelStatement(e))
      imports.forEach(|mut i| self.visitImportDirective(i))
      reexports.forEach(|mut e| self.visitTopLevelStatement(e))
      declarations.forEach(|mut e| self.visitTopLevelStatement(e))
      declarations.forEach(|mut e| self.visitTopLevelStatement(e))
    }

    visitEnumDeclaration: |mut self, mut t: EnumDeclaration| {
      let mut parentScope: Scope = self.scope
      let mut type_: Type = t->type_.transmute()
      if not t->type_ {
        let definition = Definition({file, token: t})
        t->type_ = Type.provides({
          definition
          id: getTypeId(t, context, file)
          displayName: None
          name: Some(t.name.name)
          kind: TypeKind::Enum({
            implementations: []
            members: ObjectMap.new()
          })
          class: TypeClass.fromAstNode(t, reportError)
          instance: None
          providesType: None
          enumMember: None
        })
        if let Result::Err(error) = parentScope.define({
          definition
          name: t.name.name
          mutable: false
          allowRedeclare: false
          type_: t->type_.transmute()
          previous: None
          completeType: None
        })
          then reportError(t.name, error)
      }
      else if not t->scope {
        let mut scope = parentScope.createChild()
        t->scope = scope
        self.scope = scope
        if let Some(class) = type_.providesType.unwrap().class {
          let mut c = class
          t.typeParameters.forEach(|p| {
            self.visitTypeParameter(p)
            c.typeParameters.push(p->type_.transmute())
          })
        }
        scope.setSelfType(type_.providesType.unwrap())
        self.scope = parentScope
      }
      else {
        self.scope = t->scope
        t.members.forEach(|m| self.visitEnumMember(m))

        let memberMap = ObjectMap.fromIter(
          t.members.map(|p: EnumMember| {
            let definition = Definition({file, token: p})
            (
              p.name.name
              p.bound.mapOr(
                Type({
                  definition
                  id: generateTypeId(context, file, t.name.name ++ '::' ++ p.name.name)
                  displayName: None
                  name: Some(t.name.name ++ '::' ++ p.name.name)
                  kind: TypeKind::Struct({
                    implementations: []
                    kind: StructKind::Unit
                  })
                  class: None
                  instance: None
                  providesType: None
                  enumMember: Some((p.name.name, type_.providesType.unwrap()))
                })
                |bound| Type({
                  definition
                  id: generateTypeId(context, file, t.name.name ++ '::' ++ p.name.name)
                  displayName: None
                  name: None
                  kind: bound.getType().kind
                  class: None
                  instance: None
                  providesType: None
                  enumMember: Some((p.name.name, type_.providesType.unwrap()))
                })
              )
            )
          })
        )

        if t.members.size() != memberMap.size() {
          let mut members = ObjectMap.new()
          t.members.forEach(|p| {
            if members.has(p.name.name) then reportError(p, 'Duplicate member ' ++ p.name.name)
            members[p.name.name] = p
          })
        }

        if let TypeKind::Enum(enum_) = type_.providesType.unwrap().kind {
          Object->assign(enum_.members, memberMap)
        }
        else throw 'is not an enum'

        self.scope = parentScope
      }
      ()
    }
    visitTraitDeclaration: |mut self, mut t: TraitDeclaration| {
      let mut parentScope: Scope = self.scope
      let type_: Type = t->type_.transmute()
      if not t->type_ {
        let definition = Definition({file, token: t})
        t->type_ = Type.provides({
          definition
          id: getTypeId(t, context, file)
          displayName: None
          name: Some(t.name.name)
          kind: TypeKind::Trait({
            isShorthand: false
            requiredTraits: []
            functions: ObjectMap.new()
          })
          class: TypeClass.fromAstNode(t, reportError)
          instance: None
          providesType: None
          enumMember: None
        })
        if let Result::Err(error) = parentScope.define({
          definition
          name: t.name.name
          mutable: false
          allowRedeclare: false
          type_: t->type_.transmute()
          previous: None
          completeType: None
        })
          then reportError(t.name, error)
      }
      else if not t->scope {
        let mut scope = parentScope.createChild()
        t->scope = scope
        self.scope = scope
        if let Some(class) = type_.providesType.unwrap().class {
          let mut c = class
          t.typeParameters.forEach(|p| {
            self.visitTypeParameter(p)
            c.typeParameters.push(p->type_.transmute())
          })
        }
        if let Some({bound}) = t.traitBound {
          self.visitTypeBound(bound)
          match getTraits(bound.getType()) {
            Ok(requiredTraits) => {
              if let Some(trait_) = requiredTraits.find(|t| isSameId(t, type_.providesType.unwrap())) {
                reportError(trait_.definition.token, 'A trait can not extend itself')
              }
              let mut trait_ = type_.getTrait()
              trait_.requiredTraits = requiredTraits
            }
            Err((token, message)) => reportError(token, message)
          }
        }
        scope.setSelfType(type_.providesType.unwrap())
        self.scope = parentScope
      }
      else {
        self.scope = t->scope
        t.members.forEach(|m| self.visitMethodDeclaration(m, type_.providesType.unwrap()))

        let mut trait_ = type_.getTrait()
        trait_.functions.merge(ObjectMap.fromIter(
          t.members.map(|m| {
            if let TypeKind::Function(function) = m.type_.kind {
              if function.isAbstract and function.selfBinding.isNone() {
                reportError(m, 'Static trait functions can not be abstract')
              }
            }
            (m.name.unwrap().name, m.type_)
          })
        ))

        if let Some(class) = type_.providesType.unwrap().class {
          class.instances.forEach(|mut instance| {
            let mut instanceTrait = instance.getTrait()
            instanceTrait.functions = trait_.functions
          })
        }

        self.scope = parentScope
      }
      ()
    }
    visitTypeDeclaration: |mut self, mut t: TypeDeclaration| {
      let mut parentScope: Scope = self.scope
      let type_: Type = t->type_.transmute()
      if not t->type_ {
        let structKind =
          if let Some(typeBound) = t.bound {
            match typeBound {
              TypeBound::RecordTypeBound(record) => StructKind::Record({properties: ObjectMap.new()})
              TypeBound::TupleTypeBound(tuple) => StructKind::Tuple({properties: []})
              _ => throw 'Unreachable'
            }
          }
          else StructKind::Unit

        let definition = Definition({file, token: t})
        t->type_ = Type.provides({
          definition
          id: getTypeId(t, context, file)
          displayName: None
          name: Some(t.name.name)
          kind: TypeKind::Struct({
            implementations: []
            kind: structKind
          })
          class: TypeClass.fromAstNode(t, reportError)
          instance: None
          providesType: None
          enumMember: None
        })
        if let Result::Err(error) = parentScope.define({
          definition
          name: t.name.name
          mutable: false
          allowRedeclare: false
          type_: t->type_.transmute()
          previous: None
          completeType: None
        })
          then reportError(t.name, error)
      }
      else if not t->scope {
        let mut scope = parentScope.createChild()
        t->scope = scope
        self.scope = scope
        if let Some(class) = type_.providesType.unwrap().class {
          let mut c = class
          t.typeParameters.forEach(|p| {
            self.visitTypeParameter(p)
            c.typeParameters.push(p->type_.transmute())
          })
        }
        scope.setSelfType(type_.providesType.unwrap())
        self.scope = parentScope
      }
      else {
        self.scope = t->scope
        if let Some(typeBound) = t.bound {
          self.visitTypeBound(typeBound)

          match type_.providesType.unwrap().kind {
            TypeKind::Struct({kind: StructKind::Record(mut r)}) => {
              match typeBound.getType().kind {
                TypeKind::Struct({kind: StructKind::Record(tr)}) => {
                  r.properties.merge(tr.properties)
                }
                _ => {}
              }
            }
            TypeKind::Struct({kind: StructKind::Tuple(tuple)}) => {
              Object->assign(tuple, {
                properties: typeBound.getTupleTypeBound().properties.map(|p| p.getType()).toList()
              })
            }
            _ => {}
          }
        }

        self.scope = parentScope
      }
      ()
    }

    visitExportDirective: |self, mut e: ExportDirective| {
      visit.walkExportDirective(self, e)
    }
    visitImportDirective: |mut self, mut importDirective: ImportDirective| {
      let mut scope: Scope = self.scope
      if let Some(mut module) = importDirective.module {
        if not module->scope {
          context.runTypeVisitorOnFile(module.file)
        }
      }

      match importDirective.specifier {
        ImportSpecifier::Identifier(identifier) => {
          let typeProperties =
            if let Some(module) = importDirective.module {
              module.exports.map(|exportDirective| {{
                type_: exportDirective.getType()
                optional: false
              }})
            }
            else ObjectMap.new()
           let definition = Definition({file, token: identifier})
          let mut type_ = Type({
            definition
            id: None
            displayName: Some(identifier.name)
            name: None
            kind: TypeKind::Struct({
              implementations: []
              kind: StructKind::Record({
                properties: typeProperties
              })
            })
            instance: None
            class: None
            providesType: None
            enumMember: None
          })
          if let Result::Err(error) = scope.define({
            definition
            name: identifier.name
            mutable: false
            allowRedeclare: false
            type_
            previous: None
            completeType: importDirective.module.map(|mut module| |visitor: String| {
              if visitor == 'TypeVisitor' then return None
              if visitor == 'ImplVisitor' {
                context.runTypeVisitorOnFile(module.file)
              } else {
                context.runCheckerOnFile(module.file)
              }
              let moduleScope: Scope = module->scope.transmute()
              let mut typeProperties = module.exports.map(|exportDirective| {{
                type_: exportDirective.getType()
                optional: false
              }})
              match type_.kind {
                TypeKind::Struct({kind: StructKind::Record(record)}) => {
                  let mut r = record
                  r.properties = typeProperties
                }
                _ => throw 'Unreachable'
              }
              Some(type_)
            })
          })
            then reportError(identifier, error)
        }
        ImportSpecifier::ObjectDestructure(d) => {
          d.members.forEach(|mut m| {
            if let Some(mut module) = importDirective.module {
              let moduleScope: Scope = module->scope.transmute()
              let importedBinding = moduleScope.getBinding(m.property.name, 'TypeVisitor').unwrapOr(Object->assign({}).transmute())
              if let Result::Err(error) = scope.define({
                definition: Definition({file: m.file.unwrapOr(file), token: m})
                name: m.local.name
                mutable: false
                allowRedeclare: false
                type_: importedBinding.type_
                previous: None
                completeType: Some(|visitor: String| {
                  if visitor == 'TypeVisitor' then return None
                  if visitor == 'ImplVisitor' {
                    context.runTypeVisitorOnFile(module.file)
                  } else {
                    context.runCheckerOnFile(module.file)
                  }
                  let externalBinding = moduleScope.getBinding(m.property.name, visitor)
                  externalBinding.map(|binding| binding.type_)
                })
              })
                then reportError(m.local, error)
              m.local->type_ = importedBinding.type_
              imports[m.local.name] = importDirective->file
              ()
            }
            else {
              if let Result::Err(error) = scope.define({
                definition: Definition({file, token: m})
                name: m.local.name
                mutable: false
                allowRedeclare: false
                type_: undefined
                providesType: None
                previous: None
                completeType: None
              })
                then reportError(m.local, error)
            }
          })
        }
        ImportSpecifier::Asterisk(_) => {}
      }
    }

    visitIdentifier: |self, mut i: Identifier| {
      let scope: Scope = self.scope
      if let Some(binding) = scope.getBinding(i.name, 'ImplVisitor') {
        i->binding = binding
        i->type_ = binding.type_
      }
      else context.reportError(
        file
        i
        CompilationError::UndefinedVariable(i.name)
      )
      ()
    }

    visitTypeBound: |self, mut t: TypeBound| {
      visit.walkTypeBound(self, t)
    }
    visitNamedTypeBound: |self, mut t: NamedTypeBound| {
      let scope: Scope = self.scope
      let result = scope.getTypePath(t.path, 'TypeVisitor')

      match result {
        Ok(binding) => {}
        Err(ScopeError::UndefinedType(name)) => {
          context.reportError(
            file
            t
            CompilationError::UndefinedVariable(name)
          )
        }
        Err(ScopeError::Other(err)) => reportError(t, err)
      }

      structureVisitorInstance.visitNamedTypeBound->call(self, t)
    }
    visitTypeProperty: visit.walkingVisitor->visitTypeProperty
  })
}
