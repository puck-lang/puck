import 'puck:js' as {Object, undefined}
import '../ast/ast.puck' as {
  Block
  EnumDeclaration
  EnumMember
  FunctionDeclaration
  Identifier
  Module
  ObjectDestructure
  TypeBound
  FunctionTypeBound
  NamedTypeBound
  TraitDeclaration
  TypeDeclaration
  TypeParameter
  VariableDeclaration

  ExportDirective
  ImportDirective

  Token
}
import '../ast/visit.puck' as visit
import '../compiler/ast.ts' as {SyntaxKind}
import '../entities.puck' as {StructKind, TypeClass, TypeKind}
import 'src/scope.puck' as {createScope}
import 'src/structure_visitor.puck' as {structureVisitor}
import 'src/types.puck' as {getType}

/// Visits and declares Traits, Types and toplevel function frames[1]
///
/// Traits and types are declared in this separate step so that we are sure
/// that complete type information is known during the checking step.
///
/// 1. function declaration withoud the body
export fn TypeVisitor(context, file) {
  let mut importDirective: ImportDirective
  let reportError = context.reportError.bind(context, file)

  Object.assign({}, visit.emptyVisitor, structureVisitor, {
    scope: createScope(context, file)
    reportError
    imports: {}
    postHoist: []

    visitEnumDeclaration: |mut self, mut t: EnumDeclaration| {
      if not t.type_ {
        t.type_ = {
          displayName: None
          name: Some(t.name.name)
          kind: TypeKind::Enum({
            implementations: []
            members: ObjectMap.new()
          })
          class: TypeClass.fromAstNode(t, reportError)
          instance: None
        }
        self.scope.defineType(t.type_, t, true)
        self.scope.define({name: t.name.name, mutable: false, token: t, type_: t.type_})
        t.scope = self.scope.createChild()
        self.postHoist.push(t)
      }
      else if not t.typeParametersAssigned {
        self.scope = t.scope
        if let Option::Some(class) = t.type_.class {
          t.typeParameters.forEach(|p| {
            self.visitTypeParameter(p)
            class.typeParameters.push(p.type_)
          })
        }
        t.typeParametersAssigned = true
        t.scope.setSelfBinding(t.name.name)
        self.scope = self.scope.parent
      }
      else {
        self.scope = t.scope
        t.members.forEach(|m| self.visitEnumMember(m))

        let memberMap = ObjectMap.fromList(
          t.members.map(|p: EnumMember| (
            p.name.name
            p.bound.mapOrElse(
              || {{
                displayName: None
                name: Some(p.name.name)
                kind: TypeKind::Struct({
                  implementations: []
                  kind: StructKind::Unit
                })
                class: None
                instance: None
              }}
              |bound| bound.type_
            )
          ))
        )

        if t.members.size() != memberMap.size() {
          let mut members = ObjectMap.new()
          t.members.forEach(|p| {
            if members[p.name.name] then reportError(p, 'Duplicate member ' + p.name.name)
            members[p.name.name] = p
          })
        }

        if let TypeKind::Enum(enum_) = t.type_.kind {
          Object.assign(enum_.members, memberMap)
        }
        else throw 'is not an enum'

        self.scope = self.scope.parent
      }
    }
    visitModule: |mut self, mut m: Module| {
      self.scope = m.scope
      self.scope.clearBindings()
      let expressions = m.expressions.filter(|e|
        e.kind == SyntaxKind.EnumDeclaration or
        e.kind == SyntaxKind.ImportDirective or
        e.kind == SyntaxKind.TraitDeclaration or
        e.kind == SyntaxKind.TypeDeclaration or
        (e.kind == SyntaxKind.ExportDirective and (
          e.expression.kind == SyntaxKind.EnumDeclaration or
          e.expression.kind == SyntaxKind.TraitDeclaration or
          e.expression.kind == SyntaxKind.TypeDeclaration
        ))
      )
      expressions.forEach(|mut e| {
        self.visitExpression(e)
        e.hoisted = true
      })
      self.postHoist.forEach(self.visitExpression.bind(self))
      expressions.forEach(self.visitExpression.bind(self))
    }
    visitNamedTypeBound: |self, mut t: NamedTypeBound| {
      let binding = self.scope.getTypePath(t.path)
      if not binding
        then self.reportError(t, 'Use of undeclared type ' + t.path.value[0].name)
      if not binding.token.scope {
        if not self.imports[t.path.value[0].name] then reportError(t
          'Scope not set for binding ' + t.path.value[0].name + ' but not found in imports either')

        context.runTypeVisitorOnFile(self.imports[t.path.value[0].name])
      }
      structureVisitor.visitNamedTypeBound.call(self, t)
    }
    visitObjectDestructure: |mut self, mut i: ObjectDestructure| {
      i.scope = self.scope
      i.members.forEach(|m| {
        if importDirective.module {
          let e = importDirective.module.exports[m.local.name]
          if e.expression.kind == SyntaxKind.EnumDeclaration
          or e.expression.kind == SyntaxKind.TraitDeclaration
          or e.expression.kind == SyntaxKind.TypeDeclaration {
            let typeBinding = importDirective.module.scope.getTypeBinding(m.property.name)
            self.scope.setTypeBinding(typeBinding)
            self.scope.define({name: m.local.name, mutable: false, token: m, type_: typeBinding.type_})
            self.imports[m.local.name] = importDirective.file
          }
          else {
            let binding = importDirective.module.scope.getBinding(m.property.name)
            self.scope.define({
              name: m.local.name
              mutable: false
              token: m
              inherit: binding
              importedFrom: importDirective
            })
          }
        }
        else self.scope.define({name: m.local.name, mutable: false, token: m})
      })
    }
    visitTraitDeclaration: |mut self, mut t: TraitDeclaration| {
      if not t.type_ {
        t.type_ = {
          displayName: None
          name: Some(t.name.name)
          kind: TypeKind::Trait({
            isShorthand: false
            functions: ObjectMap.new()
          })
          class: TypeClass.fromAstNode(t, reportError)
          instance: None
        }
        self.scope.defineType(t.type_, t, true)
        t.binding = self.scope.define({
          name: t.name.name
          mutable: false
          token: t
          type_: t.type_
        })
        self.postHoist.push(t)
      }
      else if not t.scope {
        self.scope = self.scope.createChild()
        t.scope = self.scope
        if let Option::Some(class) = t.type_.class {
          t.typeParameters.forEach(|p| {
            self.visitTypeParameter(p)
            class.typeParameters.push(p.type_)
          })
        }
        t.scope.setSelfBinding(t.name.name)
        self.scope = self.scope.parent
      }
      else {
        self.scope = t.scope
        t.members.forEach(|t| self.visitMethodDeclaration(t))

        if let TypeKind::Trait(trait_) = t.type_.kind {
          Object.assign(trait_.functions, ObjectMap.fromList(
            t.members.map(|m| (m.name.value[0].name, m.type_))
          ))

          if let Option::Some(class) = t.type_.class {
            class.instances.forEach(|mut instance| {
              if let TypeKind::Trait(instanceTrait) = instance.kind {
                Object.assign(instanceTrait, {
                  functions: trait_.functions
                })
              }
              else throw 'instance is not a trait'
            })
          }
        }
        else throw 'is not a trait'

        self.scope = self.scope.parent
      }
    }
    visitTypeDeclaration: |mut self, mut t: TypeDeclaration| {
      if not t.type_ {
        let structKind =
          if let Option::Some(typeBound) = t.bound {
            if typeBound.kind == SyntaxKind.ObjectTypeBound
              then StructKind::Record({properties: ObjectMap.new()})
            else if typeBound.kind == SyntaxKind.TupleTypeBound
              then StructKind::Tuple({properties: []})
          }
          else StructKind::Unit

        t.type_ = {
          displayName: None
          name: Some(t.name.name)
          kind: TypeKind::Struct({
            implementations: []
            kind: structKind
          })
          class: TypeClass.fromAstNode(t, reportError)
          instance: None
        }
        self.scope.defineType(t.type_, t, true)
        t.binding = self.scope.define({
          name: t.name.name
          mutable: false
          token: t
          type_: t.type_
        })
        t.scope = self.scope.createChild()
        self.postHoist.push(t)
      }
      else if not t.typeParametersAssigned {
        self.scope = t.scope
        if let Option::Some(class) = t.type_.class {
          t.typeParameters.forEach(|p| {
            self.visitTypeParameter(p)
            class.typeParameters.push(p.type_)
          })
        }
        t.typeParametersAssigned = true
        t.scope.setSelfBinding(t.name.name)
        self.scope = self.scope.parent
      }
      else {
        self.scope = t.scope
        if let Option::Some(typeBound) = t.bound {
          self.visitTypeBound(typeBound)

          match t.type_.kind {
            TypeKind::Struct({kind: StructKind::Record({properties})}) => {
              Object.assign(properties, ObjectMap.fromList(
                typeBound.properties.map(|p| (p.name.name, p.typeBound.type_))
              ))
            }
            TypeKind::Struct({kind: StructKind::Tuple(tuple)}) => {
              Object.assign(tuple, {
                properties: typeBound.properties.map(|p| p.type_)
              })
            }
            _ => {}
          }
        }

        self.scope = self.scope.parent
      }
    }
    visitTypeProperty: visit.walkingVisitor.visitTypeProperty

    visitExportDirective: |self, mut e: ExportDirective| {
      e.scope = self.scope
      visit.walkExportDirective(self, e)
    }
    visitImportDirective: |self, mut i: ImportDirective| {
      if i.hoisted then return undefined

      i.scope = self.scope
      if i.specifier.kind == SyntaxKind.Identifier
        then self.scope.define({name: i.specifier.name, mutable: false, token: i})
      else if i.specifier.kind == SyntaxKind.ObjectDestructure {
        importDirective = i
        visit.walkImportDirective(self, i)
      }
    }
  })
}
