import 'puck:js' as {Object, undefined}
import '../ast/ast.puck' as {
  Block
  EnumDeclaration
  EnumMember
  FunctionDeclaration
  Identifier
  ImplDeclaration
  Module
  ObjectDestructure
  TypeBound
  FunctionTypeBound
  NamedTypeBound
  TraitDeclaration
  TypeDeclaration
  TypeParameter
  VariableDeclaration

  ExportDirective
  ImportDirective

  AssignmentExpression
  BinaryExpression
  CallExpression
  ForExpression
  IfExpression
  LoopExpression
  UnaryExpression
  WhileExpression

  IndexAccess
  MemberAccess

  Token
  ReturnStatement

  ListLiteral
  BooleanLiteral
  NumberLiteral
  ObjectLiteral
  StringLiteral
}
import '../ast/visit.puck' as visit
import '../compiler/ast.ts' as {SyntaxKind}
import '../entities.puck' as {isObjectType, isTupleType}
import 'src/scope.puck' as {createScope}
import 'src/structure_visitor.puck' as {structureVisitor}
import 'src/types.puck' as {getType}

/// Visits and declares Traits, Types and toplevel function frames[1]
///
/// Traits and types are declared in this separate step so that we are sure
/// that complete type information is known during the checking step.
///
/// 1. function declaration withoud the body
export fn TypeVisitor(context, file) {
  let mut importDirective: ImportDirective
  let reportError = context.reportError.bind(context, file)

  Object.assign({}, visit.emptyVisitor, structureVisitor, {
    scope: createScope(context, file)
    reportError
    imports: {}
    postHoist: []

    visitEnumDeclaration: |mut self, mut t: EnumDeclaration| {
      if not t.ty {
        t.ty = self.scope.defineType(t, true).ty
        self.scope.define({name: t.name.name, mutable: false, token: t, ty: t.ty})
        t.scope = createScope(context, file, self.scope)
        self.postHoist.push(t)
      }
      else if not t.typeParametersAssigned {
        self.scope = t.scope
        t.typeParameters.forEach(|p| {
          self.visitTypeParameter(p)
          t.ty.typeParameters.push(p.ty)
        })
        t.typeParametersAssigned = true
        self.scope = self.scope.parent
      }
      else {
        self.scope = t.scope
        t.members.forEach(|m| self.visitEnumMember(m))

        let memberMap = ObjectMapTrait.fromList(
          t.members.map(|p: EnumMember| (
            p.name.name
            p.bound.mapOrElse(
              || {{
                kind: p.name.name
                name: p.name.name
                implementations: []
                isUnit: true
              }}
              |bound| bound.ty
            )
          ))
        )

        if t.members.size() != memberMap.size() {
          let mut members = ObjectMapTrait.new()
          t.members.forEach(|p| {
            if members[p.name.name] then reportError(p, 'Duplicate member ' + p.name.name)
            members[p.name.name] = p
          })
        }

        Object.assign(t.ty.members, memberMap)

        self.scope = self.scope.parent
      }
    }
    visitModule: |mut self, mut m: Module| {
      self.scope = m.scope
      self.scope.clearBindings()
      let expressions = m.expressions.filter(|e|
        e.kind == SyntaxKind.EnumDeclaration or
        e.kind == SyntaxKind.ImportDirective or
        e.kind == SyntaxKind.TraitDeclaration or
        e.kind == SyntaxKind.TypeDeclaration or
        (e.kind == SyntaxKind.ExportDirective and (
          e.expression.kind == SyntaxKind.EnumDeclaration or
          e.expression.kind == SyntaxKind.TraitDeclaration or
          e.expression.kind == SyntaxKind.TypeDeclaration
        ))
      )
      expressions.forEach(|mut e| {
        self.visitExpression(e)
        e.hoisted = true
      })
      self.postHoist.forEach(self.visitExpression.bind(self))
      expressions.forEach(self.visitExpression.bind(self))
    }
    visitNamedTypeBound: |self, mut t: NamedTypeBound| {
      let binding = self.scope.getTypeBinding(t.name.name)
      if not binding
        then self.reportError(t, 'Use of undeclared type ' + t.name.name)
      if not binding.token.scope {
        if not self.imports[t.name.name] then reportError(t
          'Scope not set for binding ' + t.name.name + ' but not found in imports either')

        context.runTypeVisitorOnFile(self.imports[t.name.name])
      }
      structureVisitor.visitNamedTypeBound.call(self, t)
    }
    visitObjectDestructure: |mut self, mut i: ObjectDestructure| {
      i.scope = self.scope
      i.members.forEach(|m| {
        if importDirective.module {
          let e = importDirective.module.exports[m.local.name]
          if e.expression.kind == SyntaxKind.EnumDeclaration
          or e.expression.kind == SyntaxKind.TraitDeclaration {
            let typeBinding = importDirective.module.scope.getTypeBinding(m.property.name)
            self.scope.setTypeBinding(typeBinding)
            self.scope.define({name: m.local.name, mutable: false, token: m, ty: typeBinding.ty})
          }
          else if e.expression.kind == SyntaxKind.TypeDeclaration {
            let typeBinding = importDirective.module.scope.getTypeBinding(m.property.name)
            self.scope.setTypeBinding(typeBinding)
            self.imports[m.local.name] = importDirective.file
          }
          else self.scope.define({name: m.local.name, mutable: false, token: m})
        }
        else self.scope.define({name: m.local.name, mutable: false, token: m})
      })
    }
    visitTraitDeclaration: |mut self, mut t: TraitDeclaration| {
      if not t.ty {
        t.ty = self.scope.defineType(t, true).ty
        t.binding = self.scope.define({
          name: t.name.name
          mutable: false
          token: t
          ty: t.ty
        })
        self.postHoist.push(t)
      }
      else if not t.scope {
        self.scope = createScope(context, file, self.scope)
        t.scope = self.scope
        if t.typeParameters
          then t.typeParameters.forEach(|p| {
            self.visitTypeParameter(p)
            t.ty.typeParameters.push(p.ty)
          })
        self.scope = self.scope.parent
      }
      else {
        self.scope = t.scope
        t.members.forEach(|t| self.visitFunctionDeclaration(t))

        Object.assign(t.ty.functions, ObjectMapTrait.fromList(
          t.members.map(|m| [m.name.value[0].name, m.ty])))
        if t.ty.instances
          then t.ty.instances.forEach(|mut instance| {
            instance.functions = t.ty.functions
          })

        self.scope = self.scope.parent
      }
    }
    visitTypeDeclaration: |mut self, mut t: TypeDeclaration| {
      if not t.ty {
        t.ty = self.scope.defineType(t, true).ty
        t.scope = createScope(context, file, self.scope)
        self.postHoist.push(t)
      }
      else if not t.typeParametersAssigned {
        self.scope = t.scope
        t.typeParameters.forEach(|p| {
          self.visitTypeParameter(p)
          t.ty.typeParameters.push(p.ty)
        })
        t.typeParametersAssigned = true
        self.scope = self.scope.parent
      }
      else {
        self.scope = t.scope
        if t.bound.isJust() then self.visitTypeBound(t.bound.value[0])

        if isObjectType(t.ty)
          then Object.assign(t.ty.properties, ObjectMapTrait.fromList(
            t.bound.value[0].properties.map(|p| [p.name.name, p.typeBound.ty])))
        else if isTupleType(t.ty) {
          t.ty.properties = t.bound.value[0].properties.map(|p| p.ty)
        }

        self.scope = self.scope.parent
      }
    }
    visitTypeProperty: visit.walkingVisitor.visitTypeProperty

    visitExportDirective: |self, mut e: ExportDirective| {
      e.scope = self.scope
      visit.walkExportDirective(self, e)
    }
    visitImportDirective: |self, mut i: ImportDirective| {
      if i.hoisted then return undefined

      i.scope = self.scope
      if i.specifier.kind == SyntaxKind.Identifier
        then self.scope.define({name: i.specifier.name, mutable: false, token: i})
      else if i.specifier.kind == SyntaxKind.ObjectDestructure {
        importDirective = i
        visit.walkImportDirective(self, i)
      }
    }
  })
}
