import 'puck:js' as {Error, Object, asResult, console, require, undefined, typeof}
import 'node:babel-core' as babel
import 'node:fs' as fs
import 'node:path' as path
import 'node:util' as {inspect}
import 'ast/span.puck' as {ToSpan}
import 'compiler/emitter.ts' as {Emitter}
import 'compiler/input_stream.puck' as {InputStream}
import 'compiler/parser.puck' as {parse}
import 'compiler/token_stream.puck' as {TokenStream}
import 'helpers.puck' as {cmd}
import 'typeck/impl_visitor.puck' as {ImplVisitor}
import 'typeck/import_visitor.puck' as {ImportVisitor}
import 'typeck/scope_visitor.puck' as {ScopeVisitor}
import 'typeck/top_level_visitor.puck' as {TopLevelVisitor}
import 'typeck/type_visitor.puck' as {TypeVisitor}
import 'entities.puck' as {BuildFile, File, UnparsedFile}

fn fileInspect(self, depth, opts) {
  inspect(
    Object->assign({}, self, {puck: '[hidden]', ast: '[hidden]', js: '[hidden]', inspect: undefined})
    Object->assign({}, opts, {depth: opts.depth - depth})
  )
}

export fn parseString(context, file: UnparsedFile) {
  let mut ast = parse(TokenStream.new(InputStream.new(context, file)), file)
  TopLevelVisitor(context, file)->visitModule(ast)
  ImportVisitor(context, file)->visitModule(ast)
  ast
}

export fn compile(context, file: File) {
  Emitter(context, file).emitModule(file->ast, file.isBin)
}

fn babelTransform(file) -> String {
  babel
    ->transform(file.js, {
      filename: file.absolutePath
      presets: require->resolve('babel-preset-latest')
      babelrc: false
    })
    ->code.transmute()
}

fn dumpFiles(files: List<File>, prop: String) {
  files.forEach(|file| {
    print('')
    print(file.absolutePath)
    let data = match file->[prop].asString() {
      Some(data) => data
      None => inspect(file->[prop], {colors: false, depth: 25})
    }
    print(data.split('\n').map(|line| '  $line')->join('\n'))
  })
}

export fn createContext(projectPath: String, ignoreErrors = false) {
  {
    projectPath
    impls: ObjectMap.new()
    files: ObjectMap.new()
    deferred: ObjectMap.new()
    runTypeVisitor: fn (self) {
      let keys: List<String> = Object->keys(self.files).transmute()
      keys
        .map(|path| self.files->[path])
        .forEach(|mut file| {
          if not file->typeVisitorStarted and file->ast {
            file->typeVisitorStarted = true
            TypeVisitor(self, file)->visitModule(file->ast)
            file->typeVisitorCompleted = true
          }
        })
    }
    runImplVisitor: fn (mut self) {
      let keys: List<String> = Object->keys(self.files).transmute()
      keys
        .map(|path| self.files->[path])
        .forEach(|mut file| {
          if not file->implVisitorStarted and file->ast {
            file->implVisitorStarted = true
            ImplVisitor(self, file)->visitModule(file->ast)
          }
        })
    }
    runChecker: fn (self) {
      let keys: List<String> = Object->keys(self.files).transmute()
      keys
        .map(|path| self.files->[path])
        .forEach(|mut file| {
          if not file->scopeVisitorStarted and file->ast {
            file->scopeVisitorStarted = true
            ScopeVisitor(self, file)->visitModule(file->ast)
          }
        })
    }
    runTypeVisitorOnFile: fn (self, mut file) {
      if not file.typeVisitorCompleted {
        if file.typeVisitorStarted {
          throw 'Circular import??'
        }
        file.typeVisitorStarted = true
        TypeVisitor(self, file)->visitModule(file.ast)
        file.typeVisitorCompleted = true
      }
    }
    runImplVisitorOnFile: fn (mut self, mut file) {
      if not file.typeVisitorStarted {
        self.runTypeVisitorOnFile(file)
      }
      if file.implVisitorStarted {
        throw Error('runImplVisitorOnFile??')
      }
      file.implVisitorStarted = true
      ImplVisitor(self, file)->visitModule(file.ast)
    }
    runCheckerOnFile: fn (self, mut file) {
      if not file.implVisitorStarted {
        self.runImplVisitorOnFile(file)
      }
      if not file.scopeVisitorStarted {
        file.scopeVisitorStarted = true
        ScopeVisitor(self, file)->visitModule(file.ast)
      }
    }
    defer: fn (mut self, file, func) {
      if not self.deferred->[file.absolutePath] {
        self.deferred->[file.absolutePath] = []
      }
      self.deferred->[file.absolutePath]->push(func)
    }
    resolvePath: fn (file, relativeTo) {
      let filePath =
        if file.substring(0, 1) == '/'
          then file
          else path->join(path->dirname(relativeTo.absolutePath), file).transmute()
      let absolutePath = fs->realpathSync(path->resolve(path->normalize(filePath))).transmute()
      let fileName = path->basename(absolutePath)

      {absolutePath, fileName, inspect: fileInspect}
    }
    importFile: fn (mut self, mut file: UnparsedFile) -> File {
      if self.files->[file.absolutePath] and file->outDir and file->outFile {
        self.files->[file.absolutePath]->outDir = file->outDir
        self.files->[file.absolutePath]->outFile = file->outFile
      }

      if not self.files->[file.absolutePath] {
        self.files->[file.absolutePath] = file

        if not file.puck
          then file.puck = fs->readFileSync(file.absolutePath, {encoding: 'utf-8'}).transmute()
        file->ast = parseString(self, file)

        if self.deferred->[file.absolutePath] {
          let callbacks = self.deferred->[file.absolutePath]
          self.deferred->[file.absolutePath] = undefined
          callbacks->forEach(|callback| callback())
        }
      }
      self.files->[file.absolutePath].transmute()
    }
    reportError: fn (self, file: File, token: ToSpan, message: String) {
      if not ignoreErrors {
        let {line, column} = token.span().start
        throw Error('$message\n  in ' + file.absolutePath + ' ($line:$column)')
      }
    }
  }
}

export fn buildString(code: String, filePath: String, projectPath: String) -> Result<File, {}> {
  asResult(|| {
    let mut context = createContext(projectPath)
    let mut file = context.importFile({
      isBin: false
      fileName: path->basename(filePath).transmute()
      absolutePath: fs->realpathSync(path->resolve(path->normalize(filePath))).transmute()
      puck: code
    })

    context.runTypeVisitor()
    context.runImplVisitor()
    context.runChecker()
    file.js = compile(context, file)
    file->babel = babelTransform(file)

    file
  })
}

export fn build(files: List<BuildFile>, mut context, options = {}) {
  let dump = options->dump

  let mut files = files.map(|f| {
    let fileName = path->basename(f.file).transmute()
    let absolutePath = fs->realpathSync(path->resolve(path->normalize(f.file))).transmute()
    let outFile = path->normalize(f.outFile)
    let outDir = path->dirname(outFile)

    {isBin: f.isBin, absolutePath, outFile, outDir, inspect: fileInspect}
  })

  let files = files.map(|mut f| context.importFile(f))

  if dump == 'ast' {
    dumpFiles(files, 'ast')
    return undefined
  }

  context.runTypeVisitor()

  if dump == 'typed-ast' {
    dumpFiles(files, 'ast')
    return undefined
  }

  context.runImplVisitor()

  if dump == 'impl-ast' {
    dumpFiles(files, 'ast')
    return undefined
  }

  context.runChecker()

  if dump == 'checked-ast' {
    dumpFiles(files, 'ast')
    return undefined
  }

  files.forEach(|mut file| {
    file.js = compile(context, file)
  })

  if dump == 'js' {
    dumpFiles(files, 'js')
    return undefined
  }

  files.forEach(|mut file| {
    file.babel = babelTransform(file)
  })

  files.forEach(|f| {
    let outDir = f.outDir
    let outFile = f.outFile
    cmd('mkdir -p $outDir')
    fs->writeFileSync('$outFile', f.babel + '\n', {mode: 511}) // 511 = 0o777.transmute()
  })
}
