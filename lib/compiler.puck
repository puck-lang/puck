import 'puck:js' as {Error, Object, asResult, console, process, require, undefined, typeof}
import 'node:babel-core' as babel
import 'node:fs' as fs
import 'node:path' as path
import 'node:util' as {inspect}
import 'compiler/emitter.ts' as {Emitter}
import 'compiler/input_stream.puck' as {InputStream}
import 'compiler/parser.puck' as {parse}
import 'compiler/token_stream.puck' as {TokenStream}
import 'helpers.puck' as {cmd}
import 'typeck/impl_visitor.puck' as {ImplVisitor}
import 'typeck/import_visitor.puck' as {ImportVisitor}
import 'typeck/scope_visitor.puck' as {ScopeVisitor}
import 'typeck/top_level_visitor.puck' as {TopLevelVisitor}
import 'typeck/type_visitor.puck' as {TypeVisitor}
import 'entities.puck' as {File, UnparsedFile}

fn fileInspect(self, depth, opts) {
  inspect({absolutePath: self.absolutePath}, Object.assign({}, opts, {depth: opts.depth - depth}))
}

export fn parseString(context, file: UnparsedFile) {
  let mut ast = parse(TokenStream(InputStream(file)))
  TopLevelVisitor(context, file).visitModule(ast)
  ImportVisitor(context, file).visitModule(ast)
  ast
}

export fn compile(context, file: File) {
  Emitter(context, file).emitModule(file.ast, file.isBin)
}

fn babelTransform(file) {
  babel
    .transform(file.js, {
      filename: file.absolutePath
      presets: require.resolve('babel-preset-latest')
      babelrc: false
    })
    .code
}

fn dumpFiles(files: List<File>, prop: String) {
  files.forEach(|file| {
    print()
    print(file.absolutePath)
    let mut data = file[prop]
    if typeof(data) != 'string' {
      data = inspect(data, {colors: false, depth: 25})
    }
    print(data.split('\n').map(|line| '  $line').join('\n'))
  })
}

fn createContext(ignoreErrors = false) {
  {
    files: {}
    deferred: {}
    runTypeVisitor: fn (self) {
      Object.keys(self.files)
        .map(|path| self.files[path])
        .forEach(|mut file| {
          if not file.typeVisitorStarted {
            file.typeVisitorStarted = true
            TypeVisitor(self, file).visitModule(file.ast)
          }
        })
    }
    runImplVisitor: fn (self) {
      Object.keys(self.files)
        .map(|path| self.files[path])
        .forEach(|file| ImplVisitor(self, file).visitModule(file.ast))
    }
    runChecker: fn (self) {
      Object.keys(self.files)
        .map(|path| self.files[path])
        .forEach(|mut file| {
          if not file.scopeVisitorStarted {
            file.scopeVisitorStarted = true
            ScopeVisitor(self, file).visitModule(file.ast)
          }
        })
    }
    runTypeVisitorOnFile: fn (self, mut file) {
      if file.typeVisitorStarted {
        throw 'Circular import??'
      }
      file.typeVisitorStarted = true
      TypeVisitor(self, file).visitModule(file.ast)
    }
    runCheckerOnFile: fn (self, mut file) {
      if not file.scopeVisitorStarted {
        file.scopeVisitorStarted = true
        ScopeVisitor(self, file).visitModule(file.ast)
      }
    }
    defer: fn (mut self, file, func) {
      self.deferred[file.absolutePath] = func
    }
    resolvePath: fn (file, relativeTo) {
      let filePath =
        if file.substring(0, 1) == '/'
          then file
          else path.join(path.dirname(relativeTo.absolutePath), file)
      let absolutePath = path.resolve(path.normalize(filePath))
      let fileName = path.basename(absolutePath)

      {absolutePath, fileName, inspect: fileInspect}
    }
    importFile: fn (mut self, mut file: UnparsedFile) {
      if self.files[file.absolutePath] and file.outDir and file.outFile {
        self.files[file.absolutePath].outDir = file.outDir
        self.files[file.absolutePath].outFile = file.outFile
      }

      if not self.files[file.absolutePath] {
        self.files[file.absolutePath] = file

        if not file.puck
          then file.puck = fs.readFileSync(file.absolutePath, {encoding: 'utf-8'})
        file.ast = parseString(self, file)

        if self.deferred[file.absolutePath]
          then self.deferred[file.absolutePath]()
      }
      self.files[file.absolutePath]
    }
    reportError: fn (self, file: File, token, message) {
      if not ignoreErrors {
        throw Error('$message\n  in ' + file.absolutePath)
      }
    }
  }
}

export fn buildString(code: String, filePath: String) -> Result<File, {}> {
  asResult(|| {
    let mut context = createContext()
    let mut file = context.importFile({
      isBin: false
      fileName: path.basename(filePath)
      absolutePath: path.resolve(path.normalize(filePath))
      puck: code
    })

    context.runTypeVisitor()
    context.runImplVisitor()
    context.runChecker()
    file.js = compile(context, file)
    file.babel = babelTransform(file)

    file
  })
}

export fn build(files: List<UnparsedFile>, options = {}) {
  let dump = options.dump
  let mut context = createContext(options.ignoreErrors)

  let mut files = files.map(|f| {
    let fileName = path.basename(f.file)
    let absolutePath = path.resolve(path.normalize(f.file))
    let outFile = path.normalize(f.outFile)
    let outDir = path.dirname(outFile)

    {isBin: f.isBin, absolutePath, outFile, outDir, inspect: fileInspect}
  })

  let files = files.map(|mut f| context.importFile(f))

  if dump == 'ast' {
    dumpFiles(files, 'ast')
    return undefined
  }

  context.runTypeVisitor()

  if dump == 'typed-ast' {
    dumpFiles(files, 'ast')
    return undefined
  }

  context.runImplVisitor()

  if dump == 'impl-ast' {
    dumpFiles(files, 'ast')
    return undefined
  }

  context.runChecker()

  if dump == 'checked-ast' {
    dumpFiles(files, 'ast')
    return undefined
  }

  files.forEach(|mut file| {
    file.js = compile(context, file)
  })

  if dump == 'js' {
    dumpFiles(files, 'js')
    return undefined
  }

  files.forEach(|mut file| {
    file.babel = babelTransform(file)
  })

  files.forEach(|f| {
    let outDir = f.outDir
    let outFile = f.outFile
    cmd('mkdir -p $outDir')

    fs.writeFileSync('$outFile', f.babel + '\n', {mode: 511}) // 511 = 0o777
  })
}
