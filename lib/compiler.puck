import 'puck:js' as {Object, console, process, typeof}
import 'node:babel-core' as babel
import 'node:fs' as fs
import 'node:path' as path
import 'compiler/emitter.ts' as {Emitter}
import 'compiler/input_stream.puck' as {InputStream}
import 'compiler/parser.puck' as {parse}
import 'compiler/token_stream.puck' as {TokenStream}
import 'helpers.puck' as {cmd}
import 'typeck/import.puck' as {ImportVisitor}
import 'typeck/scope.puck' as {ScopeVisitor, TopScopeVisitor}
import 'entities.puck' as {File}

export fn parseString(context, file: File) {
  let mut ast = parse(TokenStream(InputStream(file)), file)
  TopScopeVisitor(context, file).visitModule(ast)
  ImportVisitor(context, file).visitModule(ast)
  ast
}

export fn compile(context, file: File) {
  Emitter().emitModule(file.ast)
}

export fn build(files: List<File>) {
  let files = files.map(|f| {
    let fileName = path.basename(f.file)
    let absolutePath = path.resolve(path.normalize(f.file))
    let outFile = path.normalize(f.outFile)
    let outDir = path.dirname(outFile)

    {absolutePath, outFile, outDir}
  })

  let context = {
    files: {}
    deferred: {}
    defer: fn (self, file, func) then self.deferred[file.absolutePath] = func
    resolvePath: fn (file, relativeTo): File {
      let filePath =
        if file.substring(0, 1) == '/'
          then file
          else path.join(path.dirname(relativeTo.absolutePath), file)
      let absolutePath = path.resolve(path.normalize(filePath))
      let fileName = path.basename(absolutePath)

      {absolutePath, fileName}
    }
    importFile: fn (self, mut file: File) {
      if self.files[file.absolutePath] and file.outDir and file.outFile {
        self.files[file.absolutePath].outDir = file.outDir
        self.files[file.absolutePath].outFile = file.outFile
      }

      if not self.files[file.absolutePath] {
        self.files[file.absolutePath] = file

        file.puck = fs.readFileSync(file.absolutePath, {encoding: 'utf-8'})
        file.ast = parseString(context, file)

        if self.deferred[file.absolutePath]
          then self.deferred[file.absolutePath]()
      }
      self.files[file.absolutePath]
    }
    reportError: fn (file: File, token, message) {
      console.error('$message\n  in ' + file.absolutePath)
      throw Error()
      process.exit(1)
    }
  }

  let files = files.map(|f| context.importFile(f))

  Object.keys(context.files)
    .map(|path| context.files[path])
    .forEach(|file| ScopeVisitor(context, file).visitModule(file.ast))

  files.forEach(|file| {
    file.js = compile(context, file)
    file.babel = babel.transform(file.js, {
      filename: file.absolutePath
      presets: 'latest'
      babelrc: false
    }).code
  })

  files.forEach(|f| {
    let outDir = f.outDir
    let outFile = f.outFile
    cmd('mkdir -p $outDir')

    fs.writeFileSync('$outFile', f.babel + '\n', {mode: 511}) // 511 = 0o777
  })
}
