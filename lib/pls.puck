import 'puck:js' as {Error, asResult, undefined}
import 'node:path' as path
import 'node:vscode-languageserver' as {
  CompletionItemKind
  DiagnosticSeverity
}
import 'ast/ast.puck' as {Module}
import 'ast/span.puck' as {Position, ToSpan}
import 'pls/completions.puck' as {CompletionVisitor}
import 'pls/definition.puck' as {Definition, DefinitionVisitor}
import 'pls/hover.puck' as {Hover, HoverVisitor}
import 'pls/position_visitor.puck' as {PositionVisitor}
import 'typeck/src/scope.puck' as {Scope}
import 'compiler.puck' as {createContext}
import 'entities.puck' as {File, UnparsedFile}

export fn createServer(projectPath: String, sendDiagnostic) {
  let mut context
  let mut a = {}
  a.validateDocument = fn (filePath: String, contents: String) {
    print('validateDocument')
    context = createContext(projectPath)
    context.reportError = fn (file: File, token: ToSpan, message) {
      print('reportError', (file.absolutePath, message))
      let span = token.span()
      sendDiagnostic(file.absolutePath, {
        severity: DiagnosticSeverity.Error
        range: {
          start: {line: span.start.line - 1, character: span.start.column - 1}
          end: {line: span.end.line - 1, character: span.end.column - 1}
        }
        message
        source: 'puck'
      })
    }

    let result = asResult(|| {
      let mut file: UnparsedFile = {
        isBin: false
        fileName: path.basename(filePath)
        absolutePath: path.resolve(path.normalize(filePath))
        puck: contents
      }
      file = context.importFile(file)

      context.runTypeVisitor()
      context.runImplVisitor()
      context.runCheckerOnFile(file)
    })
    print('validateDocument completed')

    if let Result::Err(error) = result {
      if error != 'Syntax Error' {
        print('Error:', error)
      }
    }
  }
  a.onCompletion = fn (filePath: String, position: Position) {
    print('onCompletion')
    if not context then return []
    let file: File = context.files[path.resolve(path.normalize(filePath))]
    if not file then return []
    let module: Module = file.ast
    if not module then return []

    let mut visitor = CompletionVisitor.new(position)

    let result = asResult(|| {
      visitor.visitModule(module)
    })

    match result {
      Ok(completions) => {
        if let Some(completions) = visitor.completions {
          completions
        }
        else []
      }
      Err(error) => {
        print('completions Error:', (error, error.stack))
        []
      }
    }
  }
  a.onHover = fn (filePath: String, position: Position) -> Hover {
    print('onHover')
    if not context then return Hover.empty()
    let file: File = context.files[path.resolve(path.normalize(filePath))]
    if not file then return Hover.empty()
    let module: Module = file.ast
    if not module then return Hover.empty()

    let mut visitor = HoverVisitor.new(position)

    let result = asResult(|| {
      visitor.visitModule(module)
    })

    match result {
      Ok(_) => {
        print('onHover ok', visitor.hover)
        visitor.hover.unwrapOrElse(|| Hover.empty())
      }
      Err(error) => {
        print('onHover Error:', (error, error.stack))
        Hover.empty()
      }
    }
  }
  a.onDefinition = fn (filePath: String, position: Position) -> List<Definition> {
    print('onDefinition')
    if not context then return []
    let file: File = context.files[path.resolve(path.normalize(filePath))]
    if not file then return []
    let module: Module = file.ast
    if not module then return []

    let mut visitor = DefinitionVisitor.new(file, position)

    let result = asResult(|| {
      visitor.visitModule(module)
    })
    match result {
      Ok(_) => {
        print('onDefinition ok', visitor.definitions)
        visitor.definitions
      }
      Err(error) => {
        print('onDefinition Error:', (error, error.stack))
        []
      }
    }
  }
  a
}
