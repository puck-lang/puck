import 'puck:js' as {Date, Error, asResult, undefined}
import 'node:path' as path
import 'node:vscode-languageserver' as {
  CompletionItemKind
  DiagnosticSeverity
}
import 'ast/ast.puck' as {Module}
import 'ast/span.puck' as {Position, ToSpan}
import 'pls/completions.puck' as {CompletionVisitor}
import 'pls/definition.puck' as {Definition, DefinitionVisitor}
import 'pls/hover.puck' as {Hover, HoverVisitor}
import 'pls/position_visitor.puck' as {PositionVisitor}
import 'typeck/src/scope.puck' as {Scope}
import 'compiler.puck' as {createContext}
import 'entities.puck' as {File, UnparsedFile}

export fn createServer(projectPath: String, sendDiagnostic) {
  // let mut contexts = ObjectMap.new()
  let mut context = createContext(projectPath)
  context.reportError = fn (file: File, token: ToSpan, message) {
    print('reportError', (file.absolutePath, message))
    let span = token.span()
    sendDiagnostic(file.absolutePath, {
      severity: DiagnosticSeverity.Error
      range: {
        start: {line: span.start.line - 1, character: span.start.column - 1}
        end: {line: span.end.line - 1, character: span.end.column - 1}
      }
      message
      source: 'puck'
    })
  }
  let mut a = {}
  a->onClose = fn (filePath: String) {
    // contexts.delete(filePath)
  }
  a->validateDocument = fn (filePath: String, contents: String, skipSyntaxErrors: Bool) {
    print('validateDocument')
    let startTime = Date->now()

    let result = asResult(|| {
      let startTime = Date->now()
      let mut file: UnparsedFile = {
        isBin: false
        fileName: path->basename(filePath).transmute()
        absolutePath: path->resolve(path->normalize(filePath)).transmute()
        puck: contents
      }
      let mut file = context.importFile(file, true, skipSyntaxErrors)
      let parseTime = Date->now() - startTime
      print('Parse time $parseTime')

      context.runTypeVisitor()
      let typeVisitorTime = Date->now() - startTime - parseTime
      print('Type visitor time $typeVisitorTime')
      context.runImplVisitor()
      let implVisitorTime = Date->now() - startTime - parseTime - typeVisitorTime
      print('Impl visitor time $implVisitorTime')
      context.runCheckerOnFile(file)
      let scopeVisitorTime = Date->now() - startTime - parseTime - typeVisitorTime - implVisitorTime
      print('Scope visitor time $scopeVisitorTime')
    })
    let totalTime = Date->now() - startTime
    print('Total time $totalTime')
    print('validateDocument completed')

    if let Result::Err(error) = result {
      if error != 'Syntax Error' {
        print('Error:', error)
      }
      if not skipSyntaxErrors {
        // contexts.set(filePath, context)
      }
    }
    else {
      // contexts.set(filePath, context)
    }
  }
  a->onCompletion = fn (filePath: String, position: Position) {
    print('onCompletion')
    // let context = match contexts.get(filePath) {
    //   Some(context) => context
    //   None => return []
    // }
    let file: File = context->files->[path->resolve(path->normalize(filePath))].transmute()
    if not file then return []
    let module: Module = file->ast.transmute()
    if not module then return []

    let mut visitor = CompletionVisitor.new(file, position)

    let result = asResult(|| {
      visitor.visitModule(module)
    })

    match result {
      Ok(completions) => {
        if let Some(completions) = visitor.completions {
          completions
        }
        else []
      }
      Err(error) => {
        print('completions Error:', (error, error->stack))
        []
      }
    }
  }
  a->onHover = fn (filePath: String, position: Position) -> Option<Hover> {
    print('onHover')
    // let context = match contexts.get(filePath) {
    //   Some(context) => context
    //   None => return None
    // }
    let file: File = context->files->[path->resolve(path->normalize(filePath))].transmute()
    if not file then return None
    let module: Module = file->ast.transmute()
    if not module then return None

    let mut visitor = HoverVisitor.new(position)

    let result = asResult(|| {
      visitor.visitModule(module)
    })

    match result {
      Ok(_) => {
        print('onHover ok', visitor.hover)
        visitor.hover
      }
      Err(error) => {
        print('onHover Error:', (error, error->stack))
        None
      }
    }
  }
  a->onDefinition = fn (filePath: String, position: Position) -> List<Definition> {
    print('onDefinition')
    // let context = match contexts.get(filePath) {
    //   Some(context) => context
    //   None => return []
    // }
    let file: File = context->files->[path->resolve(path->normalize(filePath))].transmute()
    if not file then return []
    let module: Module = file->ast.transmute()
    if not module then return []

    let mut visitor = DefinitionVisitor.new(file, position)

    let result = asResult(|| {
      visitor.visitModule(module)
    })
    match result {
      Ok(_) => {
        print('onDefinition ok', visitor.definitions)
        visitor.definitions
      }
      Err(error) => {
        print('onDefinition Error:', (error, error->stack))
        []
      }
    }
  }
  a
}
