import 'puck:js' as {Array, Error, typeof}
import 'ast/ast.puck' as {
  Token
  Module
  Identifier
  TypePath
}
import 'ast/span.puck' as {ToSpan}
import 'typeck/src/range.puck' as {getRange}

export type UnparsedFile {
  isBin: Bool
  fileName: String
  absolutePath: String
  puck: String
}

export type File {
  isBin: Bool
  fileName: String
  projectPath: String
  absolutePath: String
  outDir: String
  outFile: String

  puck: String
  ast: Module
  js: String
}

fn getFunctionTypeName(function: Function) {
  getTupleTypeName(function.parameters.map(|a| a.type_)) + ' -> ' +
    (function.returnType and function.returnType.displayName())
}

fn getTupleTypeName(properties: Iterable<Type>) {
  '(' + properties.map(|type_| type_.displayName()).join(', ') + ')'
}

fn getRecordTypeName(properties: ObjectMap<Type>) {
  '{' + properties.toList().map(|(key, type_): (String, Type)| '$key: ' + type_.displayName()).join(', ') + '}'
}

fn getGenericName(name: String, type_: Type, showClassParameters = false) {
  let parameters =
    if let Option::Some(instance) = type_.instance {
      '<' + instance.typeParameters.map(|p| p.displayName()).join(', ') + '>'
    }
    else if showClassParameters
      then if let Option::Some(class) = type_.class {
        '<' + class.typeParameters.map(|p| p.displayName()).join(', ') + '>'
      }
      else ''
    else ''

  if type_.isFunction()
    then parameters + name
    else name + parameters
}

export type Type {
  displayName: Option<String>
  name: Option<String>
  kind: TypeKind
  class: Option<TypeClass>
  instance: Option<TypeInstance>
}

impl Type {
  fn empty() -> Type {{
    displayName: Some('')
    name: None
    kind: TypeKind::Struct({
      implementations: []
      kind: StructKind::Tuple({properties: []})
    })
    class: None
    instance: None
  }}

  fn unused() -> Type {{
    displayName: Some('_')
    name: None
    kind: TypeKind::Parameter({
      defaultValue: None
    })
    class: None
    instance: None
  }}

  fn displayName(self) -> String {
    if not self then return '??'
    if let Option::Some(name) = self.displayName {
      return name
    }
    match self.kind {
      TypeKind::Enum(enum_) => getGenericName(self.name.unwrap(), self)
      TypeKind::Function(function) => self.name.unwrapOrElse(|| getFunctionTypeName(function))
      TypeKind::Parameter(_) => self.name.unwrap()
      TypeKind::Struct(struct) => {
        self.name
          .mapOrElse(
            || match struct.kind {
              StructKind::Record({properties}) => getRecordTypeName(properties)
              StructKind::Tuple({properties}) => getTupleTypeName(properties)
              StructKind::Unit => self.name.unwrap()
            }
            |name| getGenericName(name, self))
      }
      TypeKind::Trait(_) => getGenericName(self.name.unwrap(), self, true)
    }
  }

  fn verboseName(self) -> String {
    if not self then return '??'
    match self.kind {
      TypeKind::Enum(enum_) => getGenericName(self.name.unwrap(), self, true)
      TypeKind::Function(function) => getGenericName(getFunctionTypeName(function), self, true)
      TypeKind::Parameter(_) => self.name.unwrap()
      TypeKind::Struct(struct) => {
        match struct.kind {
          StructKind::Record({properties}) => getRecordTypeName(properties)
          StructKind::Tuple({properties}) => getTupleTypeName(properties)
          StructKind::Unit => self.name.unwrap()
        }
      }
      TypeKind::Trait(_) => getGenericName(self.name.unwrap(), self, true)
    }
  }

  fn getEnum(self: Type) -> Enum {
    match self.kind {
      TypeKind::Enum(enum_) => enum_
      _ => {
        let name = self.displayName()
        throw Error('Type $name is not an enum')
      }
    }
  }

  fn getFunction(self: Type) -> Function {
    match self.kind {
      TypeKind::Function(function) => function
      _ => {
        let name = self.displayName()
        throw Error('Type $name is not a function')
      }
    }
  }

  fn getTrait(self: Type) -> Trait {
    match self.kind {
      TypeKind::Trait(trait_) => trait_
      _ => {
        let name = self.displayName()
        throw Error('Type $name is not a trait')
      }
    }
  }

  fn isEnum(self) -> Bool {
    match self.kind {
      TypeKind::Enum(_) => true
      _ => false
    }
  }

  fn isFunction(self) -> Bool {
    match self.kind {
      TypeKind::Function(_) => true
      _ => false
    }
  }

  fn isParameter(self) -> Bool {
    match self.kind {
      TypeKind::Parameter(_) => true
      _ => false
    }
  }
}

export enum TypeKind {
  Enum(Enum)
  Function(Function)
  Parameter(TypeParameter)
  Struct(Struct)
  Trait(Trait)
}

export type Enum {
  implementations: List<Implementation>
  members: ObjectMap<Type>
}

/// Represents a function type (Num, Num) -> Bool
export type Function {
  selfBinding: Option<Binding>
  parameters: List<Binding>
  parameterRange: Range
  returnType: Type
  isAbstract: Bool
}

/// A data type (the ones declared with the `type` keywords), like String or Num
export type Struct {
  implementations: List<Implementation>
  kind: StructKind
}

export type Trait {
  isShorthand: Bool
  functions: ObjectMap<Type>
}

export enum StructKind {
  Record(Record)
  Tuple(Tuple)
  Unit
}

export type Record {
  properties: ObjectMap<Type>
}

export type Tuple {
  properties: List<Type>
}

export type Implementation {
  type_: Type
  trait_: Type
}

/// Represents a generic type like List<T>
export type TypeClass {
  parameterRange: Range
  typeParameters: List<Type>
  instances: List<Type>
}
impl TypeClass {
  fn fromAstNode(astNode: {typeParameters: List<TypeParameter>}, reportError: (ToSpan, String) -> {}) -> Option<TypeClass> {
    if astNode.typeParameters and astNode.typeParameters.length {
      let parameterRange = getRange(
        astNode.typeParameters
        |p: TypeParameter| p.defaultValue.isSome()
        reportError
        'type parameter'
      )

      Some({
        parameterRange
        typeParameters: []
        typeParameterBindings: astNode.typeParameters
        instances: []
      })
    }
    else None
  }
}

/// Represents an instance of a generic type like List<String> or List<Num>
export type TypeInstance {
  class: Type
  typeParameters: List<Type>
  parameterMap: ObjectMap<Type>
}
export type TypeParameter {
  defaultValue: Option<Type>
}

export type Binding {
  name: String
  token: ToSpan
  mutable: Bool
  type_: Type
  // redefined: Bool
  // previous: Option<Binding>
}

export type TypeBinding {
  name: String
  type_: Type
}

export type Scope {
  getLocalBinding: (String) -> Binding
  getBinding: (String) -> Binding
  getTypeBinding: (String) -> TypeBinding
  getTypePath: (TypePath) -> Result<{name: String, type_: Type}, String>
  define: (Binding, Bool) -> Binding
  defineType: (Type, ToSpan) -> TypeBinding
}

export type ScopeAware {
  scope: Scope
}
