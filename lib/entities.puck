import 'puck:js' as {Array, typeof}
import 'ast/ast.puck' as {
  Token
  Identifier
  Module
}
import 'typeck/src/range.puck' as {getRange}

export type UnparsedFile {
  fileName: String
  absolutePath: String
  puck: String
}

export type File {
  fileName: String
  projectPath: String
  absolutePath: String
  outDir: String
  outFile: String

  puck: String
  ast: Module
  js: String
}

fn getFunctionTypeName(function: Function) {
  getTupleTypeName(function.arguments.map(|a| a.type_)) + ' -> ' +
    (function.returnType and function.returnType.displayName())
}

fn getTupleTypeName(properties: List<Type>) {
  '(' + properties.map(|type_| type_.displayName()).join(', ') + ')'
}

fn getRecordTypeName(properties: ObjectMap<Type>) {
  '{' + properties.toList().map(|(key, type_): (String, Type)| '$key: ' + type_.displayName()).join(', ') + '}'
}

fn getGenericName(name: String, type_: Type, showClassParameters = false) {
  if let Option::Some(instance) = type_.instance {
    name + '<' + instance.typeParameters.map(|p: Type| p.displayName()).join(', ') + '>'
  }
  else if showClassParameters
    then if let Option::Some(class) = type_.class {
      name + '<' + class.typeParameters.map(|p: Type| p.displayName()).join(', ') + '>'
    }
    else name
  else name
}

export type Type {
  displayName: Option<String>
  name: Option<String>
  kind: TypeKind
  class: Option<TypeClass>
  instance: Option<TypeInstance>
}

impl Type {
  fn empty() -> Type {{
    displayName: Some('')
    name: None
    kind: TypeKind::Struct({
      implementations: []
      kind: StructKind::Tuple({properties: []})
    })
    class: None
    instance: None
  }}

  fn displayName(self: Type) -> String {
    if not self then return '??'
    if let Option::Some(name) = self.displayName {
      return name
    }
    match self.kind {
      TypeKind::Enum(enum_) => getGenericName(self.name.unwrap(), self)
      TypeKind::Function(function) => self.name.unwrapOrElse(|| getFunctionTypeName(function))
      TypeKind::Parameter(_) => self.name.unwrap()
      TypeKind::Struct(struct) => {
        self.name
          .mapOrElse(
            || match struct.kind {
              StructKind::Record({properties}) => getRecordTypeName(properties)
              StructKind::Tuple({properties}) => getTupleTypeName(properties)
              StructKind::Unit => 'unit'
            }
            |name| getGenericName(name, self))
      }
      TypeKind::Trait(_) => getGenericName(self.name.unwrap(), self, true)
    }
  }

  fn getFunction(self: Type) -> Function {
    match self.kind {
      TypeKind::Function(function) => function
      _ => throw 'Type is not a function'
    }
  }

  fn getTrait(self: Type) -> Trait {
    match self.kind {
      TypeKind::Trait(trait_) => trait_
      _ => throw 'Type is not a trait'
    }
  }
}

export enum TypeKind {
  Enum(Enum)
  Function(Function)
  Parameter(TypeParameter)
  Struct(Struct)
  Trait(Trait)
}

export type Enum {
  implementations: List<Implementation>
  members: ObjectMap<Type>
}

/// Represents a function type (Num, Num) -> Bool
export type Function {
  selfBinding: Option<Binding>
  arguments: List<Binding>
  argumentRange: Range
  returnType: Type
  isAbstract: Bool
}

/// A data type (the ones declared with the `type` keywords), like String or Num
export type Struct {
  implementations: List<Implementation>
  kind: StructKind
}

export type Trait {
  isShorthand: Bool
  functions: ObjectMap<Function>
}

export enum StructKind {
  Record(Record)
  Tuple(Tuple)
  Unit
}

export type Record {
  properties: ObjectMap<Type>
}

export type Tuple {
  properties: List<Type>
}

export type Implementation {
  type_: Type
  trait_: Type
}

/// Represents a generic type like List<T>
export type TypeClass {
  parameterRange: Range
  typeParameters: List<Type>
  instances: List<Type>
}
impl TypeClass {
  fn fromAstNode(astNode, reportError) -> Option<TypeClass> { // : {typeParameters: List<TypeParameter>}
    if astNode.typeParameters and astNode.typeParameters.length {
      let parameterRange = getRange(
        astNode.typeParameters
        |p: TypeParameter| p.defaultValue.isJust()
        reportError
        'type parameter'
      )

      Some({
        parameterRange
        typeParameters: []
        typeParameterBindings: astNode.typeParameters
        instances: []
      })
    }
    else None
  }
}

/// Represents an instance of a generic type like List<String> or List<Num>
export type TypeInstance {
  class: Type
  typeParameters: List<Type>
  parameterMap: ObjectMap<Type>
}
export type TypeParameter {
  defaultValue: Option<Type>
}

export type Binding {
  name: String
  // token: Token
  mutable: Bool
  type_: Type
  // redefined: Bool
  // previous: Option<Binding>
}

export type TypeBinding {
  name: String
  type_: Type
}

export type Scope {
  getLocalBinding: (String) -> Binding
  // getBinding: (String, allowRedeclare = true) -> Binding
  getBinding: (String) -> Binding
  getTypeBinding: (String) -> TypeBinding
  define: (Binding, Bool) -> Binding
  defineType: (Type, Bool) -> TypeBinding
}

export type ScopeAware {
  scope: Scope
}
