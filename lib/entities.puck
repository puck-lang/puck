import 'puck:js' as {Array, Error, Object, typeof}
import 'ast/ast.puck' as {
  Module
  Identifier
  TypePath
  TypeParameter: AstTypeParameter
}
import 'ast/span.puck' as {Span, ToSpan}
import 'typeck/src/range.puck' as {getRange}
import 'typeck/src/scope.puck' as {Binding}

export type BuildFile {
  isBin: Bool
  file: String
  outFile: String
}

export type UnparsedFile {
  isBin: Bool
  fileName: String
  absolutePath: String
  puck: String
}

export type File {
  isBin: Bool
  fileName: String
  projectPath: String
  absolutePath: String
  outDir: String
  outFile: String

  puck: String
  // ast: Module
  js: String
}

let startWithNumber = RegExp.new('^[0-9]')

fn getFunctionTypeName(function: Function) {
  let mut parameters = function.parameters
    .map(|b| {
      let typeName = b.type_.displayName()
      let typed =
        if startWithNumber.test(b.name)
          then typeName
          else b.name + ': $typeName'
      if b.mutable
        then 'mut $typed'
        else typed
    })
    .toList()
  if let Some(selfBinding) = function.selfBinding {
    if selfBinding.mutable
      then parameters.lpush('mut self')
      else parameters.lpush('self')
  }
  let parameters = parameters->join(', ')
  let returnType = function.returnType.displayName()

  '($parameters) -> $returnType'
}

fn getTupleTypeName(properties: Iterable<Type>) {
  '(' + properties.map(|type_| type_.displayName())->join(', ') + ')'
}

fn getRecordTypeName(properties: ObjectMap<Type>) {
  '{' + properties.toList().map(|(key, type_): (String, Type)| '$key: ' + type_.displayName())->join(', ') + '}'
}

fn getGenericName(name: String, type_: Type, showClassParameters = false) {
  let parameters =
    if let Option::Some(instance) = type_.instance {
      '<' + instance.typeParameters.map(|p| p.displayName())->join(', ') + '>'
    }
    else if showClassParameters
      then if let Option::Some(class) = type_.class {
        '<' + class.typeParameters.map(|p| p.displayName())->join(', ') + '>'
      }
      else ''
    else ''

  if type_.isFunction()
    then parameters + name
    else name + parameters
}

export type Type {
  id: Option<String>
  displayName: Option<String>
  name: Option<String>
  kind: TypeKind
  class: Option<TypeClass>
  instance: Option<TypeInstance>
  /// A type definition will have a type like (String) -> String as it can be used as
  /// a function and doesn't contain any properties directly.
  /// providesType will then point to the type defined by the definition (like String)
  providesType: Option<Type>
  /// If this type is a member of an enum, enumMember will contain the
  /// member name and a pointer to the enum type
  enumMember: Option<(String, Type)>
}

impl Type {
  fn empty() -> Type {{
    id: None
    displayName: Some('()')
    name: None
    kind: TypeKind::Struct({
      implementations: []
      kind: StructKind::Tuple({properties: []})
    })
    class: None
    instance: None
    providesType: None
    enumMember: None
  }}

  fn provides(mut type_: Type) -> Type {{
    id: None
    displayName: type_.displayName
    name: type_.name
    kind: TypeKind::Struct({
      implementations: []
      kind: StructKind::Tuple({properties: []})
    })
    class: type_.class
    instance: type_.instance
    providesType: Some(type_)
    enumMember: None
  }}

  fn unused() -> Type {{
    id: None
    displayName: Some('_')
    name: None
    kind: TypeKind::Parameter({
      defaultValue: None
    })
    class: None
    instance: None
    providesType: None
    enumMember: None
  }}

  fn displayName(self) -> String {
    if not self then return '??'
    if let Option::Some(name) = self.displayName {
      return name
    }
    match self.kind {
      TypeKind::Enum(enum_) => getGenericName(self.name.unwrap(), self)
      TypeKind::Function(function) => self.name.unwrapOrElse(|| getFunctionTypeName(function))
      TypeKind::Parameter(_) => self.name.unwrap()
      TypeKind::Struct(struct) => {
        self.name
          .mapOrElse(
            || match struct.kind {
              StructKind::Record({properties}) => getRecordTypeName(properties)
              StructKind::Tuple({properties}) => getTupleTypeName(properties)
              StructKind::Unit => self.name.unwrap()
            }
            |name| getGenericName(name, self))
      }
      TypeKind::Trait(_) => getGenericName(self.name.unwrap(), self, true)
    }
  }

  fn verboseName(self) -> String {
    if not self then return '??'
    match self.kind {
      TypeKind::Enum(enum_) => getGenericName(self.name.unwrap(), self, true)
      TypeKind::Function(function) => getGenericName(getFunctionTypeName(function), self, true)
      TypeKind::Parameter(_) => self.name.unwrap()
      TypeKind::Struct(struct) => {
        match struct.kind {
          StructKind::Record({properties}) => getRecordTypeName(properties)
          StructKind::Tuple({properties}) => getTupleTypeName(properties)
          StructKind::Unit => self.name.unwrap()
        }
      }
      TypeKind::Trait(_) => getGenericName(self.name.unwrap(), self, true)
    }
  }

  fn getEnum(self: Type) -> Enum {
    match self.kind {
      TypeKind::Enum(enum_) => enum_
      _ => {
        let name = self.displayName()
        throw Error('Type $name is not an enum')
      }
    }
  }

  fn getFunction(self: Type) -> Function {
    match self.kind {
      TypeKind::Function(function) => function
      _ => {
        let name = self.displayName()
        throw Error('Type $name is not a function')
      }
    }
  }

  fn getTrait(self: Type) -> Trait {
    match self.kind {
      TypeKind::Trait(trait_) => trait_
      _ => {
        let name = self.displayName()
        throw Error('Type $name is not a trait')
      }
    }
  }

  fn isEmpty(self) -> Bool {
    match self.kind {
      TypeKind::Struct(struct) => match struct.kind {
        StructKind::Tuple(tuple) => tuple.properties.isEmpty()
        _ => false
      }
      _ => false
    }
  }

  fn isNever(self) -> Bool {
    match self.kind {
      TypeKind::Enum(enum_) => enum_.members.isEmpty()
      _ => false
    }
  }

  fn isEnum(self) -> Bool {
    match self.kind {
      TypeKind::Enum(_) => true
      _ => false
    }
  }

  fn isFunction(self) -> Bool {
    match self.kind {
      TypeKind::Function(_) => true
      _ => false
    }
  }

  fn isParameter(self) -> Bool {
    match self.kind {
      TypeKind::Parameter(_) => true
      _ => false
    }
  }

  fn typeParameters(self) -> Option<List<Type>> {
    self.instance
      .map(|i| i.typeParameters)
      .orValue(self.class.map(|i| i.typeParameters))
  }
}

export enum TypeKind {
  Enum(Enum)
  Function(Function)
  Parameter(TypeParameter)
  Struct(Struct)
  Trait(Trait)
}

export type Enum {
  implementations: List<Implementation>
  members: ObjectMap<Type>
}

/// Represents a function type (Num, Num) -> Bool
export type Function {
  selfBinding: Option<Binding>
  parameters: List<Binding>
  parameterRange: Range
  returnType: Type
  isAbstract: Bool
}

/// A data type (the ones declared with the `type` keywords), like String or Num
export type Struct {
  implementations: List<Implementation>
  kind: StructKind
}

export type Trait {
  isShorthand: Bool
  functions: ObjectMap<Type>
}

export enum StructKind {
  Record(Record)
  Tuple(Tuple)
  Unit
}

export type Record {
  properties: ObjectMap<Type>
}

export type Tuple {
  properties: List<Type>
}

export type Implementation {
  type_: Type
  trait_: Type
  typeParameters: List<Type>
}

/// Represents a generic type like List<T>
export type TypeClass {
  parameterRange: Range
  typeParameters: List<Type>
  instances: List<Type>
}
impl TypeClass {
  fn fromAstNode(astNode: {typeParameters: List<AstTypeParameter>}, reportError: (ToSpan, String) -> ()) -> Option<TypeClass> {
    if astNode.typeParameters and astNode.typeParameters.size() {
      let parameterRange = getRange(
        astNode.typeParameters
        |p| p.defaultValue.isSome()
        reportError
        'type parameter'
      )

      Some({
        parameterRange
        typeParameters: []
        typeParameterBindings: astNode.typeParameters
        instances: []
      })
    }
    else None
  }
}

/// Represents an instance of a generic type like List<String> or List<Num>
export type TypeInstance {
  class: Type
  typeParameters: List<Type>
  parameterMap: ObjectMap<Type>
}
export type TypeParameter {
  defaultValue: Option<Type>
}
