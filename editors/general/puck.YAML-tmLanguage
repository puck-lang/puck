# [PackageDev] target_format: plist, ext: tmLanguage
name: Puck
scopeName: source.puck
fileTypes: [puck]
uuid: a41aff1d-d311-48de-b928-5f01cc93818b

patterns:
- include: '#expression'

repository:
  comment:
    name: comment.puck
    patterns:
    - include: '#comment-line'

  arithmetic-operator:
    name: keyword.operator.arithmetic.puck
    match: \*\*|\*|/|\-|\+|%

  array-literal:
    name: meta.array.literal.puck
    begin: \[
    beginCaptures:
      '0': {name: meta.brace.square.puck}
    end: \]
    endCaptures:
      '0': {name: meta.brace.square.puck}
    patterns:
    - include: '#expression'

  assignment-operator:
    name: keyword.operator.assignment.puck
    match: \*\*=|\*=|(?<!\()/=|%=|\+=|\-=

  await-modifier:
    name: storage.modifier.puck
    match: \bawait\b

  block:
    name: meta.block.puck
    begin: \{
    beginCaptures:
      '0': {name: meta.brace.curly.puck}
    end: \}
    endCaptures:
      '0': {name: meta.brace.curly.puck}
    patterns:
    - include: '#object-member'
    - include: '#expression'

  boolean-literal:
    name: constant.language.boolean.puck
    match: \b(false|true)\b

  comment-line:
    name: comment.line.puck
    match: (//).*$\n?

  control-keyword:
    name: keyword.control.puck
    match: (?<!\.)\b(break|catch|continue|debugger|else|finally|for|if|return|loop|then|throw|try|while|yield)\b

  decl-block:
    name: meta.decl.block.puck
    begin: \{
    beginCaptures:
      '0': {name: meta.brace.curly.puck}
    end: \}
    endCaptures:
      '0': {name: meta.brace.curly.puck}
    patterns:
    - include: '#expression'

  declaration:
    name: meta.declaration.puck
    patterns:
    - include: '#function-declaration'
    - include: '#object-declaration'
    - include: '#type-declaration'

  expression:
    name: meta.expression.puck
    patterns:
    - include: '#for-in-simple'
    - include: '#string'
    - include: '#regex'
    - include: '#template'
    - include: '#comment'
    - include: '#literal'
    - include: '#paren-expression'
    - include: '#var-expr'
    - include: '#declaration'
    - include: '#new-expr'
    - include: '#block'
    - include: '#import-operator'
    - include: '#expression-operator'
    - include: '#imply-operator'
    - include: '#relational-operator'
    - include: '#arithmetic-operator'
    - include: '#logic-operator'
    - include: '#assignment-operator'
    - include: '#storage-keyword'
    - include: '#type-primitive'
    - include: '#function-call'
    - include: '#control-keyword'

  expression-operator:
    name: keyword.others.puck
    match: \b(in|as|is)\b

  expression-type:
    name: meta.expression.puck
    patterns:
    - include: '#string'
    - include: '#regex'
    - include: '#template'
    - include: '#comment'
    - include: '#literal'
    - include: '#paren-expression'
    # - include: '#if-expression'
    - include: '#import-operator'
    - include: '#expression-operator'
    - include: '#imply-operator'
    - include: '#relational-operator'
    - include: '#arithmetic-operator'
    - include: '#logic-operator'
    - include: '#assignment-operator'
    - include: '#type-primitive'
    - include: '#function-call'

  field-declaration:
    name: meta.field.declaration.puck
    begin: (?<!\()\s*((?:\b[a-zA-Z_$][\w$]*)|(?:\'[^']*\')|(?:\"[^"]*\"))\s*(\?\s*)?(?=(=|:))
    beginCaptures:
      '1': {name: variable.puck}
      '2': {name: keyword.others.puck}
    end: (?=\}|;|,|$)|(?<=\})
    patterns:
    - include: '#expression'

  for-in-simple:
    name: forin.expr.puck
    match: \s*\b([a-zA-Z_$][\w$]*)\s+(in)\b
    captures:
      '2': {name: keyword.others.puck}

  function-call:
    name: functioncall.expr.puck
    patterns:
    - include: '#await-modifier'
    - include: '#type-parameters'
    - include: '#paren-expression'

  function-declaration:
    name: meta.function.puck
    begin: \b(?:(export)\s+)?(?:(async)\s+)?(fn\b)(?:\s+([a-zA-Z_$][\w$]*))?\s*
    beginCaptures:
      '1': {name: storage.type.puck}
      '2': {name: storage.modifier.puck}
      '3': {name: storage.type.function.puck}
      '4': {name: entity.name.function.puck}
    end: (?=;|\})|(?<=\})
    patterns:
    - include: '#comment'
    - include: '#type-parameters'
    - include: '#function-type-parameters'
    - include: '#return-type'
    - include: '#function-overload-declaration'
    - include: '#decl-block'

  function-overload-declaration:
    name: meta.function.overload.puck
    match: \b(?:(export)\s+)?(fn\b)(?:\s+([a-zA-Z_$][\w$]*))?\s*
    captures:
      '1': {name: storage.type.puck}
      '2': {name: storage.type.function.puck}
      '3': {name: entity.name.function.puck}

  function-type-parameters:
    name: meta.function.type.parameter.puck
    begin: \(
    beginCaptures:
      '0': {name: meta.brace.round.puck}
    end: \)
    endCaptures:
      '0': {name: meta.brace.round.puck}
    patterns:
    - include: '#comment'
    - include: '#parameter-name'
    - include: '#type-annotation'
    - include: '#variable-initializer'

  imply-operator:
    name: keyword.operator.puck
    match: =>

  import-operator:
    name: keyword.control.import.include.puck
    match: \b(import|from)\b

  indexer-declaration:
    name: meta.indexer.declaration.puck
    begin: \[
    beginCaptures:
      '0': {name: meta.brace.square.puck}
    end: (\])\s*(\?\s*)?|$
    endCaptures:
      '1': {name: meta.brace.square.puck}
      '2': {name: keyword.others.puck}
    patterns:
    - include: '#type-annotation'
    - include: '#indexer-parameter'
    - include: '#expression'

  indexer-parameter:
    name: meta.indexer.parameter.puck
    match: ([a-zA-Z_$][\w$]*)(?=\:)
    captures:
      '1': {name: variable.parameter.puck}

  literal:
    name: literal.puck
    patterns:
    - include: '#numeric-literal'
    - include: '#boolean-literal'
    - include: '#array-literal'
    - include: '#this-literal'

  logic-operator:
    name: keyword.operator.arithmetic.puck
    match: \b(not|and|or)\b

  numeric-literal:
    name: constant.numeric.puck
    match: \b(?<=[^$])((0(x|X)[0-9a-fA-F]+)|(0(o|O)[0-7]+)|(0(b|B)(0|1)+)|(([0-9]+(\.[0-9]+)?))([eE]([+-]?)[0-9]+(\.[0-9]+)?)?)\b

  object-body:
    name: meta.object.body.puck
    begin: \{
    beginCaptures:
      '0': {name: meta.brace.curly.puck}
    end: \}
    endCaptures:
      '0': {name: meta.brace.curly.puck}
    patterns:
    - include: '#string'
    - include: '#comment'
    - include: '#field-declaration'
    - include: '#indexer-declaration'
    - include: '#type-annotation'
    - include: '#variable-initializer'
    - include: '#static-modifier'
    - include: '#property-accessor'

  object-declaration:
    name: meta.declaration.object.puck
    begin: \b(?:(export)\s+)?\b(?:(abstract)\s+)?\b(?<!\.)(class|interface)\b
    beginCaptures:
      '1': {name: storage.type.puck}
      '2': {name: storage.modifier.puck}
      '3': {name: storage.type.puck}
    end: (?<=\})
    endCaptures:
      '1': {name: brace.curly.puck}
    patterns:
    - include: '#comment'
    - include: '#object-name'
    - include: '#type-parameters'
    - include: '#object-body'

  object-member:
    name: meta.object.member.puck
    begin: '[a-zA-Z_$][\w$]*\s*:'
    end: (?=,|\})
    patterns:
    - include: '#expression'

  object-name:
    name: meta.object.name.puck
    match: '[a-zA-Z_$][\w$]*'
    captures:
      '0': {name: entity.name.class.puck}

  parameter-name:
    name: parameter.name.puck
    match: (?:\s*\b(public|private|protected)\b\s+)?(\.\.\.)?\s*([a-zA-Z_$][\w$]*)\s*(\??)
    captures:
      '1': {name: storage.modifier.puck}
      '2': {name: keyword.others.puck}
      '3': {name: variable.parameter.puck}
      '4': {name: keyword.others.puck}

  paren-expression:
    begin: \(
    beginCaptures:
      '0': {name: meta.brace.paren.puck}
    end: \)
    endCaptures:
      '0': {name: meta.brace.paren.puck}
    patterns:
    - include: '#expression'

  property-accessor:
    name: storage.type.property.puck
    match: \b(get|set)\b

  qstring-double:
    name: string.double.puck
    begin: '"'
    end: '"|(?:[^\\\n]$)'
    patterns:
    - include: '#string-character-escape'

  qstring-single:
    name: string.single.puck
    begin: ''''
    end: \'|(?:[^\\\n]$)
    patterns:
    - include: '#string-character-escape'

  regex:
    name: string.regex.puck
    begin: (?<=[=(:,\[]|^|return|&&|\|\||!)\s*(/)(?![/*+{}?])
    end: $|(/)[igm]*
    patterns:
    - name: constant.character.escape.puck
      match: \\.
    - name: constant.character.class.puck
      match: \[(\\\]|[^\]])*\]

  relational-operator:
    name: keyword.operator.comparison.puck
    match: ==|!=|<=|>=|=|<|>

  return-type:
    name: meta.return.type.puck
    begin: '(?<=\))\s*:'
    end: (?=$)|(?=\{|;|//)
    patterns:
    - include: '#type'

  self-literal:
    name: constant.language.self.puck
    match: \b(self)\b

  storage-keyword:
    name: storage.type.puck
    match: \b((let( mut)?)|fn|const|export)\b

  string:
    name: string.puck
    patterns:
    - include: '#qstring-single'
    - include: '#qstring-double'

  string-character-escape:
    name: constant.character.escape
    match: \\(x\h{2}|[0-2][0-7]{,2}|3[0-6][0-7]?|37[0-7]?|[4-7][0-7]?|['"nrt\\]|$)

  template:
    name: meta.template.puck
    begin: '`'
    beginCaptures:
      '0': {name: string.template.puck}
    end: '`'
    endCaptures:
      '0': {name: string.template.puck}
    patterns:
    - include: '#template-substitution-element'
    - include: '#template-string-contents'

  template-string-contents:
    name: string.template.puck
    begin: .*?
    end: (?=(\$\{|`))
    patterns:
    - include: '#string-character-escape'

  template-substitution-element:
    name: template.element.puck
    begin: \$\{
    beginCaptures:
      '0': {name: keyword.others.puck}
    end: \}
    endCaptures:
      '0': {name: keyword.others.puck}
    patterns:
    - include: '#expression'

  type:
    name: meta.type.puck
    patterns:
    - include: '#type-primitive'
    - include: '#type-parameters'
    - include: '#type-tuple'
    - include: '#type-object'
    - include: '#type-operator'
    - include: '#type-paren-or-function-type-parameters'
    - include: '#type-function-return-type'
    - include: '#type-name'

  type-annotation:
    name: meta.type.annotation.puck
    begin: ':'
    end: (?=$|[,);\}\]]|//)|(?==[^>])|(?<=[\}>\]\)]|[a-zA-Z_$])\s*(?=\{)
    patterns:
    - include: '#expression-operator'
    - include: '#type'
    - include: '#string'
    - include: '#comment'

  type-declaration:
    name: meta.type.declaration.puck
    begin: \b(type)\b\s+([a-zA-Z_$][\w$]*)\s*
    beginCaptures:
      '1': {name: keyword.other.puck}
      '2': {name: entity.name.class.puck}
    end: (?=$|[,);>]|type|fn|trait)
    patterns:
    - include: '#type-parameters'
    - include: '#type'
    - name: keyword.operator.comparison.puck
      match: =\s*

  type-function-return-type:
    name: meta.type.function.return.puck
    begin: =>
    beginCaptures:
      '0': {name: keyword.operator.puck}
    end: (?=\s*[,\)\{=;>]|//|$)
    patterns:
    - include: '#type'

  type-name:
    name: meta.type.name.puck
    match: '[a-zA-Z_$][.\w$]*'
    captures:
      '1': {name: entity.name.type.puck}

  type-object:
    name: meta.object.type.puck
    begin: \{
    beginCaptures:
      '0': {name: meta.brace.curly.puck}
    end: \}
    endCaptures:
      '0': {name: meta.brace.curly.puck}
    patterns:
    - include: '#comment'
    - include: '#field-declaration'
    - include: '#method-declaration'
    - include: '#indexer-declaration'
    - include: '#type-annotation'

  type-operator:
    name: keyword.operator.type.puck
    match: '[.|]'

  type-parameters:
    name: meta.type.parameters.puck
    begin: ([a-zA-Z_$][\w$]*)?(<)
    beginCaptures:
      '1': {name: entity.name.type.puck}
      '2': {name: meta.brace.angle.puck}
    end: (?=$)|(>)
    endCaptures:
      '2': {name: meta.brace.angle.puck}
    patterns:
    - name: keyword.other.puck
      match: \b(extends)\b
    - include: '#comment'
    - include: '#type'

  type-paren-or-function-type-parameters:
    name: meta.type.paren.cover.puck
    begin: (?:\b(new)\b)?\s*\(
    beginCaptures:
      '1': {name: keyword.control.puck}
    end: \)
    patterns:
    - include: '#comment'
    - include: '#type'
    - include: '#function-type-parameters'

  type-tuple:
    name: meta.type.tuple.puck
    begin: \[
    beginCaptures:
      '0': {name: meta.brace.square.puck}
    end: \]
    endCaptures:
      '0': {name: meta.brace.square.puck}
    patterns:
    - include: '#type'
    - include: '#comment'

  var-expr:
    name: meta.var.expr.puck
    begin: (?<!\()\s*\b(let(?!\s+mut)|const)\b
    beginCaptures:
      '1': {name: storage.type.puck}
    end: (?=$|;)
    patterns:
    - include: '#var-single-variable'
    - include: '#comment'

  var-single-variable:
    name: meta.var-single-variable.expr.puck
    begin: \b([a-zA-Z_$][\w$]*)\s*(=?)
    beginCaptures:
      '1': {name: variable.puck}
    end: (?=$|[;,])
    patterns:
    - include: '#type-annotation'
    - include: '#string'
    - include: '#comment'
    - include: '#expression'

  variable-initializer:
    begin: (=)
    beginCaptures:
      '1': {name: keyword.operator.comparison.puck}
    end: (?=$|[,);=])
    patterns:
    - include: '#expression'
