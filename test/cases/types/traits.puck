export trait Empty {}
export trait Functions {
  fn noBody(): Num

  fn withBody(self, a: String) {
    let b = a
    b
  }
}
export trait SelfAware {
  fn static(): Num then 5
  fn withImmutableSelf(self, a: String) then a
  fn withMutableSelf(mut self) then self
}
export trait Generic<T> {
  fn generic(a: T): T
}
export trait GenericSelf<T> {
  fn genericSelf(self, a: GenericSelf<T>): T
}

export type EmptyType {}
export type FunctionsType {
  name: String
}
export type GenericType<T> {}

impl Empty for EmptyType {}

impl Functions for EmptyType {
  fn noBody() then 5
}

impl Functions for FunctionsType {
  fn noBody() then 5
  fn withBody(self, a: String) then self.name
}

impl<T> Generic<T> for GenericType<T> {
  fn generic(a: T) then a
}

impl<T> GenericSelf<T> for GenericType<String> {
  fn genericSelf(self, a: GenericSelf<T>) then a
}

impl Generic<String> for GenericType<String> {
  fn generic(a: String) then a + a
}

impl SelfAware for FunctionsType {}

Functions.noBody()
let func: FunctionsType = {name: 'func'}
func.withBody('body')

let mut mutFunc = func
mutFunc.withMutableSelf()

let genericNum: GenericType<Num> = {}
genericNum.generic(5)
let genericString: GenericType<String> = {}
genericString.generic('hello')
