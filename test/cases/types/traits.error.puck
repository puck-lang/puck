///// EmptyType is not a trait
import 'traits.puck' as {EmptyType}
impl EmptyType for EmptyType {}

///// Functions is not a struct or an enum
import 'traits.puck' as {Functions}
impl Functions for Functions {}

///// Empty has already been implemented for FunctionsType
import 'traits.puck' as {Empty, FunctionsType}
impl Empty for FunctionsType {}
impl Empty for FunctionsType {}

///// Trait functions must have a return type
import 'traits.puck' as {Functions, FunctionsType}
impl Functions for FunctionsType {
  fn noBody() {1}
}

///// Functions has already been implemented for FunctionsType
import 'traits.puck' as {Functions, FunctionsType}
impl Functions for FunctionsType {
  fn noBody() -> Num {1}
}

///// Generic<String> has already been implemented for FunctionsType
import 'traits.puck' as {Generic, FunctionsType}
impl Generic<String> for FunctionsType {
  fn generic(self, a: String) -> String {a}
}
impl Generic<String> for FunctionsType {
  fn generic(self, a: String) -> String {a}
}

///// Generic<T> has already been implemented for FunctionsType
import 'traits.puck' as {Generic, FunctionsType}
impl<T> Generic<T> for FunctionsType {
  fn generic<T>(self, a: T) -> T {a}
}
impl<T> Generic<T> for FunctionsType {
  fn generic<T>(self, a: T) -> T {a}
}

///// Generic<Num> has already been implemented for GenericType<Num>
import 'traits.puck' as {Generic, GenericType}
impl Generic<Num> for GenericType<Num> {
  fn generic(self, a: Num) -> Num {a}
}
impl Generic<Num> for GenericType<Num> {
  fn generic(self, a: Num) -> Num {a}
}

///// Function Functions::noBody is not implemented for GenericType<String>
import 'traits.puck' as {GenericType, Functions}
impl Functions for GenericType<String> {}

///// Function anotherFunction is not defined by Empty
import 'traits.puck' as {Empty, FunctionsType}
impl Empty for FunctionsType {
  fn anotherFunction() -> () {}
}

///// Function SelfAware::static is static
import 'traits.puck' as {SelfAware, EmptyType}
impl SelfAware for EmptyType {
  fn static(self) -> Num {5}
}

///// Too many arguments given to static, 0 required, 1 given
import 'traits.puck' as {SelfAware, EmptyType}
impl SelfAware for EmptyType {
  fn static(a: Num) -> Num {a}
}

///// Return type String is not assignable to Num
import 'traits.puck' as {SelfAware, EmptyType}
impl SelfAware for EmptyType {
  fn static() -> String {''}
}

///// Function SelfAware::withImmutableSelf requires a self parameter
import 'traits.puck' as {SelfAware, EmptyType}
impl SelfAware for EmptyType {
  fn withImmutableSelf() -> String {'a'}
}

///// Function SelfAware::withImmutableSelf requires a self parameter
import 'traits.puck' as {SelfAware, EmptyType}
impl SelfAware for EmptyType {
  fn withImmutableSelf(a: String) -> String {a}
}

///// Function SelfAware::withImmutableSelf requires an immutable self parameter
import 'traits.puck' as {SelfAware, EmptyType}
impl SelfAware for EmptyType {
  fn withImmutableSelf(mut self, a: String) -> String {a}
}

///// Types of parameter #0 does not match. Num is not assignable to String
import 'traits.puck' as {SelfAware, EmptyType}
impl SelfAware for EmptyType {
  fn withImmutableSelf(self, a: Num) -> Num {a}
}

///// Parameter #0 is required to be immutable
import 'traits.puck' as {SelfAware, EmptyType}
impl SelfAware for EmptyType {
  fn withImmutableSelf(self, mut a: String) -> String {a}
}

///// A is already defined
trait A {}
let A = true

///// Functions has no function named missing
import 'traits.puck' as {Functions}
Functions.missing()

///// Functions::withBody takes a self parameter and can't be called directly
import 'traits.puck' as {Functions}
Functions.withBody('a')

///// withMutableSelf can only be called on a mutable binding
import 'traits.puck' as {SelfAware, FunctionsType}
let a: FunctionsType = {name: 'a'}
a.withMutableSelf()

///// Num is not assignable to type String
import 'traits.puck' as {Functions, FunctionsType}
let a: FunctionsType = {name: 'a'}
a.withBody(5)

///// The function withBody is defined in trait Functions but it is not in scope
import 'traits.puck' as {FunctionsType}
let a: FunctionsType = {name: 'a'}
a.withBody('body')

///// Ambiguous trait call
import 'traits.puck' as {Generic, GenericType}

export trait GenericSelf<T> {
  fn generic(self, a: GenericSelf<T>) -> T
}

impl<T> GenericSelf<T> for GenericType<T> {
  fn generic(self, a: GenericSelf<T>) -> GenericSelf<T> {a}
}

let genericNum: GenericType<Num> = {}
genericNum.generic(5)

///// Bool is not assignable to type Num
import 'traits.puck' as {Generic, GenericType}
let genericNum: GenericType<Num> = {}
genericNum.generic(true)


///// Use of undefined variable b
trait Trait {
  fn a(self) -> String {
    b()
  }

  fn b(self) -> String {
    a()
  }
}

///// Trait is not assignable to type Num
trait Trait {
  fn a(self: Num) -> () {}
}
